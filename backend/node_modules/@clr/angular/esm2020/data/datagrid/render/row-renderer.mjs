/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { ContentChildren, Directive } from '@angular/core';
import { DatagridCellRenderer } from './cell-renderer';
import * as i0 from "@angular/core";
import * as i1 from "../providers/columns.service";
export class DatagridRowRenderer {
    constructor(columnsService) {
        this.columnsService = columnsService;
        this.subscriptions = [];
    }
    ngAfterContentInit() {
        this.setColumnState(); // case #3 and #4
        this.subscriptions.push(this.cells.changes.subscribe(() => {
            this.setColumnState(); // case #2
            // Note on case #2: In the case of dynamic columns, when one column (header/cell together) gets deleted,
            // this.cells.changes emits before this.columnsService.columns gets updated in MainRenderer
            // when this.headers.changes emits as well. So that means there will be n+1 column state providers
            // when this.cells.changes emits. Hence, we should quit earlier there. But this method will be called
            // right after again when this.headers.changes emits. By then, there will be the same number of column state
            // providers as column headers.
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    setColumnState() {
        // This method runs in four cases:
        // 1. When the initial rows appear on the first page.
        //    In this case, the method will be called in DatagridMainRenderer.
        // 2. When columns (corresponding header/cells) get added and deleted.
        //    In this case, the method will be called in DatagridMainRenderer. (Read the note on this case above).
        // 3. When rows load asynchronously.
        //    In this case, the method will be called in this class.
        // 4. When rows load after switching pages.
        //    In this case, the method will be called in this class (Basically, same as the case 3).
        if (this.cells.length === this.columnsService.columns.length) {
            this.cells.forEach((cell, index) => {
                if (this.columnsService.columns[index]) {
                    cell.columnState = this.columnsService.columns[index];
                }
            });
        }
    }
}
DatagridRowRenderer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: DatagridRowRenderer, deps: [{ token: i1.ColumnsService }], target: i0.ɵɵFactoryTarget.Directive });
DatagridRowRenderer.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: DatagridRowRenderer, selector: "clr-dg-row, clr-dg-row-detail", queries: [{ propertyName: "cells", predicate: DatagridCellRenderer }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: DatagridRowRenderer, decorators: [{
            type: Directive,
            args: [{
                    selector: 'clr-dg-row, clr-dg-row-detail',
                }]
        }], ctorParameters: function () { return [{ type: i1.ColumnsService }]; }, propDecorators: { cells: [{
                type: ContentChildren,
                args: [DatagridCellRenderer]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LXJlbmRlcmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvcm93LXJlbmRlcmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFFSCxPQUFPLEVBQW9CLGVBQWUsRUFBRSxTQUFTLEVBQXdCLE1BQU0sZUFBZSxDQUFDO0FBSW5HLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7QUFLdkQsTUFBTSxPQUFPLG1CQUFtQjtJQUs5QixZQUFvQixjQUE4QjtRQUE5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFGMUMsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO0lBRVUsQ0FBQztJQUV0RCxrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsaUJBQWlCO1FBQ3hDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLFVBQVU7WUFDakMsd0dBQXdHO1lBQ3hHLDJGQUEyRjtZQUMzRixrR0FBa0c7WUFDbEcscUdBQXFHO1lBQ3JHLDRHQUE0RztZQUM1RywrQkFBK0I7UUFDakMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsY0FBYztRQUNaLGtDQUFrQztRQUNsQyxxREFBcUQ7UUFDckQsc0VBQXNFO1FBQ3RFLHNFQUFzRTtRQUN0RSwwR0FBMEc7UUFDMUcsb0NBQW9DO1FBQ3BDLDREQUE0RDtRQUM1RCwyQ0FBMkM7UUFDM0MsNEZBQTRGO1FBQzVGLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQzVELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUNqQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUN0QyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUN2RDtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDOztnSEEzQ1UsbUJBQW1CO29HQUFuQixtQkFBbUIsMkZBQ2Isb0JBQW9COzJGQUQxQixtQkFBbUI7a0JBSC9CLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLCtCQUErQjtpQkFDMUM7cUdBRWdELEtBQUs7c0JBQW5ELGVBQWU7dUJBQUMsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDb2x1bW5zU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9jb2x1bW5zLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRDZWxsUmVuZGVyZXIgfSBmcm9tICcuL2NlbGwtcmVuZGVyZXInO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93LCBjbHItZGctcm93LWRldGFpbCcsXG59KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkUm93UmVuZGVyZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkQ2VsbFJlbmRlcmVyKSBwcml2YXRlIGNlbGxzOiBRdWVyeUxpc3Q8RGF0YWdyaWRDZWxsUmVuZGVyZXI+O1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbHVtbnNTZXJ2aWNlOiBDb2x1bW5zU2VydmljZSkge31cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zZXRDb2x1bW5TdGF0ZSgpOyAvLyBjYXNlICMzIGFuZCAjNFxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jZWxscy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0Q29sdW1uU3RhdGUoKTsgLy8gY2FzZSAjMlxuICAgICAgICAvLyBOb3RlIG9uIGNhc2UgIzI6IEluIHRoZSBjYXNlIG9mIGR5bmFtaWMgY29sdW1ucywgd2hlbiBvbmUgY29sdW1uIChoZWFkZXIvY2VsbCB0b2dldGhlcikgZ2V0cyBkZWxldGVkLFxuICAgICAgICAvLyB0aGlzLmNlbGxzLmNoYW5nZXMgZW1pdHMgYmVmb3JlIHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1ucyBnZXRzIHVwZGF0ZWQgaW4gTWFpblJlbmRlcmVyXG4gICAgICAgIC8vIHdoZW4gdGhpcy5oZWFkZXJzLmNoYW5nZXMgZW1pdHMgYXMgd2VsbC4gU28gdGhhdCBtZWFucyB0aGVyZSB3aWxsIGJlIG4rMSBjb2x1bW4gc3RhdGUgcHJvdmlkZXJzXG4gICAgICAgIC8vIHdoZW4gdGhpcy5jZWxscy5jaGFuZ2VzIGVtaXRzLiBIZW5jZSwgd2Ugc2hvdWxkIHF1aXQgZWFybGllciB0aGVyZS4gQnV0IHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgIC8vIHJpZ2h0IGFmdGVyIGFnYWluIHdoZW4gdGhpcy5oZWFkZXJzLmNoYW5nZXMgZW1pdHMuIEJ5IHRoZW4sIHRoZXJlIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNvbHVtbiBzdGF0ZVxuICAgICAgICAvLyBwcm92aWRlcnMgYXMgY29sdW1uIGhlYWRlcnMuXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgc2V0Q29sdW1uU3RhdGUoKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgcnVucyBpbiBmb3VyIGNhc2VzOlxuICAgIC8vIDEuIFdoZW4gdGhlIGluaXRpYWwgcm93cyBhcHBlYXIgb24gdGhlIGZpcnN0IHBhZ2UuXG4gICAgLy8gICAgSW4gdGhpcyBjYXNlLCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGluIERhdGFncmlkTWFpblJlbmRlcmVyLlxuICAgIC8vIDIuIFdoZW4gY29sdW1ucyAoY29ycmVzcG9uZGluZyBoZWFkZXIvY2VsbHMpIGdldCBhZGRlZCBhbmQgZGVsZXRlZC5cbiAgICAvLyAgICBJbiB0aGlzIGNhc2UsIHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgaW4gRGF0YWdyaWRNYWluUmVuZGVyZXIuIChSZWFkIHRoZSBub3RlIG9uIHRoaXMgY2FzZSBhYm92ZSkuXG4gICAgLy8gMy4gV2hlbiByb3dzIGxvYWQgYXN5bmNocm9ub3VzbHkuXG4gICAgLy8gICAgSW4gdGhpcyBjYXNlLCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGluIHRoaXMgY2xhc3MuXG4gICAgLy8gNC4gV2hlbiByb3dzIGxvYWQgYWZ0ZXIgc3dpdGNoaW5nIHBhZ2VzLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBpbiB0aGlzIGNsYXNzIChCYXNpY2FsbHksIHNhbWUgYXMgdGhlIGNhc2UgMykuXG4gICAgaWYgKHRoaXMuY2VsbHMubGVuZ3RoID09PSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnNbaW5kZXhdKSB7XG4gICAgICAgICAgY2VsbC5jb2x1bW5TdGF0ZSA9IHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1uc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIl19