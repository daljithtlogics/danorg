/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from '@angular/core';
import { BehaviorSubject, ReplaySubject } from 'rxjs';
import { MultiSelectComboboxModel } from '../model/multi-select-combobox.model';
import * as i0 from "@angular/core";
export class OptionSelectionService {
    constructor() {
        this.loading = false;
        // Display all options on first open, even if filter text exists.
        // https://github.com/vmware-clarity/ng-clarity/issues/386
        this.showAllOptions = true;
        this._currentInput = '';
        this._inputChanged = new BehaviorSubject('');
        this._selectionChanged = new ReplaySubject(1);
        this.inputChanged = this._inputChanged.asObservable();
    }
    get currentInput() {
        return this._currentInput;
    }
    set currentInput(input) {
        // clear value in single selection model when input is empty
        if (input === '' && !this.multiselectable) {
            this.setSelectionValue(null);
        }
        this._currentInput = input;
        this._inputChanged.next(input);
    }
    // This observable is for notifying the ClrOption to update its
    // selection by comparing the value
    get selectionChanged() {
        return this._selectionChanged.asObservable();
    }
    get multiselectable() {
        return this.selectionModel instanceof MultiSelectComboboxModel;
    }
    select(item) {
        if (item === null || item === undefined || this.selectionModel.containsItem(item)) {
            return;
        }
        this.selectionModel.select(item);
        this._selectionChanged.next(this.selectionModel);
    }
    toggle(item) {
        if (item === null || item === undefined) {
            return;
        }
        if (this.selectionModel.containsItem(item)) {
            this.selectionModel.unselect(item);
        }
        else {
            this.selectionModel.select(item);
        }
        this._selectionChanged.next(this.selectionModel);
    }
    unselect(item) {
        if (item === null || item === undefined || !this.selectionModel.containsItem(item)) {
            return;
        }
        this.selectionModel.unselect(item);
        this._selectionChanged.next(this.selectionModel);
    }
    // TODO: Add support for trackBy and compareFn
    setSelectionValue(value) {
        // NOTE: Currently we assume that no 2 options will have the same value
        // but Eudes and I discussed that this is a possibility but we will handle
        // this later
        // if selection is undefined, or its value hasn't changed, or changing from null <-> undefined, that's not really changing so we return
        if (!this.selectionModel || this.selectionModel.model === value || (!this.selectionModel.model && !value)) {
            return;
        }
        this.selectionModel.model = value;
        this._selectionChanged.next(this.selectionModel);
    }
}
OptionSelectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: OptionSelectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
OptionSelectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: OptionSelectionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: OptionSelectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9uLXNlbGVjdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZm9ybXMvY29tYm9ib3gvcHJvdmlkZXJzL29wdGlvbi1zZWxlY3Rpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFjLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUdsRSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQzs7QUFHaEYsTUFBTSxPQUFPLHNCQUFzQjtJQWNqQztRQWJBLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFLaEIsaUVBQWlFO1FBQ2pFLDBEQUEwRDtRQUMxRCxtQkFBYyxHQUFHLElBQUksQ0FBQztRQUVkLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ25CLGtCQUFhLEdBQUcsSUFBSSxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEMsc0JBQWlCLEdBQUcsSUFBSSxhQUFhLENBQW1CLENBQUMsQ0FBQyxDQUFDO1FBR2pFLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRUQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzVCLENBQUM7SUFDRCxJQUFJLFlBQVksQ0FBQyxLQUFLO1FBQ3BCLDREQUE0RDtRQUM1RCxJQUFJLEtBQUssS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5QjtRQUNELElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzNCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCwrREFBK0Q7SUFDL0QsbUNBQW1DO0lBQ25DLElBQUksZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQy9DLENBQUM7SUFFRCxJQUFJLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsY0FBYyxZQUFZLHdCQUF3QixDQUFDO0lBQ2pFLENBQUM7SUFFRCxNQUFNLENBQUMsSUFBTztRQUNaLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxNQUFNLENBQUMsSUFBTztRQUNaLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ3ZDLE9BQU87U0FDUjtRQUNELElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7YUFBTTtZQUNMLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2xDO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELFFBQVEsQ0FBQyxJQUFPO1FBQ2QsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNsRixPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsOENBQThDO0lBQzlDLGlCQUFpQixDQUFDLEtBQWM7UUFDOUIsdUVBQXVFO1FBQ3ZFLDBFQUEwRTtRQUMxRSxhQUFhO1FBRWIsdUlBQXVJO1FBQ3ZJLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN6RyxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDbkQsQ0FBQzs7bUhBakZVLHNCQUFzQjt1SEFBdEIsc0JBQXNCOzJGQUF0QixzQkFBc0I7a0JBRGxDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjMgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDb21ib2JveE1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvY29tYm9ib3gubW9kZWwnO1xuaW1wb3J0IHsgTXVsdGlTZWxlY3RDb21ib2JveE1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvbXVsdGktc2VsZWN0LWNvbWJvYm94Lm1vZGVsJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE9wdGlvblNlbGVjdGlvblNlcnZpY2U8VD4ge1xuICBsb2FkaW5nID0gZmFsc2U7XG4gIGRpc3BsYXlGaWVsZDogc3RyaW5nO1xuICBzZWxlY3Rpb25Nb2RlbDogQ29tYm9ib3hNb2RlbDxUPjtcbiAgaW5wdXRDaGFuZ2VkOiBPYnNlcnZhYmxlPHN0cmluZz47XG5cbiAgLy8gRGlzcGxheSBhbGwgb3B0aW9ucyBvbiBmaXJzdCBvcGVuLCBldmVuIGlmIGZpbHRlciB0ZXh0IGV4aXN0cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS1jbGFyaXR5L25nLWNsYXJpdHkvaXNzdWVzLzM4NlxuICBzaG93QWxsT3B0aW9ucyA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfY3VycmVudElucHV0ID0gJyc7XG4gIHByaXZhdGUgX2lucHV0Q2hhbmdlZCA9IG5ldyBCZWhhdmlvclN1YmplY3QoJycpO1xuICBwcml2YXRlIF9zZWxlY3Rpb25DaGFuZ2VkID0gbmV3IFJlcGxheVN1YmplY3Q8Q29tYm9ib3hNb2RlbDxUPj4oMSk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbnB1dENoYW5nZWQgPSB0aGlzLl9pbnB1dENoYW5nZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgY3VycmVudElucHV0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRJbnB1dDtcbiAgfVxuICBzZXQgY3VycmVudElucHV0KGlucHV0KSB7XG4gICAgLy8gY2xlYXIgdmFsdWUgaW4gc2luZ2xlIHNlbGVjdGlvbiBtb2RlbCB3aGVuIGlucHV0IGlzIGVtcHR5XG4gICAgaWYgKGlucHV0ID09PSAnJyAmJiAhdGhpcy5tdWx0aXNlbGVjdGFibGUpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uVmFsdWUobnVsbCk7XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuX2lucHV0Q2hhbmdlZC5uZXh0KGlucHV0KTtcbiAgfVxuXG4gIC8vIFRoaXMgb2JzZXJ2YWJsZSBpcyBmb3Igbm90aWZ5aW5nIHRoZSBDbHJPcHRpb24gdG8gdXBkYXRlIGl0c1xuICAvLyBzZWxlY3Rpb24gYnkgY29tcGFyaW5nIHRoZSB2YWx1ZVxuICBnZXQgc2VsZWN0aW9uQ2hhbmdlZCgpOiBPYnNlcnZhYmxlPENvbWJvYm94TW9kZWw8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQ2hhbmdlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBtdWx0aXNlbGVjdGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwgaW5zdGFuY2VvZiBNdWx0aVNlbGVjdENvbWJvYm94TW9kZWw7XG4gIH1cblxuICBzZWxlY3QoaXRlbTogVCkge1xuICAgIGlmIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLnNlbGVjdGlvbk1vZGVsLmNvbnRhaW5zSXRlbShpdGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdChpdGVtKTtcbiAgICB0aGlzLl9zZWxlY3Rpb25DaGFuZ2VkLm5leHQodGhpcy5zZWxlY3Rpb25Nb2RlbCk7XG4gIH1cblxuICB0b2dnbGUoaXRlbTogVCkge1xuICAgIGlmIChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5jb250YWluc0l0ZW0oaXRlbSkpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwudW5zZWxlY3QoaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGl0ZW0pO1xuICAgIH1cbiAgICB0aGlzLl9zZWxlY3Rpb25DaGFuZ2VkLm5leHQodGhpcy5zZWxlY3Rpb25Nb2RlbCk7XG4gIH1cblxuICB1bnNlbGVjdChpdGVtOiBUKSB7XG4gICAgaWYgKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLnNlbGVjdGlvbk1vZGVsLmNvbnRhaW5zSXRlbShpdGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnVuc2VsZWN0KGl0ZW0pO1xuICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQubmV4dCh0aGlzLnNlbGVjdGlvbk1vZGVsKTtcbiAgfVxuXG4gIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciB0cmFja0J5IGFuZCBjb21wYXJlRm5cbiAgc2V0U2VsZWN0aW9uVmFsdWUodmFsdWU6IFQgfCBUW10pOiB2b2lkIHtcbiAgICAvLyBOT1RFOiBDdXJyZW50bHkgd2UgYXNzdW1lIHRoYXQgbm8gMiBvcHRpb25zIHdpbGwgaGF2ZSB0aGUgc2FtZSB2YWx1ZVxuICAgIC8vIGJ1dCBFdWRlcyBhbmQgSSBkaXNjdXNzZWQgdGhhdCB0aGlzIGlzIGEgcG9zc2liaWxpdHkgYnV0IHdlIHdpbGwgaGFuZGxlXG4gICAgLy8gdGhpcyBsYXRlclxuXG4gICAgLy8gaWYgc2VsZWN0aW9uIGlzIHVuZGVmaW5lZCwgb3IgaXRzIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBvciBjaGFuZ2luZyBmcm9tIG51bGwgPC0+IHVuZGVmaW5lZCwgdGhhdCdzIG5vdCByZWFsbHkgY2hhbmdpbmcgc28gd2UgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnNlbGVjdGlvbk1vZGVsIHx8IHRoaXMuc2VsZWN0aW9uTW9kZWwubW9kZWwgPT09IHZhbHVlIHx8ICghdGhpcy5zZWxlY3Rpb25Nb2RlbC5tb2RlbCAmJiAhdmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5tb2RlbCA9IHZhbHVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQubmV4dCh0aGlzLnNlbGVjdGlvbk1vZGVsKTtcbiAgfVxufVxuIl19