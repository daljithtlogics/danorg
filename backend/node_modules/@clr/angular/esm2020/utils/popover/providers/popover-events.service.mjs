/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable } from '@angular/core';
import { fromEvent } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./popover-toggle.service";
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/** @dynamic */
export class ClrPopoverEventsService {
    constructor(renderer, smartOpenService, document) {
        this.renderer = renderer;
        this.smartOpenService = smartOpenService;
        this.document = document;
        this.outsideClickClose = true;
        this.scrollToClose = true;
        this.subscriptions = [];
        this.subscriptions.push(smartOpenService.openChange.subscribe(open => {
            if (open) {
                this.addEscapeListener();
                this.addClickListener();
                this.addScrollListener();
            }
            else {
                this.removeAllEventListeners();
            }
        }), smartOpenService.getEventChange().subscribe(event => {
            // Remember the event that was used to open the content
            this.ignoredEvent = event;
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
        this.removeAllEventListeners();
    }
    addScrollListener() {
        if (this.scrollToClose) {
            this.documentScroller = fromEvent(this.document, 'scroll', { capture: true });
            this.scrollSubscription = this.documentScroller
                .pipe(filter(this.testForSmartPopoverContentContainer))
                .subscribe(() => {
                this.smartOpenService.open = false;
                this.setAnchorFocus();
            });
        }
        else {
            // I think this is where dynamic re-positioning will be added
            // Instead of testing like we do in the close pipe below
            // we need to switch positioning to use an observable and then
            // debounce the scroll events to recalculate content position in a performant way
            // For now, ignore scrolling events.
            return;
        }
    }
    removeScrollListener() {
        if (this.documentScroller) {
            this.scrollSubscription.unsubscribe();
            delete this.documentScroller;
        }
    }
    addClickListener() {
        if (this.outsideClickClose) {
            this.documentClickListener = this.renderer.listen(this.document, 'click', (event) => {
                if (event === this.ignoredEvent) {
                    // Here we ignore the opening click event (w/o this content opens and immediately closes.
                    delete this.ignoredEvent;
                }
                else {
                    this.smartOpenService.open = false;
                    // Rather than a complex change to the focus trap I put focus on the element that was clicked
                    const clickedElement = event.target;
                    clickedElement.focus();
                }
            });
        }
    }
    removeClickListener() {
        if (this.outsideClickClose) {
            delete this.ignoredEvent;
            if (this.documentClickListener) {
                this.documentClickListener();
                delete this.documentClickListener;
            }
        }
    }
    addEscapeListener() {
        this.escapeListener = this.renderer.listen(this.document, 'keydown.escape', () => {
            this.smartOpenService.open = false;
            this.setAnchorFocus();
        });
    }
    removeEscapeListener() {
        if (this.escapeListener) {
            this.escapeListener();
            delete this.escapeListener;
        }
    }
    setCloseFocus() {
        this.closeButtonRef.nativeElement.focus();
    }
    setAnchorFocus() {
        this.anchorButtonRef.nativeElement.focus();
    }
    testForSmartPopoverContentContainer(event) {
        // Filter for the documentScroller observable event targets
        let target = event.target;
        // Walk up the DOM tree until we get to the element that is a direct child of the body.
        while (target.classList && target.parentElement.localName !== 'body') {
            target = target.parentElement;
        }
        // Target is the child element of body where the scroll events originated.
        // Return false and prevent the popover content container from closing for any scroll events inside a popover
        // content container.
        if (target.classList) {
            // check scroll events to see if they are happening in popover content or elsewhere
            return target.classList.contains('clr-popover-content') ? false : true;
        }
        else {
            // prevents it from closing right after first opening
            return false;
        }
    }
    removeAllEventListeners() {
        this.removeScrollListener();
        this.removeClickListener();
        this.removeEscapeListener();
    }
}
ClrPopoverEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrPopoverEventsService, deps: [{ token: i0.Renderer2 }, { token: i1.ClrPopoverToggleService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
ClrPopoverEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrPopoverEventsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrPopoverEventsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.ClrPopoverToggleService }, { type: HTMLDocument, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1ldmVudHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL3V0aWxzL3BvcG92ZXIvcHJvdmlkZXJzL3BvcG92ZXItZXZlbnRzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQWMsTUFBTSxFQUFFLFVBQVUsRUFBd0IsTUFBTSxlQUFlLENBQUM7QUFDckYsT0FBTyxFQUFFLFNBQVMsRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFDM0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFJeEMseUVBQXlFO0FBQ3pFLGVBQWU7QUFFZixNQUFNLE9BQU8sdUJBQXVCO0lBY2xDLFlBQ1UsUUFBbUIsRUFDbkIsZ0JBQXlDLEVBQ3ZCLFFBQXNCO1FBRnhDLGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUF5QjtRQUN2QixhQUFRLEdBQVIsUUFBUSxDQUFjO1FBaEJsRCxzQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDekIsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFTYixrQkFBYSxHQUFtQixFQUFFLENBQUM7UUFRekMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0MsSUFBSSxJQUFJLEVBQUU7Z0JBQ1IsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO2dCQUN4QixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQzthQUMxQjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQzthQUNoQztRQUNI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eXJpZ2h0IChjKSAyMDE2LTIwMjMgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgT25EZXN0cm95LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlIH0gZnJvbSAnLi9wb3BvdmVyLXRvZ2dsZS5zZXJ2aWNlJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjAzNTEjaXNzdWVjb21tZW50LTM0NDAwOTg4N1xuLyoqIEBkeW5hbWljICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBvdXRzaWRlQ2xpY2tDbG9zZSA9IHRydWU7XG4gIHNjcm9sbFRvQ2xvc2UgPSB0cnVlO1xuICBpZ25vcmVkRXZlbnQ6IGFueTtcbiAgYW5jaG9yQnV0dG9uUmVmOiBFbGVtZW50UmVmO1xuICBjbG9zZUJ1dHRvblJlZjogRWxlbWVudFJlZjtcbiAgY29udGVudFJlZjogRWxlbWVudFJlZjtcblxuICBwcml2YXRlIGRvY3VtZW50Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBlc2NhcGVMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBzY3JvbGxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGRvY3VtZW50U2Nyb2xsZXI6IE9ic2VydmFibGU8RXZlbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIHNtYXJ0T3BlblNlcnZpY2U6IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlLFxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgZG9jdW1lbnQ6IEhUTUxEb2N1bWVudFxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHNtYXJ0T3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUob3BlbiA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgdGhpcy5hZGRFc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgIHRoaXMuYWRkU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc21hcnRPcGVuU2VydmljZS5nZXRFdmVudENoYW5nZSgpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBldmVudCB0aGF0IHdhcyB1c2VkIHRvIG9wZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5pZ25vcmVkRXZlbnQgPSBldmVudDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgYWRkU2Nyb2xsTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsVG9DbG9zZSkge1xuICAgICAgdGhpcy5kb2N1bWVudFNjcm9sbGVyID0gZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdzY3JvbGwnLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuZG9jdW1lbnRTY3JvbGxlclxuICAgICAgICAucGlwZShmaWx0ZXIodGhpcy50ZXN0Rm9yU21hcnRQb3BvdmVyQ29udGVudENvbnRhaW5lcikpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zZXRBbmNob3JGb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSSB0aGluayB0aGlzIGlzIHdoZXJlIGR5bmFtaWMgcmUtcG9zaXRpb25pbmcgd2lsbCBiZSBhZGRlZFxuICAgICAgLy8gSW5zdGVhZCBvZiB0ZXN0aW5nIGxpa2Ugd2UgZG8gaW4gdGhlIGNsb3NlIHBpcGUgYmVsb3dcbiAgICAgIC8vIHdlIG5lZWQgdG8gc3dpdGNoIHBvc2l0aW9uaW5nIHRvIHVzZSBhbiBvYnNlcnZhYmxlIGFuZCB0aGVuXG4gICAgICAvLyBkZWJvdW5jZSB0aGUgc2Nyb2xsIGV2ZW50cyB0byByZWNhbGN1bGF0ZSBjb250ZW50IHBvc2l0aW9uIGluIGEgcGVyZm9ybWFudCB3YXlcbiAgICAgIC8vIEZvciBub3csIGlnbm9yZSBzY3JvbGxpbmcgZXZlbnRzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVNjcm9sbExpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmRvY3VtZW50U2Nyb2xsZXIpIHtcbiAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kb2N1bWVudFNjcm9sbGVyO1xuICAgIH1cbiAgfVxuXG4gIGFkZENsaWNrTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMub3V0c2lkZUNsaWNrQ2xvc2UpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5kb2N1bWVudCwgJ2NsaWNrJywgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudCA9PT0gdGhpcy5pZ25vcmVkRXZlbnQpIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIGlnbm9yZSB0aGUgb3BlbmluZyBjbGljayBldmVudCAody9vIHRoaXMgY29udGVudCBvcGVucyBhbmQgaW1tZWRpYXRlbHkgY2xvc2VzLlxuICAgICAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZWRFdmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNtYXJ0T3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIC8vIFJhdGhlciB0aGFuIGEgY29tcGxleCBjaGFuZ2UgdG8gdGhlIGZvY3VzIHRyYXAgSSBwdXQgZm9jdXMgb24gdGhlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZFxuICAgICAgICAgIGNvbnN0IGNsaWNrZWRFbGVtZW50ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgIGNsaWNrZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUNsaWNrTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMub3V0c2lkZUNsaWNrQ2xvc2UpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZWRFdmVudDtcbiAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkRXNjYXBlTGlzdGVuZXIoKSB7XG4gICAgdGhpcy5lc2NhcGVMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZG9jdW1lbnQsICdrZXlkb3duLmVzY2FwZScsICgpID0+IHtcbiAgICAgIHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLnNldEFuY2hvckZvY3VzKCk7XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVFc2NhcGVMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5lc2NhcGVMaXN0ZW5lcikge1xuICAgICAgdGhpcy5lc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgZGVsZXRlIHRoaXMuZXNjYXBlTGlzdGVuZXI7XG4gICAgfVxuICB9XG5cbiAgc2V0Q2xvc2VGb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLmNsb3NlQnV0dG9uUmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIHNldEFuY2hvckZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuYW5jaG9yQnV0dG9uUmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdGVzdEZvclNtYXJ0UG9wb3ZlckNvbnRlbnRDb250YWluZXIoZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XG4gICAgLy8gRmlsdGVyIGZvciB0aGUgZG9jdW1lbnRTY3JvbGxlciBvYnNlcnZhYmxlIGV2ZW50IHRhcmdldHNcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgLy8gV2FsayB1cCB0aGUgRE9NIHRyZWUgdW50aWwgd2UgZ2V0IHRvIHRoZSBlbGVtZW50IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIGJvZHkuXG4gICAgd2hpbGUgKHRhcmdldC5jbGFzc0xpc3QgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQubG9jYWxOYW1lICE9PSAnYm9keScpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFRhcmdldCBpcyB0aGUgY2hpbGQgZWxlbWVudCBvZiBib2R5IHdoZXJlIHRoZSBzY3JvbGwgZXZlbnRzIG9yaWdpbmF0ZWQuXG4gICAgLy8gUmV0dXJuIGZhbHNlIGFuZCBwcmV2ZW50IHRoZSBwb3BvdmVyIGNvbnRlbnQgY29udGFpbmVyIGZyb20gY2xvc2luZyBmb3IgYW55IHNjcm9sbCBldmVudHMgaW5zaWRlIGEgcG9wb3ZlclxuICAgIC8vIGNvbnRlbnQgY29udGFpbmVyLlxuICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0KSB7XG4gICAgICAvLyBjaGVjayBzY3JvbGwgZXZlbnRzIHRvIHNlZSBpZiB0aGV5IGFyZSBoYXBwZW5pbmcgaW4gcG9wb3ZlciBjb250ZW50IG9yIGVsc2V3aGVyZVxuICAgICAgcmV0dXJuIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Nsci1wb3BvdmVyLWNvbnRlbnQnKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJldmVudHMgaXQgZnJvbSBjbG9zaW5nIHJpZ2h0IGFmdGVyIGZpcnN0IG9wZW5pbmdcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMucmVtb3ZlU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICB0aGlzLnJlbW92ZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB0aGlzLnJlbW92ZUVzY2FwZUxpc3RlbmVyKCk7XG4gIH1cbn1cbiJdfQ==