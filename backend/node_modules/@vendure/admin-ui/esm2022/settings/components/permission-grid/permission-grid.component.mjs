import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@vendure/admin-ui/core";
import * as i3 from "@ngx-translate/core";
/**
 * A table showing and allowing the setting of all possible CRUD permissions.
 */
export class PermissionGridComponent {
    constructor() {
        this.readonly = false;
        this.permissionChange = new EventEmitter();
    }
    ngOnInit() {
        this.buildGrid();
    }
    setPermission(permission, value) {
        if (!this.readonly) {
            this.permissionChange.emit({ permission, value });
        }
    }
    toggleAll(defs) {
        const value = defs.some(d => !this.activePermissions.includes(d.name));
        for (const def of defs) {
            this.permissionChange.emit({ permission: def.name, value });
        }
    }
    buildGrid() {
        const crudGroups = new Map();
        const nonCrud = [];
        const crudRe = /^(Create|Read|Update|Delete)([a-zA-Z]+)$/;
        for (const def of this.permissionDefinitions) {
            const isCrud = crudRe.test(def.name);
            if (isCrud) {
                const groupName = def.name.match(crudRe)?.[2];
                if (groupName) {
                    const existing = crudGroups.get(groupName);
                    if (existing) {
                        existing.push(def);
                    }
                    else {
                        crudGroups.set(groupName, [def]);
                    }
                }
            }
            else if (def.assignable) {
                nonCrud.push(def);
            }
        }
        this.gridData = [
            ...nonCrud.map(d => ({
                label: d.name,
                description: d.description,
                permissions: [d],
            })),
            ...Array.from(crudGroups.entries()).map(([label, defs]) => ({
                label,
                description: this.extractCrudDescription(defs[0]),
                permissions: defs,
            })),
        ];
    }
    extractCrudDescription(def) {
        return def.description.replace(/Grants permission to [\w]+/, 'Grants permissions on');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: PermissionGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: PermissionGridComponent, selector: "vdr-permission-grid", inputs: { permissionDefinitions: "permissionDefinitions", activePermissions: "activePermissions", readonly: "readonly" }, outputs: { permissionChange: "permissionChange" }, ngImport: i0, template: "<table class=\"table\">\r\n    <tbody>\r\n        <tr *ngFor=\"let section of gridData\">\r\n            <td class=\"permission-group left\">\r\n                <div><strong>{{ section.label | translate }}</strong></div>\r\n                <small>{{ section.description | translate }}</small><br>\r\n                <button *ngIf=\"1 < section.permissions.length && !readonly\" class=\"button-small\" (click)=\"toggleAll(section.permissions)\">\r\n                    {{ 'common.toggle-all' | translate }}\r\n                </button>\r\n            </td>\r\n            <td *ngFor=\"let permission of section.permissions\" [attr.colspan]=\"section.permissions.length === 1 ? 4 : 1\">\r\n                <vdr-select-toggle\r\n                    size=\"small\"\r\n                    [title]=\"permission.description\"\r\n                    [label]=\"permission.name\"\r\n                    [disabled]=\"readonly\"\r\n                    [selected]=\"activePermissions?.includes(permission.name)\"\r\n                    (selectedChange)=\"setPermission(permission.name, $event)\"\r\n                ></vdr-select-toggle>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n", styles: [":host{display:block}td.permission-group{max-width:300px;background-color:var(--color-component-bg-200)}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.SelectToggleComponent, selector: "vdr-select-toggle", inputs: ["size", "selected", "hiddenWhenOff", "disabled", "label"], outputs: ["selectedChange"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: PermissionGridComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-permission-grid', changeDetection: ChangeDetectionStrategy.OnPush, template: "<table class=\"table\">\r\n    <tbody>\r\n        <tr *ngFor=\"let section of gridData\">\r\n            <td class=\"permission-group left\">\r\n                <div><strong>{{ section.label | translate }}</strong></div>\r\n                <small>{{ section.description | translate }}</small><br>\r\n                <button *ngIf=\"1 < section.permissions.length && !readonly\" class=\"button-small\" (click)=\"toggleAll(section.permissions)\">\r\n                    {{ 'common.toggle-all' | translate }}\r\n                </button>\r\n            </td>\r\n            <td *ngFor=\"let permission of section.permissions\" [attr.colspan]=\"section.permissions.length === 1 ? 4 : 1\">\r\n                <vdr-select-toggle\r\n                    size=\"small\"\r\n                    [title]=\"permission.description\"\r\n                    [label]=\"permission.name\"\r\n                    [disabled]=\"readonly\"\r\n                    [selected]=\"activePermissions?.includes(permission.name)\"\r\n                    (selectedChange)=\"setPermission(permission.name, $event)\"\r\n                ></vdr-select-toggle>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n", styles: [":host{display:block}td.permission-group{max-width:300px;background-color:var(--color-component-bg-200)}\n"] }]
        }], propDecorators: { permissionDefinitions: [{
                type: Input
            }], activePermissions: [{
                type: Input
            }], readonly: [{
                type: Input
            }], permissionChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbi1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvc2V0dGluZ3Mvc3JjL2NvbXBvbmVudHMvcGVybWlzc2lvbi1ncmlkL3Blcm1pc3Npb24tZ3JpZC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3NldHRpbmdzL3NyYy9jb21wb25lbnRzL3Blcm1pc3Npb24tZ3JpZC9wZXJtaXNzaW9uLWdyaWQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7QUFVeEc7O0dBRUc7QUFPSCxNQUFNLE9BQU8sdUJBQXVCO0lBTnBDO1FBU2EsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNoQixxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBMEMsQ0FBQztLQXlEM0Y7SUF0REcsUUFBUTtRQUNKLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsYUFBYSxDQUFDLFVBQWtCLEVBQUUsS0FBYztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDckQ7SUFDTCxDQUFDO0lBRUQsU0FBUyxDQUFDLElBQTRCO1FBQ2xDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDdkUsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDL0Q7SUFDTCxDQUFDO0lBRU8sU0FBUztRQUNiLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxFQUFrQyxDQUFDO1FBQzdELE1BQU0sT0FBTyxHQUEyQixFQUFFLENBQUM7UUFDM0MsTUFBTSxNQUFNLEdBQUcsMENBQTBDLENBQUM7UUFDMUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDMUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDckMsSUFBSSxNQUFNLEVBQUU7Z0JBQ1IsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUMsSUFBSSxTQUFTLEVBQUU7b0JBQ1gsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDM0MsSUFBSSxRQUFRLEVBQUU7d0JBQ1YsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDdEI7eUJBQU07d0JBQ0gsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3FCQUNwQztpQkFDSjthQUNKO2lCQUFNLElBQUksR0FBRyxDQUFDLFVBQVUsRUFBRTtnQkFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNyQjtTQUNKO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRztZQUNaLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2pCLEtBQUssRUFBRSxDQUFDLENBQUMsSUFBSTtnQkFDYixXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVc7Z0JBQzFCLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNuQixDQUFDLENBQUM7WUFDSCxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3BELEtBQUs7Z0JBQ0wsV0FBVyxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pELFdBQVcsRUFBRSxJQUFJO2FBQ3BCLENBQUMsQ0FBQztTQUNWLENBQUM7SUFDTixDQUFDO0lBRU8sc0JBQXNCLENBQUMsR0FBeUI7UUFDcEQsT0FBTyxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQzFGLENBQUM7OEdBNURRLHVCQUF1QjtrR0FBdkIsdUJBQXVCLHdPQ25CcEMsMnFDQXVCQTs7MkZESmEsdUJBQXVCO2tCQU5uQyxTQUFTOytCQUNJLHFCQUFxQixtQkFHZCx1QkFBdUIsQ0FBQyxNQUFNOzhCQUd0QyxxQkFBcUI7c0JBQTdCLEtBQUs7Z0JBQ0csaUJBQWlCO3NCQUF6QixLQUFLO2dCQUNHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBQ0ksZ0JBQWdCO3NCQUF6QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgbWFya2VyIGFzIF8gfSBmcm9tICdAYmllc2JqZXJnL25neC10cmFuc2xhdGUtZXh0cmFjdC1tYXJrZXInO1xyXG5pbXBvcnQgeyBQZXJtaXNzaW9uRGVmaW5pdGlvbiB9IGZyb20gJ0B2ZW5kdXJlL2FkbWluLXVpL2NvcmUnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQZXJtaXNzaW9uR3JpZFJvdyB7XHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAgIHBlcm1pc3Npb25zOiBQZXJtaXNzaW9uRGVmaW5pdGlvbltdO1xyXG59XHJcblxyXG4vKipcclxuICogQSB0YWJsZSBzaG93aW5nIGFuZCBhbGxvd2luZyB0aGUgc2V0dGluZyBvZiBhbGwgcG9zc2libGUgQ1JVRCBwZXJtaXNzaW9ucy5cclxuICovXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2ZHItcGVybWlzc2lvbi1ncmlkJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9wZXJtaXNzaW9uLWdyaWQuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vcGVybWlzc2lvbi1ncmlkLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25HcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIEBJbnB1dCgpIHBlcm1pc3Npb25EZWZpbml0aW9uczogUGVybWlzc2lvbkRlZmluaXRpb25bXTtcclxuICAgIEBJbnB1dCgpIGFjdGl2ZVBlcm1pc3Npb25zOiBzdHJpbmdbXTtcclxuICAgIEBJbnB1dCgpIHJlYWRvbmx5ID0gZmFsc2U7XHJcbiAgICBAT3V0cHV0KCkgcGVybWlzc2lvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8eyBwZXJtaXNzaW9uOiBzdHJpbmc7IHZhbHVlOiBib29sZWFuIH0+KCk7XHJcbiAgICBncmlkRGF0YTogUGVybWlzc2lvbkdyaWRSb3dbXTtcclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLmJ1aWxkR3JpZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBlcm1pc3Npb24ocGVybWlzc2lvbjogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWFkb25seSkge1xyXG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25DaGFuZ2UuZW1pdCh7IHBlcm1pc3Npb24sIHZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVBbGwoZGVmczogUGVybWlzc2lvbkRlZmluaXRpb25bXSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVmcy5zb21lKGQgPT4gIXRoaXMuYWN0aXZlUGVybWlzc2lvbnMuaW5jbHVkZXMoZC5uYW1lKSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xyXG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25DaGFuZ2UuZW1pdCh7IHBlcm1pc3Npb246IGRlZi5uYW1lLCB2YWx1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZEdyaWQoKSB7XHJcbiAgICAgICAgY29uc3QgY3J1ZEdyb3VwcyA9IG5ldyBNYXA8c3RyaW5nLCBQZXJtaXNzaW9uRGVmaW5pdGlvbltdPigpO1xyXG4gICAgICAgIGNvbnN0IG5vbkNydWQ6IFBlcm1pc3Npb25EZWZpbml0aW9uW10gPSBbXTtcclxuICAgICAgICBjb25zdCBjcnVkUmUgPSAvXihDcmVhdGV8UmVhZHxVcGRhdGV8RGVsZXRlKShbYS16QS1aXSspJC87XHJcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgdGhpcy5wZXJtaXNzaW9uRGVmaW5pdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNDcnVkID0gY3J1ZFJlLnRlc3QoZGVmLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNDcnVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cE5hbWUgPSBkZWYubmFtZS5tYXRjaChjcnVkUmUpPy5bMl07XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjcnVkR3JvdXBzLmdldChncm91cE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKGRlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3J1ZEdyb3Vwcy5zZXQoZ3JvdXBOYW1lLCBbZGVmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZi5hc3NpZ25hYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBub25DcnVkLnB1c2goZGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyaWREYXRhID0gW1xyXG4gICAgICAgICAgICAuLi5ub25DcnVkLm1hcChkID0+ICh7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogZC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGQuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogW2RdLFxyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20oY3J1ZEdyb3Vwcy5lbnRyaWVzKCkpLm1hcCgoW2xhYmVsLCBkZWZzXSkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5leHRyYWN0Q3J1ZERlc2NyaXB0aW9uKGRlZnNbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBkZWZzLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBleHRyYWN0Q3J1ZERlc2NyaXB0aW9uKGRlZjogUGVybWlzc2lvbkRlZmluaXRpb24pOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBkZWYuZGVzY3JpcHRpb24ucmVwbGFjZSgvR3JhbnRzIHBlcm1pc3Npb24gdG8gW1xcd10rLywgJ0dyYW50cyBwZXJtaXNzaW9ucyBvbicpO1xyXG4gICAgfVxyXG59XHJcbiIsIjx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XHJcbiAgICA8dGJvZHk+XHJcbiAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBzZWN0aW9uIG9mIGdyaWREYXRhXCI+XHJcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cInBlcm1pc3Npb24tZ3JvdXAgbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj48c3Ryb25nPnt7IHNlY3Rpb24ubGFiZWwgfCB0cmFuc2xhdGUgfX08L3N0cm9uZz48L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxzbWFsbD57eyBzZWN0aW9uLmRlc2NyaXB0aW9uIHwgdHJhbnNsYXRlIH19PC9zbWFsbD48YnI+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVwiMSA8IHNlY3Rpb24ucGVybWlzc2lvbnMubGVuZ3RoICYmICFyZWFkb25seVwiIGNsYXNzPVwiYnV0dG9uLXNtYWxsXCIgKGNsaWNrKT1cInRvZ2dsZUFsbChzZWN0aW9uLnBlcm1pc3Npb25zKVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIHt7ICdjb21tb24udG9nZ2xlLWFsbCcgfCB0cmFuc2xhdGUgfX1cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IHBlcm1pc3Npb24gb2Ygc2VjdGlvbi5wZXJtaXNzaW9uc1wiIFthdHRyLmNvbHNwYW5dPVwic2VjdGlvbi5wZXJtaXNzaW9ucy5sZW5ndGggPT09IDEgPyA0IDogMVwiPlxyXG4gICAgICAgICAgICAgICAgPHZkci1zZWxlY3QtdG9nZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZT1cInNtYWxsXCJcclxuICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwicGVybWlzc2lvbi5kZXNjcmlwdGlvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cInBlcm1pc3Npb24ubmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cInJlYWRvbmx5XCJcclxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiYWN0aXZlUGVybWlzc2lvbnM/LmluY2x1ZGVzKHBlcm1pc3Npb24ubmFtZSlcIlxyXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZENoYW5nZSk9XCJzZXRQZXJtaXNzaW9uKHBlcm1pc3Npb24ubmFtZSwgJGV2ZW50KVwiXHJcbiAgICAgICAgICAgICAgICA+PC92ZHItc2VsZWN0LXRvZ2dsZT5cclxuICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICA8L3RyPlxyXG4gICAgPC90Ym9keT5cclxuPC90YWJsZT5cclxuIl19