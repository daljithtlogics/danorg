import { ActivationStart, } from '@angular/router';
import { notNullOrUndefined } from '@vendure/common/lib/shared-utils';
import { of } from 'rxjs';
import { filter, map, shareReplay, take, takeUntil } from 'rxjs/operators';
export function createResolveData(resolver) {
    return {
        entity: resolver,
    };
}
/**
 * @description
 * A base resolver for an entity detail route. Resolves to an observable of the given entity, or a "blank"
 * version if the route id equals "create". Should be used together with details views which extend the
 * {@link BaseDetailComponent}.
 *
 * @example
 * ```ts
 * \@Injectable({
 *   providedIn: 'root',
 * })
 * export class MyEntityResolver extends BaseEntityResolver<MyEntityFragment> {
 *   constructor(router: Router, dataService: DataService) {
 *     super(
 *       router,
 *       {
 *         __typename: 'MyEntity',
 *         id: '',
 *         createdAt: '',
 *         updatedAt: '',
 *         name: '',
 *       },
 *       id => dataService.query(GET_MY_ENTITY, { id }).mapStream(data => data.myEntity),
 *     );
 *   }
 * }
 * ```
 *
 * @docsCategory list-detail-views
 */
export class BaseEntityResolver {
    constructor(router, emptyEntity, entityStream) {
        this.router = router;
        this.emptyEntity = emptyEntity;
        this.entityStream = entityStream;
    }
    /** @internal */
    resolve(route, state) {
        const id = route.paramMap.get('id');
        // Complete the entity stream upon navigating away
        const navigateAway$ = this.router.events.pipe(filter(event => event instanceof ActivationStart));
        if (id === 'create') {
            return of(of(this.emptyEntity));
        }
        else {
            const stream = this.entityStream(id || '').pipe(takeUntil(navigateAway$), filter(notNullOrUndefined), shareReplay(1));
            return stream.pipe(take(1), map(() => stream));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1lbnRpdHktcmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2NvbW1vbi9iYXNlLWVudGl0eS1yZXNvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsZUFBZSxHQUlsQixNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRSxNQUFNLFVBQVUsaUJBQWlCLENBQzdCLFFBQWlCO0lBRWpCLE9BQU87UUFDSCxNQUFNLEVBQUUsUUFBUTtLQUNuQixDQUFDO0FBQ04sQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQUNILE1BQU0sT0FBTyxrQkFBa0I7SUFDM0IsWUFDYyxNQUFjLEVBQ1AsV0FBYyxFQUN2QixZQUE4RDtRQUY1RCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ1AsZ0JBQVcsR0FBWCxXQUFXLENBQUc7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtEO0lBQ3ZFLENBQUM7SUFFSixnQkFBZ0I7SUFDaEIsT0FBTyxDQUFDLEtBQTZCLEVBQUUsS0FBMEI7UUFDN0QsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEMsa0RBQWtEO1FBQ2xELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLFlBQVksZUFBZSxDQUFDLENBQUMsQ0FBQztRQUVqRyxJQUFJLEVBQUUsS0FBSyxRQUFRLEVBQUU7WUFDakIsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1NBQ25DO2FBQU07WUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQzNDLFNBQVMsQ0FBQyxhQUFhLENBQUMsRUFDeEIsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEVBQzFCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDakIsQ0FBQztZQUVGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FDZCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ1AsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUNwQixDQUFDO1NBQ0w7SUFDTCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcclxuICAgIEFjdGl2YXRpb25TdGFydCxcclxuICAgIFJlc29sdmVEYXRhLFxyXG4gICAgUm91dGVyLFxyXG4gICAgUm91dGVyU3RhdGVTbmFwc2hvdCxcclxufSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBub3ROdWxsT3JVbmRlZmluZWQgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC11dGlscyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzaGFyZVJlcGxheSwgdGFrZSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlSZXNvbHZlRGF0YTxSPiBleHRlbmRzIFJlc29sdmVEYXRhIHtcclxuICAgIGVudGl0eTogVHlwZTxCYXNlRW50aXR5UmVzb2x2ZXI8Uj4+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZURhdGE8VCBleHRlbmRzIEJhc2VFbnRpdHlSZXNvbHZlcjxSPiwgUj4oXHJcbiAgICByZXNvbHZlcjogVHlwZTxUPixcclxuKTogRW50aXR5UmVzb2x2ZURhdGE8Uj4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbnRpdHk6IHJlc29sdmVyLFxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGJhc2UgcmVzb2x2ZXIgZm9yIGFuIGVudGl0eSBkZXRhaWwgcm91dGUuIFJlc29sdmVzIHRvIGFuIG9ic2VydmFibGUgb2YgdGhlIGdpdmVuIGVudGl0eSwgb3IgYSBcImJsYW5rXCJcclxuICogdmVyc2lvbiBpZiB0aGUgcm91dGUgaWQgZXF1YWxzIFwiY3JlYXRlXCIuIFNob3VsZCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggZGV0YWlscyB2aWV3cyB3aGljaCBleHRlbmQgdGhlXHJcbiAqIHtAbGluayBCYXNlRGV0YWlsQ29tcG9uZW50fS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogXFxASW5qZWN0YWJsZSh7XHJcbiAqICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG4gKiB9KVxyXG4gKiBleHBvcnQgY2xhc3MgTXlFbnRpdHlSZXNvbHZlciBleHRlbmRzIEJhc2VFbnRpdHlSZXNvbHZlcjxNeUVudGl0eUZyYWdtZW50PiB7XHJcbiAqICAgY29uc3RydWN0b3Iocm91dGVyOiBSb3V0ZXIsIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSkge1xyXG4gKiAgICAgc3VwZXIoXHJcbiAqICAgICAgIHJvdXRlcixcclxuICogICAgICAge1xyXG4gKiAgICAgICAgIF9fdHlwZW5hbWU6ICdNeUVudGl0eScsXHJcbiAqICAgICAgICAgaWQ6ICcnLFxyXG4gKiAgICAgICAgIGNyZWF0ZWRBdDogJycsXHJcbiAqICAgICAgICAgdXBkYXRlZEF0OiAnJyxcclxuICogICAgICAgICBuYW1lOiAnJyxcclxuICogICAgICAgfSxcclxuICogICAgICAgaWQgPT4gZGF0YVNlcnZpY2UucXVlcnkoR0VUX01ZX0VOVElUWSwgeyBpZCB9KS5tYXBTdHJlYW0oZGF0YSA9PiBkYXRhLm15RW50aXR5KSxcclxuICogICAgICk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZG9jc0NhdGVnb3J5IGxpc3QtZGV0YWlsLXZpZXdzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFzZUVudGl0eVJlc29sdmVyPFQ+IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByb3RlY3RlZCByb3V0ZXI6IFJvdXRlcixcclxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGVtcHR5RW50aXR5OiBULFxyXG4gICAgICAgIHByaXZhdGUgZW50aXR5U3RyZWFtOiAoaWQ6IHN0cmluZykgPT4gT2JzZXJ2YWJsZTxUIHwgbnVsbCB8IHVuZGVmaW5lZD4sXHJcbiAgICApIHt9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVzb2x2ZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU6IFJvdXRlclN0YXRlU25hcHNob3QpOiBPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+IHtcclxuICAgICAgICBjb25zdCBpZCA9IHJvdXRlLnBhcmFtTWFwLmdldCgnaWQnKTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGxldGUgdGhlIGVudGl0eSBzdHJlYW0gdXBvbiBuYXZpZ2F0aW5nIGF3YXlcclxuICAgICAgICBjb25zdCBuYXZpZ2F0ZUF3YXkkID0gdGhpcy5yb3V0ZXIuZXZlbnRzLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgQWN0aXZhdGlvblN0YXJ0KSk7XHJcblxyXG4gICAgICAgIGlmIChpZCA9PT0gJ2NyZWF0ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9mKG9mKHRoaXMuZW1wdHlFbnRpdHkpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLmVudGl0eVN0cmVhbShpZCB8fCAnJykucGlwZShcclxuICAgICAgICAgICAgICAgIHRha2VVbnRpbChuYXZpZ2F0ZUF3YXkkKSxcclxuICAgICAgICAgICAgICAgIGZpbHRlcihub3ROdWxsT3JVbmRlZmluZWQpLFxyXG4gICAgICAgICAgICAgICAgc2hhcmVSZXBsYXkoMSksXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtLnBpcGUoXHJcbiAgICAgICAgICAgICAgICB0YWtlKDEpLFxyXG4gICAgICAgICAgICAgICAgbWFwKCgpID0+IHN0cmVhbSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==