import { findTranslation } from './find-translation';
import { getDefaultValue } from './custom-field-default-value';
/**
 * When updating an entity which has translations, the value from the form will pertain to the current
 * languageCode. This function ensures that the "translations" array is correctly set based on the
 * existing languages and the updated values in the specified language.
 */
export function createUpdatedTranslatable(options) {
    const { translatable, updatedFields, languageCode, customFieldConfig, defaultTranslation } = options;
    const currentTranslation = findTranslation(translatable, languageCode) || defaultTranslation || {};
    const index = translatable.translations?.indexOf(currentTranslation);
    const newTranslation = patchObject(currentTranslation, updatedFields);
    const newCustomFields = {};
    const newTranslatedCustomFields = {};
    if (customFieldConfig && updatedFields.hasOwnProperty('customFields')) {
        for (const field of customFieldConfig) {
            const value = updatedFields.customFields[field.name];
            if (field.type === 'localeString' || field.type === 'localeText') {
                newTranslatedCustomFields[field.name] = value;
            }
            else {
                newCustomFields[field.name] =
                    value === ''
                        ? getDefaultValue(field.type, field.nullable ?? true)
                        : value;
            }
        }
        newTranslation.customFields = newTranslatedCustomFields;
    }
    const newTranslatable = {
        ...patchObject(translatable, updatedFields),
        ...{ translations: translatable.translations?.slice() ?? [] },
    };
    if (customFieldConfig) {
        newTranslatable.customFields = newCustomFields;
    }
    if (index !== -1) {
        newTranslatable.translations.splice(index, 1, newTranslation);
    }
    else {
        newTranslatable.translations.push(newTranslation);
    }
    return newTranslatable;
}
/**
 * Returns a shallow clone of `obj` with any properties contained in `patch` overwriting
 * those of `obj`.
 */
function patchObject(obj, patch) {
    const clone = Object.assign({}, obj);
    Object.keys(clone).forEach(key => {
        if (patch.hasOwnProperty(key)) {
            clone[key] = patch[key];
        }
    });
    return clone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLXVwZGF0ZWQtdHJhbnNsYXRhYmxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9jb21tb24vdXRpbGl0aWVzL2NyZWF0ZS11cGRhdGVkLXRyYW5zbGF0YWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDckQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBYy9EOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUseUJBQXlCLENBQ3JDLE9BQXFDO0lBRXJDLE1BQU0sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE9BQU8sQ0FBQztJQUNyRyxNQUFNLGtCQUFrQixHQUNwQixlQUFlLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxJQUFJLGtCQUFrQixJQUFLLEVBQVUsQ0FBQztJQUNyRixNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUN0RSxNQUFNLGVBQWUsR0FBdUIsRUFBRSxDQUFDO0lBQy9DLE1BQU0seUJBQXlCLEdBQXVCLEVBQUUsQ0FBQztJQUN6RCxJQUFJLGlCQUFpQixJQUFJLGFBQWEsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEVBQUU7UUFDbkUsS0FBSyxNQUFNLEtBQUssSUFBSSxpQkFBaUIsRUFBRTtZQUNuQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssY0FBYyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFFO2dCQUM5RCx5QkFBeUIsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO2FBQ2pEO2lCQUFNO2dCQUNILGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO29CQUN2QixLQUFLLEtBQUssRUFBRTt3QkFDUixDQUFDLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUF1QixFQUFFLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDO3dCQUN4RSxDQUFDLENBQUMsS0FBSyxDQUFDO2FBQ25CO1NBQ0o7UUFDRCxjQUFjLENBQUMsWUFBWSxHQUFHLHlCQUF5QixDQUFDO0tBQzNEO0lBQ0QsTUFBTSxlQUFlLEdBQUc7UUFDcEIsR0FBSSxXQUFXLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBUztRQUNwRCxHQUFHLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQyxZQUFZLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFO0tBQ2hFLENBQUM7SUFDRixJQUFJLGlCQUFpQixFQUFFO1FBQ25CLGVBQWUsQ0FBQyxZQUFZLEdBQUcsZUFBZSxDQUFDO0tBQ2xEO0lBQ0QsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUU7UUFDZCxlQUFlLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQ2pFO1NBQU07UUFDSCxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNyRDtJQUNELE9BQU8sZUFBZSxDQUFDO0FBQzNCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLFdBQVcsQ0FBbUMsR0FBTSxFQUFFLEtBQTZCO0lBQ3hGLE1BQU0sS0FBSyxHQUFRLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQzdCLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tRmllbGRzT2JqZWN0LCBDdXN0b21GaWVsZFR5cGUgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC10eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBDdXN0b21GaWVsZENvbmZpZywgTGFuZ3VhZ2VDb2RlIH0gZnJvbSAnLi4vZ2VuZXJhdGVkLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IGZpbmRUcmFuc2xhdGlvbiB9IGZyb20gJy4vZmluZC10cmFuc2xhdGlvbic7XHJcbmltcG9ydCB7IGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4vY3VzdG9tLWZpZWxkLWRlZmF1bHQtdmFsdWUnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGFibGVVcGRhdGVPcHRpb25zPFQgZXh0ZW5kcyB7IHRyYW5zbGF0aW9uczogYW55W10gfSAmIE1heUhhdmVDdXN0b21GaWVsZHM+IHtcclxuICAgIHRyYW5zbGF0YWJsZTogVDtcclxuICAgIHVwZGF0ZWRGaWVsZHM6IHsgW2tleTogc3RyaW5nXTogYW55IH07XHJcbiAgICBsYW5ndWFnZUNvZGU6IExhbmd1YWdlQ29kZTtcclxuICAgIGN1c3RvbUZpZWxkQ29uZmlnPzogQ3VzdG9tRmllbGRDb25maWdbXTtcclxuICAgIGRlZmF1bHRUcmFuc2xhdGlvbj86IFBhcnRpYWw8VFsndHJhbnNsYXRpb25zJ11bbnVtYmVyXT47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1heUhhdmVDdXN0b21GaWVsZHMgPSB7XHJcbiAgICBjdXN0b21GaWVsZHM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdoZW4gdXBkYXRpbmcgYW4gZW50aXR5IHdoaWNoIGhhcyB0cmFuc2xhdGlvbnMsIHRoZSB2YWx1ZSBmcm9tIHRoZSBmb3JtIHdpbGwgcGVydGFpbiB0byB0aGUgY3VycmVudFxyXG4gKiBsYW5ndWFnZUNvZGUuIFRoaXMgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IHRoZSBcInRyYW5zbGF0aW9uc1wiIGFycmF5IGlzIGNvcnJlY3RseSBzZXQgYmFzZWQgb24gdGhlXHJcbiAqIGV4aXN0aW5nIGxhbmd1YWdlcyBhbmQgdGhlIHVwZGF0ZWQgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgbGFuZ3VhZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVXBkYXRlZFRyYW5zbGF0YWJsZTxUIGV4dGVuZHMgeyB0cmFuc2xhdGlvbnM6IGFueVtdIH0gJiBNYXlIYXZlQ3VzdG9tRmllbGRzPihcclxuICAgIG9wdGlvbnM6IFRyYW5zbGF0YWJsZVVwZGF0ZU9wdGlvbnM8VD4sXHJcbik6IFQge1xyXG4gICAgY29uc3QgeyB0cmFuc2xhdGFibGUsIHVwZGF0ZWRGaWVsZHMsIGxhbmd1YWdlQ29kZSwgY3VzdG9tRmllbGRDb25maWcsIGRlZmF1bHRUcmFuc2xhdGlvbiB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2xhdGlvbiA9XHJcbiAgICAgICAgZmluZFRyYW5zbGF0aW9uKHRyYW5zbGF0YWJsZSwgbGFuZ3VhZ2VDb2RlKSB8fCBkZWZhdWx0VHJhbnNsYXRpb24gfHwgKHt9IGFzIGFueSk7XHJcbiAgICBjb25zdCBpbmRleCA9IHRyYW5zbGF0YWJsZS50cmFuc2xhdGlvbnM/LmluZGV4T2YoY3VycmVudFRyYW5zbGF0aW9uKTtcclxuICAgIGNvbnN0IG5ld1RyYW5zbGF0aW9uID0gcGF0Y2hPYmplY3QoY3VycmVudFRyYW5zbGF0aW9uLCB1cGRhdGVkRmllbGRzKTtcclxuICAgIGNvbnN0IG5ld0N1c3RvbUZpZWxkczogQ3VzdG9tRmllbGRzT2JqZWN0ID0ge307XHJcbiAgICBjb25zdCBuZXdUcmFuc2xhdGVkQ3VzdG9tRmllbGRzOiBDdXN0b21GaWVsZHNPYmplY3QgPSB7fTtcclxuICAgIGlmIChjdXN0b21GaWVsZENvbmZpZyAmJiB1cGRhdGVkRmllbGRzLmhhc093blByb3BlcnR5KCdjdXN0b21GaWVsZHMnKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgY3VzdG9tRmllbGRDb25maWcpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1cGRhdGVkRmllbGRzLmN1c3RvbUZpZWxkc1tmaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdsb2NhbGVTdHJpbmcnIHx8IGZpZWxkLnR5cGUgPT09ICdsb2NhbGVUZXh0Jykge1xyXG4gICAgICAgICAgICAgICAgbmV3VHJhbnNsYXRlZEN1c3RvbUZpZWxkc1tmaWVsZC5uYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Q3VzdG9tRmllbGRzW2ZpZWxkLm5hbWVdID1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gJydcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREZWZhdWx0VmFsdWUoZmllbGQudHlwZSBhcyBDdXN0b21GaWVsZFR5cGUsIGZpZWxkLm51bGxhYmxlID8/IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3VHJhbnNsYXRpb24uY3VzdG9tRmllbGRzID0gbmV3VHJhbnNsYXRlZEN1c3RvbUZpZWxkcztcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1RyYW5zbGF0YWJsZSA9IHtcclxuICAgICAgICAuLi4ocGF0Y2hPYmplY3QodHJhbnNsYXRhYmxlLCB1cGRhdGVkRmllbGRzKSBhcyBhbnkpLFxyXG4gICAgICAgIC4uLnsgdHJhbnNsYXRpb25zOiB0cmFuc2xhdGFibGUudHJhbnNsYXRpb25zPy5zbGljZSgpID8/IFtdIH0sXHJcbiAgICB9O1xyXG4gICAgaWYgKGN1c3RvbUZpZWxkQ29uZmlnKSB7XHJcbiAgICAgICAgbmV3VHJhbnNsYXRhYmxlLmN1c3RvbUZpZWxkcyA9IG5ld0N1c3RvbUZpZWxkcztcclxuICAgIH1cclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBuZXdUcmFuc2xhdGFibGUudHJhbnNsYXRpb25zLnNwbGljZShpbmRleCwgMSwgbmV3VHJhbnNsYXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdUcmFuc2xhdGFibGUudHJhbnNsYXRpb25zLnB1c2gobmV3VHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1RyYW5zbGF0YWJsZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmpgIHdpdGggYW55IHByb3BlcnRpZXMgY29udGFpbmVkIGluIGBwYXRjaGAgb3ZlcndyaXRpbmdcclxuICogdGhvc2Ugb2YgYG9iamAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRjaE9iamVjdDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhbnkgfT4ob2JqOiBULCBwYXRjaDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IFQge1xyXG4gICAgY29uc3QgY2xvbmU6IGFueSA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcbiAgICBPYmplY3Qua2V5cyhjbG9uZSkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmIChwYXRjaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSBwYXRjaFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNsb25lO1xyXG59XHJcbiJdfQ==