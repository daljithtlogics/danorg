import { HttpErrorResponse, HttpResponse, } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { DEFAULT_AUTH_TOKEN_HEADER_KEY } from '@vendure/common/lib/shared-constants';
import { switchMap, tap } from 'rxjs/operators';
import { getAppConfig } from '../../app.config';
import { NotificationService } from '../../providers/notification/notification.service';
import * as i0 from "@angular/core";
import * as i1 from "./data.service";
import * as i2 from "../../providers/auth/auth.service";
import * as i3 from "@angular/router";
import * as i4 from "../../providers/local-storage/local-storage.service";
export const AUTH_REDIRECT_PARAM = 'redirectTo';
/**
 * The default interceptor examines all HTTP requests & responses and automatically updates the requesting state
 * and shows error notifications.
 */
export class DefaultInterceptor {
    constructor(dataService, injector, authService, router, localStorageService) {
        this.dataService = dataService;
        this.injector = injector;
        this.authService = authService;
        this.router = router;
        this.localStorageService = localStorageService;
        this.tokenMethod = 'cookie';
        this.tokenMethod = getAppConfig().tokenMethod;
        this.authTokenHeaderKey = getAppConfig().authTokenHeaderKey || DEFAULT_AUTH_TOKEN_HEADER_KEY;
    }
    intercept(req, next) {
        this.dataService.client.startRequest().subscribe();
        return this.dataService.client.uiState().single$.pipe(switchMap(({ uiState }) => {
            const request = req.clone({
                setParams: {
                    languageCode: uiState?.contentLanguage ?? '',
                },
            });
            return next.handle(request);
        }), tap(event => {
            if (event instanceof HttpResponse) {
                this.checkForAuthToken(event);
                this.notifyOnError(event);
                this.dataService.client.completeRequest().subscribe();
            }
        }, err => {
            if (err instanceof HttpErrorResponse) {
                this.notifyOnError(err);
                this.dataService.client.completeRequest().subscribe();
            }
            else {
                this.displayErrorNotification(err.message);
            }
        }));
    }
    notifyOnError(response) {
        if (response instanceof HttpErrorResponse) {
            if (response.status === 0) {
                const { apiHost, apiPort } = getAppConfig();
                this.displayErrorNotification(_(`error.could-not-connect-to-server`), {
                    url: `${apiHost}:${apiPort}`,
                });
            }
            else if (response.status === 503 && response.url?.endsWith('/health')) {
                this.displayErrorNotification(_(`error.health-check-failed`));
            }
            else {
                this.displayErrorNotification(this.extractErrorFromHttpResponse(response));
            }
        }
        else {
            // GraphQL errors still return 200 OK responses, but have the actual error message
            // inside the body of the response.
            const graphQLErrors = response.body.errors;
            if (graphQLErrors && Array.isArray(graphQLErrors)) {
                const firstCode = graphQLErrors[0]?.extensions?.code;
                if (firstCode === 'FORBIDDEN') {
                    this.authService.logOut().subscribe(() => {
                        const { loginUrl } = getAppConfig();
                        // If there is a `loginUrl` which is external to the AdminUI, redirect to it (with no query parameters)
                        if (loginUrl && !this.areUrlsOnSameOrigin(loginUrl, window.location.origin)) {
                            window.location.href = loginUrl;
                            return;
                        }
                        // Else, we build the login path from the login url if one is provided or fallback to `/login`
                        const loginPath = loginUrl ? this.getPathFromLoginUrl(loginUrl) : '/login';
                        if (!window.location.pathname.includes(loginPath)) {
                            const path = graphQLErrors[0].path.join(' > ');
                            this.displayErrorNotification(_(`error.403-forbidden`), { path });
                        }
                        // Navigate to the `loginPath` route by ensuring the query param in charge of the redirection is provided
                        this.router.navigate([loginPath], {
                            queryParams: {
                                [AUTH_REDIRECT_PARAM]: btoa(this.router.url),
                            },
                        });
                    });
                }
                else if (firstCode === 'CHANNEL_NOT_FOUND') {
                    const message = graphQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                    this.localStorageService.remove('activeChannelToken');
                }
                else {
                    const message = graphQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                }
            }
        }
    }
    extractErrorFromHttpResponse(response) {
        const errors = response.error.errors;
        if (Array.isArray(errors)) {
            return errors.map(e => e.message).join('\n');
        }
        else {
            return response.message;
        }
    }
    /**
     * We need to lazily inject the NotificationService since it depends on the I18nService which
     * eventually depends on the HttpClient (used to load messages from json files). If we were to
     * directly inject NotificationService into the constructor, we get a cyclic dependency.
     */
    displayErrorNotification(message, vars) {
        const notificationService = this.injector.get(NotificationService);
        notificationService.error(message, vars);
    }
    /**
     * If the server is configured to use the "bearer" tokenMethod, each response should be checked
     * for the existence of an auth token.
     */
    checkForAuthToken(response) {
        if (this.tokenMethod === 'bearer') {
            const authToken = response.headers.get(this.authTokenHeaderKey);
            if (authToken) {
                this.localStorageService.set('authToken', authToken);
            }
        }
    }
    /**
     * Determine if two urls are on the same origin.
     */
    areUrlsOnSameOrigin(urlA, urlB) {
        return new URL(urlA).origin === new URL(urlB).origin;
    }
    /**
     * If the provided `loginUrl` is on the same origin than the AdminUI, return the path
     * after the `/admin`.
     * Else, return the whole login url.
     */
    getPathFromLoginUrl(loginUrl) {
        if (!this.areUrlsOnSameOrigin(loginUrl, window.location.origin)) {
            return loginUrl;
        }
        return loginUrl.split('/admin')[1];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DefaultInterceptor, deps: [{ token: i1.DataService }, { token: i0.Injector }, { token: i2.AuthService }, { token: i3.Router }, { token: i4.LocalStorageService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DefaultInterceptor }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DefaultInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.DataService }, { type: i0.Injector }, { type: i2.AuthService }, { type: i3.Router }, { type: i4.LocalStorageService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2RhdGEvcHJvdmlkZXJzL2ludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFLakIsWUFBWSxHQUNmLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLGVBQWUsQ0FBQztBQUVyRCxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUMsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBR3JGLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBR2hELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDOzs7Ozs7QUFJeEYsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFDO0FBRWhEOzs7R0FHRztBQUVILE1BQU0sT0FBTyxrQkFBa0I7SUFJM0IsWUFDWSxXQUF3QixFQUN4QixRQUFrQixFQUNsQixXQUF3QixFQUN4QixNQUFjLEVBQ2QsbUJBQXdDO1FBSnhDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFSbkMsZ0JBQVcsR0FBaUMsUUFBUSxDQUFDO1FBVWxFLElBQUksQ0FBQyxXQUFXLEdBQUcsWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDO1FBQzlDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxZQUFZLEVBQUUsQ0FBQyxrQkFBa0Is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bUJBQW1CLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUN4RDtTQUNKO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ssbUJBQW1CLENBQUMsSUFBWSxFQUFFLElBQVk7UUFDbEQsT0FBTyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsUUFBZ0I7UUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM3RCxPQUFPLFFBQVEsQ0FBQztTQUNuQjtRQUNELE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDOzhHQXRKUSxrQkFBa0I7a0hBQWxCLGtCQUFrQjs7MkZBQWxCLGtCQUFrQjtrQkFEOUIsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgSHR0cEVycm9yUmVzcG9uc2UsXG4gICAgSHR0cEV2ZW50LFxuICAgIEh0dHBIYW5kbGVyLFxuICAgIEh0dHBJbnRlcmNlcHRvcixcbiAgICBIdHRwUmVxdWVzdCxcbiAgICBIdHRwUmVzcG9uc2UsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgbWFya2VyIGFzIF8gfSBmcm9tICdAYmllc2JqZXJnL25neC10cmFuc2xhdGUtZXh0cmFjdC1tYXJrZXInO1xuaW1wb3J0IHsgREVGQVVMVF9BVVRIX1RPS0VOX0hFQURFUl9LRVkgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC1jb25zdGFudHMnO1xuaW1wb3J0IHsgQWRtaW5VaUNvbmZpZyB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2hhcmVkLXR5cGVzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN3aXRjaE1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBnZXRBcHBDb25maWcgfSBmcm9tICcuLi8uLi9hcHAuY29uZmlnJztcbmltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL2F1dGgvYXV0aC5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvbG9jYWwtc3RvcmFnZS9sb2NhbC1zdG9yYWdlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4vZGF0YS5zZXJ2aWNlJztcblxuZXhwb3J0IGNvbnN0IEFVVEhfUkVESVJFQ1RfUEFSQU0gPSAncmVkaXJlY3RUbyc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgaW50ZXJjZXB0b3IgZXhhbWluZXMgYWxsIEhUVFAgcmVxdWVzdHMgJiByZXNwb25zZXMgYW5kIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcmVxdWVzdGluZyBzdGF0ZVxuICogYW5kIHNob3dzIGVycm9yIG5vdGlmaWNhdGlvbnMuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdG9rZW5NZXRob2Q6IEFkbWluVWlDb25maWdbJ3Rva2VuTWV0aG9kJ10gPSAnY29va2llJztcbiAgICBwcml2YXRlIHJlYWRvbmx5IGF1dGhUb2tlbkhlYWRlcktleTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICAgICAgcHJpdmF0ZSBhdXRoU2VydmljZTogQXV0aFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsXG4gICAgICAgIHByaXZhdGUgbG9jYWxTdG9yYWdlU2VydmljZTogTG9jYWxTdG9yYWdlU2VydmljZSxcbiAgICApIHtcbiAgICAgICAgdGhpcy50b2tlbk1ldGhvZCA9IGdldEFwcENvbmZpZygpLnRva2VuTWV0aG9kO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbkhlYWRlcktleSA9IGdldEFwcENvbmZpZygpLmF1dGhUb2tlbkhlYWRlcktleSB8fCBERUZBVUxUX0FVVEhfVE9LRU5fSEVBREVSX0tFWTtcbiAgICB9XG5cbiAgICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZS5jbGllbnQuc3RhcnRSZXF1ZXN0KCkuc3Vic2NyaWJlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudC51aVN0YXRlKCkuc2luZ2xlJC5waXBlKFxuICAgICAgICAgICAgc3dpdGNoTWFwKCh7IHVpU3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXEuY2xvbmUoe1xuICAgICAgICAgICAgICAgICAgICBzZXRQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlQ29kZTogdWlTdGF0ZT8uY29udGVudExhbmd1YWdlID8/ICcnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFwKFxuICAgICAgICAgICAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRm9yQXV0aFRva2VuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T25FcnJvcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudC5jb21wbGV0ZVJlcXVlc3QoKS5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50LmNvbXBsZXRlUmVxdWVzdCgpLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24oZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBub3RpZnlPbkVycm9yKHJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8YW55PiB8IEh0dHBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcGlIb3N0LCBhcGlQb3J0IH0gPSBnZXRBcHBDb25maWcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvck5vdGlmaWNhdGlvbihfKGBlcnJvci5jb3VsZC1ub3QtY29ubmVjdC10by1zZXJ2ZXJgKSwge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGAke2FwaUhvc3R9OiR7YXBpUG9ydH1gLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwMyAmJiByZXNwb25zZS51cmw/LmVuZHNXaXRoKCcvaGVhbHRoJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvck5vdGlmaWNhdGlvbihfKGBlcnJvci5oZWFsdGgtY2hlY2stZmFpbGVkYCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvck5vdGlmaWNhdGlvbih0aGlzLmV4dHJhY3RFcnJvckZyb21IdHRwUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdyYXBoUUwgZXJyb3JzIHN0aWxsIHJldHVybiAyMDAgT0sgcmVzcG9uc2VzLCBidXQgaGF2ZSB0aGUgYWN0dWFsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vIGluc2lkZSB0aGUgYm9keSBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCBncmFwaFFMRXJyb3JzID0gcmVzcG9uc2UuYm9keS5lcnJvcnM7XG4gICAgICAgICAgICBpZiAoZ3JhcGhRTEVycm9ycyAmJiBBcnJheS5pc0FycmF5KGdyYXBoUUxFcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDb2RlOiBzdHJpbmcgPSBncmFwaFFMRXJyb3JzWzBdPy5leHRlbnNpb25zPy5jb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q29kZSA9PT0gJ0ZPUkJJRERFTicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoU2VydmljZS5sb2dPdXQoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsb2dpblVybCB9ID0gZ2V0QXBwQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGBsb2dpblVybGAgd2hpY2ggaXMgZXh0ZXJuYWwgdG8gdGhlIEFkbWluVUksIHJlZGlyZWN0IHRvIGl0ICh3aXRoIG5vIHF1ZXJ5IHBhcmFtZXRlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9naW5VcmwgJiYgIXRoaXMuYXJlVXJsc09uU2FtZU9yaWdpbihsb2dpblVybCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGxvZ2luVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgYnVpbGQgdGhlIGxvZ2luIHBhdGggZnJvbSB0aGUgbG9naW4gdXJsIGlmIG9uZSBpcyBwcm92aWRlZCBvciBmYWxsYmFjayB0byBgL2xvZ2luYFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9naW5QYXRoID0gbG9naW5VcmwgPyB0aGlzLmdldFBhdGhGcm9tTG9naW5VcmwobG9naW5VcmwpIDogJy9sb2dpbic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmluY2x1ZGVzKGxvZ2luUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZ3JhcGhRTEVycm9yc1swXS5wYXRoLmpvaW4oJyA+ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKF8oYGVycm9yLjQwMy1mb3JiaWRkZW5gKSwgeyBwYXRoIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgYGxvZ2luUGF0aGAgcm91dGUgYnkgZW5zdXJpbmcgdGhlIHF1ZXJ5IHBhcmFtIGluIGNoYXJnZSBvZiB0aGUgcmVkaXJlY3Rpb24gaXMgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtsb2dpblBhdGhdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0FVVEhfUkVESVJFQ1RfUEFSQU1dOiBidG9hKHRoaXMucm91dGVyLnVybCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Q29kZSA9PT0gJ0NIQU5ORUxfTk9UX0ZPVU5EJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ3JhcGhRTEVycm9ycy5tYXAoZXJyID0+IGVyci5tZXNzYWdlKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxTdG9yYWdlU2VydmljZS5yZW1vdmUoJ2FjdGl2ZUNoYW5uZWxUb2tlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBncmFwaFFMRXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvck5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RFcnJvckZyb21IdHRwUmVzcG9uc2UocmVzcG9uc2U6IEh0dHBFcnJvclJlc3BvbnNlKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gcmVzcG9uc2UuZXJyb3IuZXJyb3JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JzLm1hcChlID0+IGUubWVzc2FnZSkuam9pbignXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gbGF6aWx5IGluamVjdCB0aGUgTm90aWZpY2F0aW9uU2VydmljZSBzaW5jZSBpdCBkZXBlbmRzIG9uIHRoZSBJMThuU2VydmljZSB3aGljaFxuICAgICAqIGV2ZW50dWFsbHkgZGVwZW5kcyBvbiB0aGUgSHR0cENsaWVudCAodXNlZCB0byBsb2FkIG1lc3NhZ2VzIGZyb20ganNvbiBmaWxlcykuIElmIHdlIHdlcmUgdG9cbiAgICAgKiBkaXJlY3RseSBpbmplY3QgTm90aWZpY2F0aW9uU2VydmljZSBpbnRvIHRoZSBjb25zdHJ1Y3Rvciwgd2UgZ2V0IGEgY3ljbGljIGRlcGVuZGVuY3kuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkaXNwbGF5RXJyb3JOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nLCB2YXJzPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb25TZXJ2aWNlID0gdGhpcy5pbmplY3Rvci5nZXQ8Tm90aWZpY2F0aW9uU2VydmljZT4oTm90aWZpY2F0aW9uU2VydmljZSk7XG4gICAgICAgIG5vdGlmaWNhdGlvblNlcnZpY2UuZXJyb3IobWVzc2FnZSwgdmFycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHNlcnZlciBpcyBjb25maWd1cmVkIHRvIHVzZSB0aGUgXCJiZWFyZXJcIiB0b2tlbk1ldGhvZCwgZWFjaCByZXNwb25zZSBzaG91bGQgYmUgY2hlY2tlZFxuICAgICAqIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIGF1dGggdG9rZW4uXG4gICAgICovXG4gICAgcHJpdmF0ZSBjaGVja0ZvckF1dGhUb2tlbihyZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4pIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5NZXRob2QgPT09ICdiZWFyZXInKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRoVG9rZW4gPSByZXNwb25zZS5oZWFkZXJzLmdldCh0aGlzLmF1dGhUb2tlbkhlYWRlcktleSk7XG4gICAgICAgICAgICBpZiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbFN0b3JhZ2VTZXJ2aWNlLnNldCgnYXV0aFRva2VuJywgYXV0aFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0d28gdXJscyBhcmUgb24gdGhlIHNhbWUgb3JpZ2luLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXJlVXJsc09uU2FtZU9yaWdpbih1cmxBOiBzdHJpbmcsIHVybEI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmxBKS5vcmlnaW4gPT09IG5ldyBVUkwodXJsQikub3JpZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm92aWRlZCBgbG9naW5VcmxgIGlzIG9uIHRoZSBzYW1lIG9yaWdpbiB0aGFuIHRoZSBBZG1pblVJLCByZXR1cm4gdGhlIHBhdGhcbiAgICAgKiBhZnRlciB0aGUgYC9hZG1pbmAuXG4gICAgICogRWxzZSwgcmV0dXJuIHRoZSB3aG9sZSBsb2dpbiB1cmwuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRQYXRoRnJvbUxvZ2luVXJsKGxvZ2luVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXRoaXMuYXJlVXJsc09uU2FtZU9yaWdpbihsb2dpblVybCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dpblVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naW5Vcmwuc3BsaXQoJy9hZG1pbicpWzFdO1xuICAgIH1cbn1cbiJdfQ==