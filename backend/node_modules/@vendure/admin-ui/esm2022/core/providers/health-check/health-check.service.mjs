import { Injectable } from '@angular/core';
import { merge, of, Subject, timer } from 'rxjs';
import { catchError, map, shareReplay, switchMap, throttleTime } from 'rxjs/operators';
import { getServerLocation } from '../../data/utils/get-server-location';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
export class HealthCheckService {
    constructor(httpClient) {
        this.httpClient = httpClient;
        this.pollingDelayMs = 60 * 1000;
        this._refresh = new Subject();
        this.healthCheckEndpoint = getServerLocation() + '/health';
        const refresh$ = this._refresh.pipe(throttleTime(1000));
        const result$ = merge(timer(0, this.pollingDelayMs), refresh$).pipe(switchMap(() => this.checkHealth()), shareReplay(1));
        this.status$ = result$.pipe(map(res => res.status));
        this.details$ = result$.pipe(map(res => Object.keys(res.details).map(key => ({ key, result: res.details[key] }))));
        this.lastCheck$ = result$.pipe(map(res => res.lastChecked));
    }
    refresh() {
        this._refresh.next();
    }
    checkHealth() {
        return this.httpClient.get(this.healthCheckEndpoint).pipe(catchError(err => of(err.error)), map(res => ({ ...res, lastChecked: new Date() })));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: HealthCheckService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: HealthCheckService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: HealthCheckService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhbHRoLWNoZWNrLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3Byb3ZpZGVycy9oZWFsdGgtY2hlY2svaGVhbHRoLWNoZWNrLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsS0FBSyxFQUFjLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdELE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7OztBQXVCekUsTUFBTSxPQUFPLGtCQUFrQjtJQVMzQixZQUFvQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBSnpCLG1CQUFjLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUUzQixhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUc1QyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsaUJBQWlCLEVBQUUsR0FBRyxTQUFTLENBQUM7UUFFM0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDeEQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FDL0QsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUNuQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2pCLENBQUM7UUFFRixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUN4QixHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FDTixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUMzRSxDQUNKLENBQUM7UUFDRixJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVELE9BQU87UUFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTyxXQUFXO1FBQ2YsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBb0IsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsSUFBSSxDQUN4RSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQ2hDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsRUFBRSxXQUFXLEVBQUUsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FDcEQsQ0FBQztJQUNOLENBQUM7OEdBcENRLGtCQUFrQjtrSEFBbEIsa0JBQWtCLGNBRmYsTUFBTTs7MkZBRVQsa0JBQWtCO2tCQUg5QixVQUFVO21CQUFDO29CQUNSLFVBQVUsRUFBRSxNQUFNO2lCQUNyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgbWVyZ2UsIE9ic2VydmFibGUsIG9mLCBTdWJqZWN0LCB0aW1lciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAsIHRocm90dGxlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IGdldFNlcnZlckxvY2F0aW9uIH0gZnJvbSAnLi4vLi4vZGF0YS91dGlscy9nZXQtc2VydmVyLWxvY2F0aW9uJztcclxuXHJcbmV4cG9ydCB0eXBlIFN5c3RlbVN0YXR1cyA9ICdvaycgfCAnZXJyb3InO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja1Jlc3VsdCB7XHJcbiAgICBzdGF0dXM6IFN5c3RlbVN0YXR1cztcclxuICAgIGluZm86IHsgW25hbWU6IHN0cmluZ106IEhlYWx0aENoZWNrU3VjY2Vzc1Jlc3VsdCB9O1xyXG4gICAgZGV0YWlsczogeyBbbmFtZTogc3RyaW5nXTogSGVhbHRoQ2hlY2tTdWNjZXNzUmVzdWx0IHwgSGVhbHRoQ2hlY2tFcnJvclJlc3VsdCB9O1xyXG4gICAgZXJyb3I6IHsgW25hbWU6IHN0cmluZ106IEhlYWx0aENoZWNrRXJyb3JSZXN1bHQgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja1N1Y2Nlc3NSZXN1bHQge1xyXG4gICAgc3RhdHVzOiAndXAnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrRXJyb3JSZXN1bHQge1xyXG4gICAgc3RhdHVzOiAnZG93bic7XHJcbiAgICBtZXNzYWdlOiBzdHJpbmc7XHJcbn1cclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICAgIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIEhlYWx0aENoZWNrU2VydmljZSB7XHJcbiAgICBzdGF0dXMkOiBPYnNlcnZhYmxlPFN5c3RlbVN0YXR1cz47XHJcbiAgICBkZXRhaWxzJDogT2JzZXJ2YWJsZTxBcnJheTx7IGtleTogc3RyaW5nOyByZXN1bHQ6IEhlYWx0aENoZWNrU3VjY2Vzc1Jlc3VsdCB8IEhlYWx0aENoZWNrRXJyb3JSZXN1bHQgfT4+O1xyXG4gICAgbGFzdENoZWNrJDogT2JzZXJ2YWJsZTxEYXRlPjtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBvbGxpbmdEZWxheU1zID0gNjAgKiAxMDAwO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBoZWFsdGhDaGVja0VuZHBvaW50OiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9yZWZyZXNoID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHBDbGllbnQ6IEh0dHBDbGllbnQpIHtcclxuICAgICAgICB0aGlzLmhlYWx0aENoZWNrRW5kcG9pbnQgPSBnZXRTZXJ2ZXJMb2NhdGlvbigpICsgJy9oZWFsdGgnO1xyXG5cclxuICAgICAgICBjb25zdCByZWZyZXNoJCA9IHRoaXMuX3JlZnJlc2gucGlwZSh0aHJvdHRsZVRpbWUoMTAwMCkpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCQgPSBtZXJnZSh0aW1lcigwLCB0aGlzLnBvbGxpbmdEZWxheU1zKSwgcmVmcmVzaCQpLnBpcGUoXHJcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aGlzLmNoZWNrSGVhbHRoKCkpLFxyXG4gICAgICAgICAgICBzaGFyZVJlcGxheSgxKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXR1cyQgPSByZXN1bHQkLnBpcGUobWFwKHJlcyA9PiByZXMuc3RhdHVzKSk7XHJcbiAgICAgICAgdGhpcy5kZXRhaWxzJCA9IHJlc3VsdCQucGlwZShcclxuICAgICAgICAgICAgbWFwKHJlcyA9PlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzLmRldGFpbHMpLm1hcChrZXkgPT4gKHsga2V5LCByZXN1bHQ6IHJlcy5kZXRhaWxzW2tleV0gfSkpLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5sYXN0Q2hlY2skID0gcmVzdWx0JC5waXBlKG1hcChyZXMgPT4gcmVzLmxhc3RDaGVja2VkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaCgpIHtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoLm5leHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNoZWNrSGVhbHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuZ2V0PEhlYWx0aENoZWNrUmVzdWx0Pih0aGlzLmhlYWx0aENoZWNrRW5kcG9pbnQpLnBpcGUoXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyID0+IG9mKGVyci5lcnJvcikpLFxyXG4gICAgICAgICAgICBtYXAocmVzID0+ICh7IC4uLnJlcywgbGFzdENoZWNrZWQ6IG5ldyBEYXRlKCkgfSkpLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIl19