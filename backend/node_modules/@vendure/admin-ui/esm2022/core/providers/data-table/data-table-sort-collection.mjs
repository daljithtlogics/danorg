import { assertNever } from '@vendure/common/lib/shared-utils';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { DataTableSort } from './data-table-sort';
export class DataTableSortCollection {
    #sorts;
    #valueChanges$;
    #connectedToRouter;
    #sortQueryParamName;
    #defaultSort;
    constructor(router) {
        this.router = router;
        this.#sorts = [];
        this.#valueChanges$ = new Subject();
        this.#connectedToRouter = false;
        this.valueChanges = this.#valueChanges$.asObservable();
        this.#sortQueryParamName = 'sort';
        this.destroy$ = new Subject();
    }
    get length() {
        return this.#sorts.length;
    }
    destroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    addSort(config) {
        if (this.#connectedToRouter) {
            throw new Error('Cannot add sort after connecting to router. Make sure to call addSort() before connectToRoute()');
        }
        this.#sorts.push(new DataTableSort(config, () => this.onSetValue()));
        return this;
    }
    addSorts(configs) {
        for (const config of configs) {
            this.addSort(config);
        }
        return this;
    }
    addCustomFieldSorts(customFields) {
        for (const config of customFields) {
            const type = config.type;
            if (config.list) {
                continue;
            }
            switch (type) {
                case 'string':
                case 'localeString':
                case 'boolean':
                case 'int':
                case 'float':
                case 'datetime':
                case 'localeText':
                case 'text':
                    this.addSort({ name: config.name });
                    break;
                case 'relation':
                    // Cannot sort relations
                    break;
                default:
                    assertNever(type);
            }
        }
        return this;
    }
    defaultSort(name, sortOrder) {
        this.#defaultSort = { name, sortOrder };
        return this;
    }
    get(name) {
        return this.#sorts.find(s => s.name === name);
    }
    connectToRoute(route) {
        this.valueChanges.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.router.navigate(['./'], {
                queryParams: { [this.#sortQueryParamName]: this.serialize() },
                relativeTo: route,
                queryParamsHandling: 'merge',
            });
        });
        const filterQueryParams = (route.snapshot.queryParamMap.get(this.#sortQueryParamName) ?? '')
            .split(';')
            .map(value => value.split(':'))
            .map(([name, value]) => ({ name, value }));
        for (const { name, value } of filterQueryParams) {
            const sort = this.get(name);
            if (sort) {
                sort.setSortOrder(value);
            }
        }
        this.#connectedToRouter = true;
        return this;
    }
    createSortInput() {
        const activeSorts = this.#sorts.filter(s => s.sortOrder !== undefined);
        let sortInput = {};
        if (activeSorts.length === 0 && this.#defaultSort) {
            return { [this.#defaultSort.name]: this.#defaultSort.sortOrder };
        }
        for (const sort of activeSorts) {
            sortInput = { ...sortInput, [sort.name]: sort.sortOrder };
        }
        return sortInput;
    }
    serialize() {
        const activeSorts = this.#sorts.filter(s => s.sortOrder !== undefined);
        return activeSorts.map(s => `${s.name}:${s.sortOrder}`).join(';');
    }
    onSetValue() {
        this.#valueChanges$.next(this.#sorts
            .filter(f => f.sortOrder !== undefined)
            .map(s => ({ name: s.name, sortOrder: s.sortOrder })));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS10YWJsZS1zb3J0LWNvbGxlY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3Byb3ZpZGVycy9kYXRhLXRhYmxlL2RhdGEtdGFibGUtc29ydC1jb2xsZWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUMvRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzQyxPQUFPLEVBQUUsYUFBYSxFQUE0QyxNQUFNLG1CQUFtQixDQUFDO0FBRTVGLE1BQU0sT0FBTyx1QkFBdUI7SUFJdkIsTUFBTSxDQUF1QztJQUN0RCxjQUFjLENBQXFGO0lBQ25HLGtCQUFrQixDQUFTO0lBRWxCLG1CQUFtQixDQUFVO0lBQ3RDLFlBQVksQ0FBdUU7SUFHbkYsWUFBb0IsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFSekIsV0FBTSxHQUFvQyxFQUFFLENBQUM7UUFDdEQsbUJBQWMsR0FBRyxJQUFJLE9BQU8sRUFBc0UsQ0FBQztRQUNuRyx1QkFBa0IsR0FBRyxLQUFLLENBQUM7UUFDM0IsaUJBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3pDLHdCQUFtQixHQUFHLE1BQU0sQ0FBQztRQUVyQixhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQUVYLENBQUM7SUFFdEMsSUFBSSxNQUFNO1FBQ04sT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUM5QixDQUFDO0lBRUQsT0FBTztRQUNILElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lB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QUFDLENBQUMsSUFBYyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRU8sVUFBVTtRQUNkLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUNwQixJQUFJLENBQUMsTUFBTTthQUNOLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEtBQUssU0FBUyxDQUFDO2FBQ3RDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQVcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FDbkUsQ0FBQztJQUNOLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBDdXN0b21GaWVsZFR5cGUgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC10eXBlcyc7XHJcbmltcG9ydCB7IGFzc2VydE5ldmVyIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtdXRpbHMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgQ3VzdG9tRmllbGRDb25maWcgfSBmcm9tICcuLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgRGF0YVRhYmxlU29ydCwgRGF0YVRhYmxlU29ydE9wdGlvbnMsIERhdGFUYWJsZVNvcnRPcmRlciB9IGZyb20gJy4vZGF0YS10YWJsZS1zb3J0JztcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVTb3J0Q29sbGVjdGlvbjxcclxuICAgIFNvcnRJbnB1dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsICdBU0MnIHwgJ0RFU0MnPixcclxuICAgIE5hbWVzIGV4dGVuZHMgWy4uLkFycmF5PGtleW9mIFNvcnRJbnB1dD5dID0gW10sXHJcbj4ge1xyXG4gICAgcmVhZG9ubHkgI3NvcnRzOiBBcnJheTxEYXRhVGFibGVTb3J0PFNvcnRJbnB1dD4+ID0gW107XHJcbiAgICAjdmFsdWVDaGFuZ2VzJCA9IG5ldyBTdWJqZWN0PEFycmF5PHsgbmFtZTogc3RyaW5nOyBzb3J0T3JkZXI6IERhdGFUYWJsZVNvcnRPcmRlciB8IHVuZGVmaW5lZCB9Pj4oKTtcclxuICAgICNjb25uZWN0ZWRUb1JvdXRlciA9IGZhbHNlO1xyXG4gICAgdmFsdWVDaGFuZ2VzID0gdGhpcy4jdmFsdWVDaGFuZ2VzJC5hc09ic2VydmFibGUoKTtcclxuICAgIHJlYWRvbmx5ICNzb3J0UXVlcnlQYXJhbU5hbWUgPSAnc29ydCc7XHJcbiAgICAjZGVmYXVsdFNvcnQ6IHsgbmFtZToga2V5b2YgU29ydElucHV0OyBzb3J0T3JkZXI6IERhdGFUYWJsZVNvcnRPcmRlciB9IHwgdW5kZWZpbmVkO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFJvdXRlcikge31cclxuXHJcbiAgICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NvcnRzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRTb3J0PE5hbWUgZXh0ZW5kcyBrZXlvZiBTb3J0SW5wdXQ+KFxyXG4gICAgICAgIGNvbmZpZzogRGF0YVRhYmxlU29ydE9wdGlvbnM8U29ydElucHV0LCBOYW1lPixcclxuICAgICk6IERhdGFUYWJsZVNvcnRDb2xsZWN0aW9uPFNvcnRJbnB1dCwgWy4uLk5hbWVzLCBOYW1lXT4ge1xyXG4gICAgICAgIGlmICh0aGlzLiNjb25uZWN0ZWRUb1JvdXRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGFkZCBzb3J0IGFmdGVyIGNvbm5lY3RpbmcgdG8gcm91dGVyLiBNYWtlIHN1cmUgdG8gY2FsbCBhZGRTb3J0KCkgYmVmb3JlIGNvbm5lY3RUb1JvdXRlKCknLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNzb3J0cy5wdXNoKG5ldyBEYXRhVGFibGVTb3J0PFNvcnRJbnB1dD4oY29uZmlnLCAoKSA9PiB0aGlzLm9uU2V0VmFsdWUoKSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgRGF0YVRhYmxlU29ydENvbGxlY3Rpb248U29ydElucHV0LCBbLi4uTmFtZXMsIE5hbWVdPjtcclxuICAgIH1cclxuXHJcbiAgICBhZGRTb3J0czxOYW1lIGV4dGVuZHMga2V5b2YgU29ydElucHV0PihcclxuICAgICAgICBjb25maWdzOiBBcnJheTxEYXRhVGFibGVTb3J0T3B0aW9uczxTb3J0SW5wdXQsIE5hbWU+PixcclxuICAgICk6IERhdGFUYWJsZVNvcnRDb2xsZWN0aW9uPFNvcnRJbnB1dCwgWy4uLk5hbWVzLCBOYW1lXT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRTb3J0KGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzIGFzIHVua25vd24gYXMgRGF0YVRhYmxlU29ydENvbGxlY3Rpb248U29ydElucHV0LCBbLi4uTmFtZXMsIE5hbWVdPjtcclxuICAgIH1cclxuXHJcbiAgICBhZGRDdXN0b21GaWVsZFNvcnRzKGN1c3RvbUZpZWxkczogQ3VzdG9tRmllbGRDb25maWdbXSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGN1c3RvbUZpZWxkcykge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gY29uZmlnLnR5cGUgYXMgQ3VzdG9tRmllbGRUeXBlO1xyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmxpc3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xvY2FsZVN0cmluZyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ludCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmbG9hdCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2NhbGVUZXh0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU29ydCh7IG5hbWU6IGNvbmZpZy5uYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbm5vdCBzb3J0IHJlbGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcih0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBkZWZhdWx0U29ydChuYW1lOiBrZXlvZiBTb3J0SW5wdXQsIHNvcnRPcmRlcjogRGF0YVRhYmxlU29ydE9yZGVyKSB7XHJcbiAgICAgICAgdGhpcy4jZGVmYXVsdFNvcnQgPSB7IG5hbWUsIHNvcnRPcmRlciB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldChuYW1lOiBOYW1lc1tudW1iZXJdKTogRGF0YVRhYmxlU29ydDxTb3J0SW5wdXQ+IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4jc29ydHMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdFRvUm91dGUocm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFsnLi8nXSwge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHsgW3RoaXMuI3NvcnRRdWVyeVBhcmFtTmFtZV06IHRoaXMuc2VyaWFsaXplKCkgfSxcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG86IHJvdXRlLFxyXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNIYW5kbGluZzogJ21lcmdlJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyUXVlcnlQYXJhbXMgPSAocm91dGUuc25hcHNob3QucXVlcnlQYXJhbU1hcC5nZXQodGhpcy4jc29ydFF1ZXJ5UGFyYW1OYW1lKSA/PyAnJylcclxuICAgICAgICAgICAgLnNwbGl0KCc7JylcclxuICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiB2YWx1ZS5zcGxpdCgnOicpKVxyXG4gICAgICAgICAgICAubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgZmlsdGVyUXVlcnlQYXJhbXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHRoaXMuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoc29ydCkge1xyXG4gICAgICAgICAgICAgICAgc29ydC5zZXRTb3J0T3JkZXIodmFsdWUgYXMgYW55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWRUb1JvdXRlciA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU29ydElucHV0KCk6IFNvcnRJbnB1dCB7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlU29ydHMgPSB0aGlzLiNzb3J0cy5maWx0ZXIocyA9PiBzLnNvcnRPcmRlciAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICBsZXQgc29ydElucHV0ID0ge30gYXMgU29ydElucHV0O1xyXG4gICAgICAgIGlmIChhY3RpdmVTb3J0cy5sZW5ndGggPT09IDAgJiYgdGhpcy4jZGVmYXVsdFNvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgW3RoaXMuI2RlZmF1bHRTb3J0Lm5hbWVdOiB0aGlzLiNkZWZhdWx0U29ydC5zb3J0T3JkZXIgfSBhcyBTb3J0SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qgc29ydCBvZiBhY3RpdmVTb3J0cykge1xyXG4gICAgICAgICAgICBzb3J0SW5wdXQgPSB7IC4uLnNvcnRJbnB1dCwgW3NvcnQubmFtZV06IHNvcnQuc29ydE9yZGVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3J0SW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXJpYWxpemUoKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVTb3J0cyA9IHRoaXMuI3NvcnRzLmZpbHRlcihzID0+IHMuc29ydE9yZGVyICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVTb3J0cy5tYXAocyA9PiBgJHtzLm5hbWUgYXMgc3RyaW5nfToke3Muc29ydE9yZGVyfWApLmpvaW4oJzsnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uU2V0VmFsdWUoKSB7XHJcbiAgICAgICAgdGhpcy4jdmFsdWVDaGFuZ2VzJC5uZXh0KFxyXG4gICAgICAgICAgICB0aGlzLiNzb3J0c1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmID0+IGYuc29ydE9yZGVyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gKHsgbmFtZTogcy5uYW1lIGFzIGFueSwgc29ydE9yZGVyOiBzLnNvcnRPcmRlciB9KSksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=