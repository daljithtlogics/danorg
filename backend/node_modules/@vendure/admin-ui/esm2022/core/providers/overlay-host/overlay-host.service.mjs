import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * The OverlayHostService is used to get a reference to the ViewConainerRef of the
 * OverlayHost component, so that other components may insert components & elements
 * into the DOM at that point.
 */
export class OverlayHostService {
    constructor() {
        this.promiseResolveFns = [];
    }
    /**
     * Used to pass in the ViewContainerRed from the OverlayHost component.
     * Should not be used by any other component.
     */
    registerHostView(viewContainerRef) {
        this.hostView = viewContainerRef;
        if (0 < this.promiseResolveFns.length) {
            this.resolveHostView();
        }
    }
    /**
     * Returns a promise which resolves to the ViewContainerRef of the OverlayHost
     * component. This can then be used to insert components and elements into the
     * DOM at that point.
     */
    getHostView() {
        return new Promise((resolve) => {
            this.promiseResolveFns.push(resolve);
            if (this.hostView !== undefined) {
                this.resolveHostView();
            }
        });
    }
    resolveHostView() {
        this.promiseResolveFns.forEach(resolve => resolve(this.hostView));
        this.promiseResolveFns = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OverlayHostService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OverlayHostService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OverlayHostService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1ob3N0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3Byb3ZpZGVycy9vdmVybGF5LWhvc3Qvb3ZlcmxheS1ob3N0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBb0IsTUFBTSxlQUFlLENBQUM7O0FBRTdEOzs7O0dBSUc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBSC9CO1FBS1ksc0JBQWlCLEdBQWlDLEVBQUUsQ0FBQztLQStCaEU7SUE3Qkc7OztPQUdHO0lBQ0gsZ0JBQWdCLENBQUMsZ0JBQWtDO1FBQy9DLElBQUksQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUM7UUFDakMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRTtZQUNuQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDMUI7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFdBQVc7UUFDUCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBOEIsRUFBRSxFQUFFO1lBQ2xELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDckMsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2FBQzFCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sZUFBZTtRQUNuQixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7SUFDaEMsQ0FBQzs4R0FoQ1Esa0JBQWtCO2tIQUFsQixrQkFBa0IsY0FGZixNQUFNOzsyRkFFVCxrQkFBa0I7a0JBSDlCLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBPdmVybGF5SG9zdFNlcnZpY2UgaXMgdXNlZCB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIFZpZXdDb25haW5lclJlZiBvZiB0aGVcclxuICogT3ZlcmxheUhvc3QgY29tcG9uZW50LCBzbyB0aGF0IG90aGVyIGNvbXBvbmVudHMgbWF5IGluc2VydCBjb21wb25lbnRzICYgZWxlbWVudHNcclxuICogaW50byB0aGUgRE9NIGF0IHRoYXQgcG9pbnQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBPdmVybGF5SG9zdFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBob3N0VmlldzogVmlld0NvbnRhaW5lclJlZjtcclxuICAgIHByaXZhdGUgcHJvbWlzZVJlc29sdmVGbnM6IEFycmF5PChyZXN1bHQ6IGFueSkgPT4gdm9pZD4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gcGFzcyBpbiB0aGUgVmlld0NvbnRhaW5lclJlZCBmcm9tIHRoZSBPdmVybGF5SG9zdCBjb21wb25lbnQuXHJcbiAgICAgKiBTaG91bGQgbm90IGJlIHVzZWQgYnkgYW55IG90aGVyIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcmVnaXN0ZXJIb3N0Vmlldyh2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5ob3N0VmlldyA9IHZpZXdDb250YWluZXJSZWY7XHJcbiAgICAgICAgaWYgKDAgPCB0aGlzLnByb21pc2VSZXNvbHZlRm5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVIb3N0VmlldygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBWaWV3Q29udGFpbmVyUmVmIG9mIHRoZSBPdmVybGF5SG9zdFxyXG4gICAgICogY29tcG9uZW50LiBUaGlzIGNhbiB0aGVuIGJlIHVzZWQgdG8gaW5zZXJ0IGNvbXBvbmVudHMgYW5kIGVsZW1lbnRzIGludG8gdGhlXHJcbiAgICAgKiBET00gYXQgdGhhdCBwb2ludC5cclxuICAgICAqL1xyXG4gICAgZ2V0SG9zdFZpZXcoKTogUHJvbWlzZTxWaWV3Q29udGFpbmVyUmVmPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlOiAocmVzdWx0OiBhbnkpID0+IHZvaWQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9taXNlUmVzb2x2ZUZucy5wdXNoKHJlc29sdmUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0VmlldyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVIb3N0VmlldygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNvbHZlSG9zdFZpZXcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlUmVzb2x2ZUZucy5mb3JFYWNoKHJlc29sdmUgPT4gcmVzb2x2ZSh0aGlzLmhvc3RWaWV3KSk7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlUmVzb2x2ZUZucyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==