import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgSelectComponent } from '@ng-select/ng-select';
import { gql } from 'apollo-angular';
import { Subject } from 'rxjs';
import { GetZoneSelectorListDocument } from '../../../common/generated-types';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "@angular/forms";
import * as i3 from "@ng-select/ng-select";
import * as i4 from "@angular/common";
export const GET_ZONE_SELECTOR_LIST = gql `
    query GetZoneSelectorList($options: ZoneListOptions) {
        zones(options: $options) {
            items {
                id
                createdAt
                updatedAt
                name
            }
            totalItems
        }
    }
`;
/**
 * @description
 * A form control for selecting zones.
 *
 * @docsCategory components
 */
export class ZoneSelectorComponent {
    constructor(dataService, changeDetectorRef) {
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.selectedValuesChange = new EventEmitter();
        this.readonly = false;
        this.transformControlValueAccessorValue = value => value?.id;
        this.selectedId$ = new Subject();
        this.disabled = false;
        this.zones$ = this.dataService
            .query(GetZoneSelectorListDocument, { options: { take: 999 } }, 'cache-first')
            .mapSingle(result => result.zones.items);
    }
    onChange(selected) {
        if (this.readonly) {
            return;
        }
        this.selectedValuesChange.emit(selected);
        if (this.onChangeFn) {
            const transformedValue = this.transformControlValueAccessorValue(selected);
            this.onChangeFn(transformedValue);
        }
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    focus() {
        this.ngSelect.focus();
    }
    writeValue(obj) {
        if (typeof obj === 'string' && obj.length > 0) {
            this.value = obj;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: ZoneSelectorComponent, deps: [{ token: i1.DataService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: ZoneSelectorComponent, selector: "vdr-zone-selector", inputs: { readonly: "readonly", transformControlValueAccessorValue: "transformControlValueAccessorValue" }, outputs: { selectedValuesChange: "selectedValuesChange" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: ZoneSelectorComponent,
                multi: true,
            },
        ], viewQueries: [{ propertyName: "ngSelect", first: true, predicate: NgSelectComponent, descendants: true }], ngImport: i0, template: "<ng-select\r\n    [items]=\"zones$ | async\"\r\n    [addTag]=\"false\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    bindValue=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n</ng-select>\r\n", styles: [""], dependencies: [{ kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i3.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "deselectOnClick"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: ZoneSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-zone-selector', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: ZoneSelectorComponent,
                            multi: true,
                        },
                    ], template: "<ng-select\r\n    [items]=\"zones$ | async\"\r\n    [addTag]=\"false\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    bindValue=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n</ng-select>\r\n" }]
        }], ctorParameters: function () { return [{ type: i1.DataService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { selectedValuesChange: [{
                type: Output
            }], readonly: [{
                type: Input
            }], transformControlValueAccessorValue: [{
                type: Input
            }], ngSelect: [{
                type: ViewChild,
                args: [NgSelectComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiem9uZS1zZWxlY3Rvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL3pvbmUtc2VsZWN0b3Ivem9uZS1zZWxlY3Rvci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL3pvbmUtc2VsZWN0b3Ivem9uZS1zZWxlY3Rvci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEdBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRS9CLE9BQU8sRUFBRSwyQkFBMkIsRUFBNEIsTUFBTSxpQ0FBaUMsQ0FBQzs7Ozs7O0FBR3hHLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQTs7Ozs7Ozs7Ozs7O0NBWXhDLENBQUM7QUFJRjs7Ozs7R0FLRztBQWNILE1BQU0sT0FBTyxxQkFBcUI7SUFnQjlCLFlBQW9CLFdBQXdCLEVBQVUsaUJBQW9DO1FBQXRFLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQVUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQWZoRix5QkFBb0IsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBQ2pELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsdUNBQWtDLEdBQXFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNuRyxnQkFBVyxHQUFHLElBQUksT0FBTyxFQUFVLENBQUM7UUFNcEMsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQixXQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVc7YUFDcEIsS0FBSyxDQUFDLDJCQUEyQixFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsYUFBYSxDQUFDO2FBQzdFLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFZ0QsQ0FBQztJQUU5RixRQUFRLENBQUMsUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3pDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDckM7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsRUFBTztRQUNwQixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsaUJBQWlCLENBQUMsRUFBTztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsZ0JBQWdCLENBQUMsVUFBbUI7UUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztJQUVELEtBQUs7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxVQUFVLENBQUMsR0FBeUI7UUFDaEMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDM0MsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7U0FDcEI7SUFDTCxDQUFDOzhHQWpEUSxxQkFBcUI7a0dBQXJCLHFCQUFxQixtTkFSbkI7WUFDUDtnQkFDSSxPQUFPLEVBQUUsaUJBQWlCO2dCQUMxQixXQUFXLEVBQUUscUJBQXFCO2dCQUNsQyxLQUFLLEVBQUUsSUFBSTthQUNkO1NBQ0osb0VBUVUsaUJBQWlCLGdEQzFEaEMsdVJBV0E7OzJGRHlDYSxxQkFBcUI7a0JBYmpDLFNBQVM7K0JBQ0ksbUJBQW1CLG1CQUdaLHVCQUF1QixDQUFDLE1BQU0sYUFDcEM7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyx1QkFBdUI7NEJBQ2xDLEtBQUssRUFBRSxJQUFJO3lCQUNkO3FCQUNKO2tJQUdTLG9CQUFvQjtzQkFBN0IsTUFBTTtnQkFDRSxRQUFRO3NCQUFoQixLQUFLO2dCQUNHLGtDQUFrQztzQkFBMUMsS0FBSztnQkFHZ0MsUUFBUTtzQkFBN0MsU0FBUzt1QkFBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIENvbXBvbmVudCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIElucHV0LFxyXG4gICAgT3V0cHV0LFxyXG4gICAgVmlld0NoaWxkLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IE5nU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnQG5nLXNlbGVjdC9uZy1zZWxlY3QnO1xyXG5pbXBvcnQgeyBncWwgfSBmcm9tICdhcG9sbG8tYW5ndWxhcic7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSXRlbU9mIH0gZnJvbSAnLi4vLi4vLi4vY29tbW9uL2Jhc2UtbGlzdC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBHZXRab25lU2VsZWN0b3JMaXN0RG9jdW1lbnQsIEdldFpvbmVTZWxlY3Rvckxpc3RRdWVyeSB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9nZW5lcmF0ZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RhdGEvcHJvdmlkZXJzL2RhdGEuc2VydmljZSc7XHJcblxyXG5leHBvcnQgY29uc3QgR0VUX1pPTkVfU0VMRUNUT1JfTElTVCA9IGdxbGBcclxuICAgIHF1ZXJ5IEdldFpvbmVTZWxlY3Rvckxpc3QoJG9wdGlvbnM6IFpvbmVMaXN0T3B0aW9ucykge1xyXG4gICAgICAgIHpvbmVzKG9wdGlvbnM6ICRvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGl0ZW1zIHtcclxuICAgICAgICAgICAgICAgIGlkXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXRcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdFxyXG4gICAgICAgICAgICAgICAgbmFtZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvdGFsSXRlbXNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbmA7XHJcblxyXG50eXBlIFpvbmUgPSBJdGVtT2Y8R2V0Wm9uZVNlbGVjdG9yTGlzdFF1ZXJ5LCAnem9uZXMnPjtcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBmb3JtIGNvbnRyb2wgZm9yIHNlbGVjdGluZyB6b25lcy5cclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBjb21wb25lbnRzXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLXpvbmUtc2VsZWN0b3InLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3pvbmUtc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vem9uZS1zZWxlY3Rvci5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogWm9uZVNlbGVjdG9yQ29tcG9uZW50LFxyXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIFpvbmVTZWxlY3RvckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcclxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZFZhbHVlc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Wm9uZT4oKTtcclxuICAgIEBJbnB1dCgpIHJlYWRvbmx5ID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSB0cmFuc2Zvcm1Db250cm9sVmFsdWVBY2Nlc3NvclZhbHVlOiAodmFsdWU6IFpvbmUgfCB1bmRlZmluZWQpID0+IGFueSA9IHZhbHVlID0+IHZhbHVlPy5pZDtcclxuICAgIHNlbGVjdGVkSWQkID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoTmdTZWxlY3RDb21wb25lbnQpIHByaXZhdGUgbmdTZWxlY3Q6IE5nU2VsZWN0Q29tcG9uZW50O1xyXG5cclxuICAgIG9uQ2hhbmdlRm46ICh2YWw6IGFueSkgPT4gdm9pZDtcclxuICAgIG9uVG91Y2hGbjogKCkgPT4gdm9pZDtcclxuICAgIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICB2YWx1ZTogc3RyaW5nIHwgWm9uZTtcclxuICAgIHpvbmVzJCA9IHRoaXMuZGF0YVNlcnZpY2VcclxuICAgICAgICAucXVlcnkoR2V0Wm9uZVNlbGVjdG9yTGlzdERvY3VtZW50LCB7IG9wdGlvbnM6IHsgdGFrZTogOTk5IH0gfSwgJ2NhY2hlLWZpcnN0JylcclxuICAgICAgICAubWFwU2luZ2xlKHJlc3VsdCA9PiByZXN1bHQuem9uZXMuaXRlbXMpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLCBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cclxuXHJcbiAgICBvbkNoYW5nZShzZWxlY3RlZDogWm9uZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlc0NoYW5nZS5lbWl0KHNlbGVjdGVkKTtcclxuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUZuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB0aGlzLnRyYW5zZm9ybUNvbnRyb2xWYWx1ZUFjY2Vzc29yVmFsdWUoc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRm4odHJhbnNmb3JtZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9uVG91Y2hGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzKCkge1xyXG4gICAgICAgIHRoaXMubmdTZWxlY3QuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKG9iajogc3RyaW5nIHwgWm9uZSB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgJiYgb2JqLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiPG5nLXNlbGVjdFxyXG4gICAgW2l0ZW1zXT1cInpvbmVzJCB8IGFzeW5jXCJcclxuICAgIFthZGRUYWddPVwiZmFsc2VcIlxyXG4gICAgYXBwZW5kVG89XCJib2R5XCJcclxuICAgIGJpbmRMYWJlbD1cIm5hbWVcIlxyXG4gICAgYmluZFZhbHVlPVwiaWRcIlxyXG4gICAgW2Rpc2FibGVkXT1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcclxuICAgIFtuZ01vZGVsXT1cInZhbHVlXCJcclxuICAgIChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXHJcbj5cclxuPC9uZy1zZWxlY3Q+XHJcbiJdfQ==