import { ChangeDetectionStrategy, Component } from '@angular/core';
import { UntypedFormControl } from '@angular/forms';
import { HtmlEditorFormInputComponent } from '../../../dynamic-form-inputs/code-editor-form-input/html-editor-form-input.component';
import * as i0 from "@angular/core";
import * as i1 from "../../modal-dialog/dialog-buttons.directive";
import * as i2 from "../../../dynamic-form-inputs/dynamic-form-input/dynamic-form-input.component";
import * as i3 from "@ngx-translate/core";
export class RawHtmlDialogComponent {
    constructor() {
        this.formControl = new UntypedFormControl();
        this.config = {
            name: '',
            type: '',
            list: false,
            required: true,
            ui: { component: HtmlEditorFormInputComponent.id },
        };
    }
    ngOnInit() {
        this.formControl.setValue(this.process(this.html));
    }
    process(str) {
        const div = document.createElement('div');
        div.innerHTML = str.trim();
        return this.format(div, 0).innerHTML.trim();
    }
    /**
     * Taken from https://stackoverflow.com/a/26361620/772859
     */
    format(node, level = 0) {
        const indentBefore = new Array(level++ + 1).join('\t');
        const indentAfter = new Array(level - 1).join('\t');
        let textNode;
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < node.children.length; i++) {
            textNode = document.createTextNode('\n' + indentBefore);
            node.insertBefore(textNode, node.children[i]);
            this.format(node.children[i], level);
            if (node.lastElementChild === node.children[i]) {
                textNode = document.createTextNode('\n' + indentAfter);
                node.appendChild(textNode);
            }
        }
        return node;
    }
    cancel() {
        this.resolveWith(undefined);
    }
    select() {
        this.resolveWith(this.formControl.value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: RawHtmlDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: RawHtmlDialogComponent, selector: "vdr-raw-html-dialog", ngImport: i0, template: "<vdr-dynamic-form-input\r\n                      [def]=\"config\"\r\n                      [control]=\"formControl\"\r\n                  ></vdr-dynamic-form-input>\r\n<ng-template vdrDialogButtons>\r\n    <button type=\"button\" class=\"btn btn-secondary\" (click)=\"cancel()\">\r\n       {{ 'common.cancel' | translate }}\r\n    </button>\r\n    <button type=\"submit\" (click)=\"select()\" class=\"btn btn-primary\" [disabled]=\"formControl.invalid\">\r\n        {{ 'common.update' | translate }}\r\n    </button>\r\n</ng-template>\r\n", styles: [""], dependencies: [{ kind: "directive", type: i1.DialogButtonsDirective, selector: "[vdrDialogButtons]" }, { kind: "component", type: i2.DynamicFormInputComponent, selector: "vdr-dynamic-form-input", inputs: ["def", "readonly", "control"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: RawHtmlDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-raw-html-dialog', changeDetection: ChangeDetectionStrategy.OnPush, template: "<vdr-dynamic-form-input\r\n                      [def]=\"config\"\r\n                      [control]=\"formControl\"\r\n                  ></vdr-dynamic-form-input>\r\n<ng-template vdrDialogButtons>\r\n    <button type=\"button\" class=\"btn btn-secondary\" (click)=\"cancel()\">\r\n       {{ 'common.cancel' | translate }}\r\n    </button>\r\n    <button type=\"submit\" (click)=\"select()\" class=\"btn btn-primary\" [disabled]=\"formControl.invalid\">\r\n        {{ 'common.update' | translate }}\r\n    </button>\r\n</ng-template>\r\n" }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3LWh0bWwtZGlhbG9nLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL2NvbXBvbmVudHMvcmljaC10ZXh0LWVkaXRvci9yYXctaHRtbC1kaWFsb2cvcmF3LWh0bWwtZGlhbG9nLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL2NvbXBvbmVudHMvcmljaC10ZXh0LWVkaXRvci9yYXctaHRtbC1kaWFsb2cvcmF3LWh0bWwtZGlhbG9nLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJcEQsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sc0ZBQXNGLENBQUM7Ozs7O0FBUXBJLE1BQU0sT0FBTyxzQkFBc0I7SUFObkM7UUFRSSxnQkFBVyxHQUFHLElBQUksa0JBQWtCLEVBQUUsQ0FBQztRQUN2QyxXQUFNLEdBQXdCO1lBQzFCLElBQUksRUFBRSxFQUFFO1lBQ1IsSUFBSSxFQUFFLEVBQUU7WUFDUixJQUFJLEVBQUUsS0FBSztZQUNYLFFBQVEsRUFBRSxJQUFJO1lBQ2QsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLDRCQUE0QixDQUFDLEVBQUUsRUFBRTtTQUNyRCxDQUFDO0tBNkNMO0lBekNHLFFBQVE7UUFDSixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxPQUFPLENBQUMsR0FBVztRQUNmLE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDM0IsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDaEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLElBQWEsRUFBRSxLQUFLLEdBQUcsQ0FBQztRQUMzQixNQUFNLFlBQVksR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkQsTUFBTSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLFFBQWMsQ0FBQztRQUVuQiw0REFBNEQ7UUFDNUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNDLFFBQVEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsQ0FBQztZQUN4RCxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFOUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRXJDLElBQUksSUFBSSxDQUFDLGdCQUFnQixLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzVDLFFBQVEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM5QjtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELE1BQU07UUFDRixJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxNQUFNO1FBQ0YsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdDLENBQUM7OEdBckRRLHNCQUFzQjtrR0FBdEIsc0JBQXNCLDJEQ2JuQyw0aEJBWUE7OzJGRENhLHNCQUFzQjtrQkFObEMsU0FBUzsrQkFDSSxxQkFBcUIsbUJBR2QsdUJBQXVCLENBQUMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVbnR5cGVkRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgeyBDb25maWdBcmdEZWZpbml0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29tbW9uL2dlbmVyYXRlZC10eXBlcyc7XHJcbmltcG9ydCB7IERpYWxvZyB9IGZyb20gJy4uLy4uLy4uLy4uL3Byb3ZpZGVycy9tb2RhbC9tb2RhbC50eXBlcyc7XHJcbmltcG9ydCB7IEh0bWxFZGl0b3JGb3JtSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9keW5hbWljLWZvcm0taW5wdXRzL2NvZGUtZWRpdG9yLWZvcm0taW5wdXQvaHRtbC1lZGl0b3ItZm9ybS1pbnB1dC5jb21wb25lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1yYXctaHRtbC1kaWFsb2cnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Jhdy1odG1sLWRpYWxvZy5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9yYXctaHRtbC1kaWFsb2cuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUmF3SHRtbERpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgRGlhbG9nPHN0cmluZz4ge1xyXG4gICAgaHRtbDogc3RyaW5nO1xyXG4gICAgZm9ybUNvbnRyb2wgPSBuZXcgVW50eXBlZEZvcm1Db250cm9sKCk7XHJcbiAgICBjb25maWc6IENvbmZpZ0FyZ0RlZmluaXRpb24gPSB7XHJcbiAgICAgICAgbmFtZTogJycsXHJcbiAgICAgICAgdHlwZTogJycsXHJcbiAgICAgICAgbGlzdDogZmFsc2UsXHJcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgdWk6IHsgY29tcG9uZW50OiBIdG1sRWRpdG9yRm9ybUlucHV0Q29tcG9uZW50LmlkIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIHJlc29sdmVXaXRoOiAoaHRtbDogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xyXG5cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5wcm9jZXNzKHRoaXMuaHRtbCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3Moc3RyOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyLnRyaW0oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGl2LCAwKS5pbm5lckhUTUwudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjYzNjE2MjAvNzcyODU5XHJcbiAgICAgKi9cclxuICAgIGZvcm1hdChub2RlOiBFbGVtZW50LCBsZXZlbCA9IDApIHtcclxuICAgICAgICBjb25zdCBpbmRlbnRCZWZvcmUgPSBuZXcgQXJyYXkobGV2ZWwrKyArIDEpLmpvaW4oJ1xcdCcpO1xyXG4gICAgICAgIGNvbnN0IGluZGVudEFmdGVyID0gbmV3IEFycmF5KGxldmVsIC0gMSkuam9pbignXFx0Jyk7XHJcbiAgICAgICAgbGV0IHRleHROb2RlOiBUZXh0O1xyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxuJyArIGluZGVudEJlZm9yZSk7XHJcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2RlLmNoaWxkcmVuW2ldKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KG5vZGUuY2hpbGRyZW5baV0sIGxldmVsKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxhc3RFbGVtZW50Q2hpbGQgPT09IG5vZGUuY2hpbGRyZW5baV0pIHtcclxuICAgICAgICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcbicgKyBpbmRlbnRBZnRlcik7XHJcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZVdpdGgodW5kZWZpbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3QoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlV2l0aCh0aGlzLmZvcm1Db250cm9sLnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4iLCI8dmRyLWR5bmFtaWMtZm9ybS1pbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgW2RlZl09XCJjb25maWdcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW2NvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIlxyXG4gICAgICAgICAgICAgICAgICA+PC92ZHItZHluYW1pYy1mb3JtLWlucHV0PlxyXG48bmctdGVtcGxhdGUgdmRyRGlhbG9nQnV0dG9ucz5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIiAoY2xpY2spPVwiY2FuY2VsKClcIj5cclxuICAgICAgIHt7ICdjb21tb24uY2FuY2VsJyB8IHRyYW5zbGF0ZSB9fVxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiAoY2xpY2spPVwic2VsZWN0KClcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIFtkaXNhYmxlZF09XCJmb3JtQ29udHJvbC5pbnZhbGlkXCI+XHJcbiAgICAgICAge3sgJ2NvbW1vbi51cGRhdGUnIHwgdHJhbnNsYXRlIH19XHJcbiAgICA8L2J1dHRvbj5cclxuPC9uZy10ZW1wbGF0ZT5cclxuIl19