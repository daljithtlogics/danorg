import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgSelectComponent } from '@ng-select/ng-select';
import { concat, merge, of, Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, mapTo, switchMap, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@ng-select/ng-select";
import * as i5 from "../chip/chip.component";
import * as i6 from "../facet-value-chip/facet-value-chip.component";
import * as i7 from "@ngx-translate/core";
/**
 * @description
 * A form control for selecting facet values.
 *
 * @example
 * ```HTML
 * <vdr-facet-value-selector
 *   [facets]="facets"
 *   (selectedValuesChange)="selectedValues = $event"
 * ></vdr-facet-value-selector>
 * ```
 * The `facets` input should be provided from the parent component
 * like this:
 *
 * @example
 * ```ts
 * this.facets = this.dataService
 *   .facet.getAllFacets()
 *   .mapSingle(data => data.facets.items);
 * ```
 * @docsCategory components
 */
export class FacetValueSelectorComponent {
    constructor(dataService, changeDetectorRef) {
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.selectedValuesChange = new EventEmitter();
        this.readonly = false;
        this.transformControlValueAccessorValue = value => value;
        this.searchInput$ = new Subject();
        this.searchLoading = false;
        this.selectedIds$ = new Subject();
        this.disabled = false;
    }
    ngOnInit() {
        this.initSearchResults();
    }
    initSearchResults() {
        const searchItems$ = this.searchInput$.pipe(debounceTime(200), distinctUntilChanged(), tap(() => (this.searchLoading = true)), switchMap(term => {
            if (!term) {
                return of([]);
            }
            return this.dataService.facet
                .getFacetValues({ take: 100, filter: { name: { contains: term } } })
                .mapSingle(result => result.facetValues.items);
        }), tap(() => (this.searchLoading = false)));
        this.subscription = this.selectedIds$
            .pipe(switchMap(ids => {
            if (!ids.length) {
                return of([]);
            }
            return this.dataService.facet
                .getFacetValues({ take: 100, filter: { id: { in: ids } } }, 'cache-first')
                .mapSingle(result => result.facetValues.items);
        }))
            .subscribe(val => {
            this.value = val;
            this.changeDetectorRef.markForCheck();
        });
        const clear$ = this.selectedValuesChange.pipe(mapTo([]));
        this.searchResults$ = concat(of([]), merge(searchItems$, clear$));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    onChange(selected) {
        if (this.readonly) {
            return;
        }
        this.selectedValuesChange.emit(selected);
        if (this.onChangeFn) {
            const transformedValue = this.transformControlValueAccessorValue(selected);
            this.onChangeFn(transformedValue);
        }
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    focus() {
        this.ngSelect.focus();
    }
    writeValue(obj) {
        let valueIds;
        if (typeof obj === 'string') {
            try {
                const facetValueIds = JSON.parse(obj);
                valueIds = facetValueIds;
            }
            catch (err) {
                // TODO: log error
                throw err;
            }
        }
        else if (Array.isArray(obj)) {
            const isIdArray = (input) => input.every(i => typeof i === 'number' || typeof i === 'string');
            if (isIdArray(obj)) {
                valueIds = obj.map(fv => fv.toString());
            }
            else {
                valueIds = obj.map(fv => fv.id);
            }
        }
        if (valueIds) {
            // this.value = valueIds;
            this.selectedIds$.next(valueIds);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: FacetValueSelectorComponent, deps: [{ token: i1.DataService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: FacetValueSelectorComponent, selector: "vdr-facet-value-selector", inputs: { readonly: "readonly", transformControlValueAccessorValue: "transformControlValueAccessorValue" }, outputs: { selectedValuesChange: "selectedValuesChange" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: FacetValueSelectorComponent,
                multi: true,
            },
        ], viewQueries: [{ propertyName: "ngSelect", first: true, predicate: NgSelectComponent, descendants: true }], ngImport: i0, template: "<ng-select\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    multiple=\"true\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n    <ng-template ng-label-tmp let-item=\"item\" let-clear=\"clear\">\r\n        <vdr-facet-value-chip\r\n            *ngIf=\"item; else facetNotFound\"\r\n            [facetValue]=\"item\"\r\n            [removable]=\"!readonly\"\r\n            (remove)=\"clear(item)\"\r\n        ></vdr-facet-value-chip>\r\n        <ng-template #facetNotFound>\r\n            <vdr-chip colorType=\"error\" icon=\"times\" (iconClick)=\"clear(item)\">{{\r\n                'catalog.facet-value-not-available' | translate: { id: item.id }\r\n            }}</vdr-chip>\r\n        </ng-template>\r\n    </ng-template>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <vdr-facet-value-chip [facetValue]=\"item\" [removable]=\"false\"></vdr-facet-value-chip>\r\n    </ng-template>\r\n</ng-select>\r\n", styles: [""], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i4.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "deselectOnClick"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "directive", type: i4.NgOptionTemplateDirective, selector: "[ng-option-tmp]" }, { kind: "directive", type: i4.NgLabelTemplateDirective, selector: "[ng-label-tmp]" }, { kind: "component", type: i5.ChipComponent, selector: "vdr-chip", inputs: ["icon", "invert", "colorFrom", "colorType"], outputs: ["iconClick"] }, { kind: "component", type: i6.FacetValueChipComponent, selector: "vdr-facet-value-chip", inputs: ["facetValue", "removable", "displayFacetName"], outputs: ["remove"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }, { kind: "pipe", type: i7.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: FacetValueSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-facet-value-selector', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: FacetValueSelectorComponent,
                            multi: true,
                        },
                    ], template: "<ng-select\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    multiple=\"true\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n    <ng-template ng-label-tmp let-item=\"item\" let-clear=\"clear\">\r\n        <vdr-facet-value-chip\r\n            *ngIf=\"item; else facetNotFound\"\r\n            [facetValue]=\"item\"\r\n            [removable]=\"!readonly\"\r\n            (remove)=\"clear(item)\"\r\n        ></vdr-facet-value-chip>\r\n        <ng-template #facetNotFound>\r\n            <vdr-chip colorType=\"error\" icon=\"times\" (iconClick)=\"clear(item)\">{{\r\n                'catalog.facet-value-not-available' | translate: { id: item.id }\r\n            }}</vdr-chip>\r\n        </ng-template>\r\n    </ng-template>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <vdr-facet-value-chip [facetValue]=\"item\" [removable]=\"false\"></vdr-facet-value-chip>\r\n    </ng-template>\r\n</ng-select>\r\n" }]
        }], ctorParameters: function () { return [{ type: i1.DataService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { selectedValuesChange: [{
                type: Output
            }], readonly: [{
                type: Input
            }], transformControlValueAccessorValue: [{
                type: Input
            }], ngSelect: [{
                type: ViewChild,
                args: [NgSelectComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQtdmFsdWUtc2VsZWN0b3IuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvY29tcG9uZW50cy9mYWNldC12YWx1ZS1zZWxlY3Rvci9mYWNldC12YWx1ZS1zZWxlY3Rvci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL2ZhY2V0LXZhbHVlLXNlbGVjdG9yL2ZhY2V0LXZhbHVlLXNlbGVjdG9yLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBR0wsTUFBTSxFQUNOLFNBQVMsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekQsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7Ozs7QUFLM0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQWNILE1BQU0sT0FBTywyQkFBMkI7SUFnQnBDLFlBQW9CLFdBQXdCLEVBQVUsaUJBQW9DO1FBQXRFLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQVUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQWZoRix5QkFBb0IsR0FBRyxJQUFJLFlBQVksRUFBd0IsQ0FBQztRQUNqRSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLHVDQUFrQyxH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TTtnQkFDSCxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUNuQztTQUNKO1FBQ0QsSUFBSSxRQUFRLEVBQUU7WUFDVix5QkFBeUI7WUFDekIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDcEM7SUFDTCxDQUFDOzhHQTlHUSwyQkFBMkI7a0dBQTNCLDJCQUEyQiwwTkFSekI7WUFDUDtnQkFDSSxPQUFPLEVBQUUsaUJBQWlCO2dCQUMxQixXQUFXLEVBQUUsMkJBQTJCO2dCQUN4QyxLQUFLLEVBQUUsSUFBSTthQUNkO1NBQ0osb0VBV1UsaUJBQWlCLGdEQy9EaEMsK29DQThCQTs7MkZEd0JhLDJCQUEyQjtrQkFidkMsU0FBUzsrQkFDSSwwQkFBMEIsbUJBR25CLHVCQUF1QixDQUFDLE1BQU0sYUFDcEM7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyw2QkFBNkI7NEJBQ3hDLEtBQUssRUFBRSxJQUFJO3lCQUNkO3FCQUNKO2tJQUdTLG9CQUFvQjtzQkFBN0IsTUFBTTtnQkFDRSxRQUFRO3NCQUFoQixLQUFLO2dCQUNHLGtDQUFrQztzQkFBMUMsS0FBSztnQkFNZ0MsUUFBUTtzQkFBN0MsU0FBUzt1QkFBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIENvbXBvbmVudCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIElucHV0LFxyXG4gICAgT25EZXN0cm95LFxyXG4gICAgT25Jbml0LFxyXG4gICAgT3V0cHV0LFxyXG4gICAgVmlld0NoaWxkLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IE5nU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnQG5nLXNlbGVjdC9uZy1zZWxlY3QnO1xyXG5pbXBvcnQgeyBjb25jYXQsIG1lcmdlLCBPYnNlcnZhYmxlLCBvZiwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcFRvLCBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IEZhY2V0VmFsdWUsIEZhY2V0VmFsdWVGcmFnbWVudCB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9nZW5lcmF0ZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RhdGEvcHJvdmlkZXJzL2RhdGEuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgZm9ybSBjb250cm9sIGZvciBzZWxlY3RpbmcgZmFjZXQgdmFsdWVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBIVE1MXHJcbiAqIDx2ZHItZmFjZXQtdmFsdWUtc2VsZWN0b3JcclxuICogICBbZmFjZXRzXT1cImZhY2V0c1wiXHJcbiAqICAgKHNlbGVjdGVkVmFsdWVzQ2hhbmdlKT1cInNlbGVjdGVkVmFsdWVzID0gJGV2ZW50XCJcclxuICogPjwvdmRyLWZhY2V0LXZhbHVlLXNlbGVjdG9yPlxyXG4gKiBgYGBcclxuICogVGhlIGBmYWNldHNgIGlucHV0IHNob3VsZCBiZSBwcm92aWRlZCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50XHJcbiAqIGxpa2UgdGhpczpcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogdGhpcy5mYWNldHMgPSB0aGlzLmRhdGFTZXJ2aWNlXHJcbiAqICAgLmZhY2V0LmdldEFsbEZhY2V0cygpXHJcbiAqICAgLm1hcFNpbmdsZShkYXRhID0+IGRhdGEuZmFjZXRzLml0ZW1zKTtcclxuICogYGBgXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgY29tcG9uZW50c1xyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1mYWNldC12YWx1ZS1zZWxlY3RvcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmFjZXQtdmFsdWUtc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vZmFjZXQtdmFsdWUtc2VsZWN0b3IuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IEZhY2V0VmFsdWVTZWxlY3RvckNvbXBvbmVudCxcclxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGYWNldFZhbHVlU2VsZWN0b3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xyXG4gICAgQE91dHB1dCgpIHNlbGVjdGVkVmFsdWVzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldFZhbHVlRnJhZ21lbnRbXT4oKTtcclxuICAgIEBJbnB1dCgpIHJlYWRvbmx5ID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSB0cmFuc2Zvcm1Db250cm9sVmFsdWVBY2Nlc3NvclZhbHVlOiAodmFsdWU6IEZhY2V0VmFsdWVGcmFnbWVudFtdKSA9PiBhbnlbXSA9IHZhbHVlID0+IHZhbHVlO1xyXG4gICAgc2VhcmNoSW5wdXQkID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xyXG4gICAgc2VhcmNoTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgc2VhcmNoUmVzdWx0cyQ6IE9ic2VydmFibGU8RmFjZXRWYWx1ZUZyYWdtZW50W10+O1xyXG4gICAgc2VsZWN0ZWRJZHMkID0gbmV3IFN1YmplY3Q8c3RyaW5nW10+KCk7XHJcblxyXG4gICAgQFZpZXdDaGlsZChOZ1NlbGVjdENvbXBvbmVudCkgcHJpdmF0ZSBuZ1NlbGVjdDogTmdTZWxlY3RDb21wb25lbnQ7XHJcblxyXG4gICAgb25DaGFuZ2VGbjogKHZhbDogYW55KSA9PiB2b2lkO1xyXG4gICAgb25Ub3VjaEZuOiAoKSA9PiB2b2lkO1xyXG4gICAgZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIHZhbHVlOiBBcnJheTxzdHJpbmcgfCBGYWNldFZhbHVlRnJhZ21lbnQ+O1xyXG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLCBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cclxuXHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmluaXRTZWFyY2hSZXN1bHRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0U2VhcmNoUmVzdWx0cygpIHtcclxuICAgICAgICBjb25zdCBzZWFyY2hJdGVtcyQgPSB0aGlzLnNlYXJjaElucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwKSxcclxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgICAgICAgdGFwKCgpID0+ICh0aGlzLnNlYXJjaExvYWRpbmcgPSB0cnVlKSksXHJcbiAgICAgICAgICAgIHN3aXRjaE1hcCh0ZXJtID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGVybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5mYWNldFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRGYWNldFZhbHVlcyh7IHRha2U6IDEwMCwgZmlsdGVyOiB7IG5hbWU6IHsgY29udGFpbnM6IHRlcm0gfSB9IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcFNpbmdsZShyZXN1bHQgPT4gcmVzdWx0LmZhY2V0VmFsdWVzLml0ZW1zKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRhcCgoKSA9PiAodGhpcy5zZWFyY2hMb2FkaW5nID0gZmFsc2UpKSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3RlZElkcyRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoaWRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZmFjZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEZhY2V0VmFsdWVzKHsgdGFrZTogMTAwLCBmaWx0ZXI6IHsgaWQ6IHsgaW46IGlkcyB9IH0gfSwgJ2NhY2hlLWZpcnN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcFNpbmdsZShyZXN1bHQgPT4gcmVzdWx0LmZhY2V0VmFsdWVzLml0ZW1zKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2xlYXIkID0gdGhpcy5zZWxlY3RlZFZhbHVlc0NoYW5nZS5waXBlKG1hcFRvKFtdKSk7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzJCA9IGNvbmNhdChvZihbXSksIG1lcmdlKHNlYXJjaEl0ZW1zJCwgY2xlYXIkKSk7XHJcbiAgICB9XHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkNoYW5nZShzZWxlY3RlZDogRmFjZXRWYWx1ZUZyYWdtZW50W10pIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkb25seSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZXNDaGFuZ2UuZW1pdChzZWxlY3RlZCk7XHJcbiAgICAgICAgaWYgKHRoaXMub25DaGFuZ2VGbikge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gdGhpcy50cmFuc2Zvcm1Db250cm9sVmFsdWVBY2Nlc3NvclZhbHVlKHNlbGVjdGVkKTtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUZuKHRyYW5zZm9ybWVkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlRm4gPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5vblRvdWNoRm4gPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICBmb2N1cygpIHtcclxuICAgICAgICB0aGlzLm5nU2VsZWN0LmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVWYWx1ZShvYmo6IHN0cmluZyB8IEZhY2V0VmFsdWVGcmFnbWVudFtdIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdmFsdWVJZHM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmFjZXRWYWx1ZUlkcyA9IEpTT04ucGFyc2Uob2JqKSBhcyBzdHJpbmdbXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlSWRzID0gZmFjZXRWYWx1ZUlkcztcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBsb2cgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSWRBcnJheSA9IChpbnB1dDogdW5rbm93bltdKTogaW5wdXQgaXMgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9PlxyXG4gICAgICAgICAgICAgICAgaW5wdXQuZXZlcnkoaSA9PiB0eXBlb2YgaSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGkgPT09ICdzdHJpbmcnKTtcclxuICAgICAgICAgICAgaWYgKGlzSWRBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUlkcyA9IG9iai5tYXAoZnYgPT4gZnYudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUlkcyA9IG9iai5tYXAoZnYgPT4gZnYuaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZUlkcykge1xyXG4gICAgICAgICAgICAvLyB0aGlzLnZhbHVlID0gdmFsdWVJZHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJZHMkLm5leHQodmFsdWVJZHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCI8bmctc2VsZWN0XHJcbiAgICBbaXRlbXNdPVwic2VhcmNoUmVzdWx0cyQgfCBhc3luY1wiXHJcbiAgICBbYWRkVGFnXT1cImZhbHNlXCJcclxuICAgIFtoaWRlU2VsZWN0ZWRdPVwidHJ1ZVwiXHJcbiAgICBbbG9hZGluZ109XCJzZWFyY2hMb2FkaW5nXCJcclxuICAgIFt0eXBlYWhlYWRdPVwic2VhcmNoSW5wdXQkXCJcclxuICAgIG11bHRpcGxlPVwidHJ1ZVwiXHJcbiAgICBhcHBlbmRUbz1cImJvZHlcIlxyXG4gICAgYmluZExhYmVsPVwibmFtZVwiXHJcbiAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxyXG4gICAgW25nTW9kZWxdPVwidmFsdWVcIlxyXG4gICAgKGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcclxuPlxyXG4gICAgPG5nLXRlbXBsYXRlIG5nLWxhYmVsLXRtcCBsZXQtaXRlbT1cIml0ZW1cIiBsZXQtY2xlYXI9XCJjbGVhclwiPlxyXG4gICAgICAgIDx2ZHItZmFjZXQtdmFsdWUtY2hpcFxyXG4gICAgICAgICAgICAqbmdJZj1cIml0ZW07IGVsc2UgZmFjZXROb3RGb3VuZFwiXHJcbiAgICAgICAgICAgIFtmYWNldFZhbHVlXT1cIml0ZW1cIlxyXG4gICAgICAgICAgICBbcmVtb3ZhYmxlXT1cIiFyZWFkb25seVwiXHJcbiAgICAgICAgICAgIChyZW1vdmUpPVwiY2xlYXIoaXRlbSlcIlxyXG4gICAgICAgID48L3Zkci1mYWNldC12YWx1ZS1jaGlwPlxyXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjZmFjZXROb3RGb3VuZD5cclxuICAgICAgICAgICAgPHZkci1jaGlwIGNvbG9yVHlwZT1cImVycm9yXCIgaWNvbj1cInRpbWVzXCIgKGljb25DbGljayk9XCJjbGVhcihpdGVtKVwiPnt7XHJcbiAgICAgICAgICAgICAgICAnY2F0YWxvZy5mYWNldC12YWx1ZS1ub3QtYXZhaWxhYmxlJyB8IHRyYW5zbGF0ZTogeyBpZDogaXRlbS5pZCB9XHJcbiAgICAgICAgICAgIH19PC92ZHItY2hpcD5cclxuICAgICAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDxuZy10ZW1wbGF0ZSBuZy1vcHRpb24tdG1wIGxldC1pdGVtPVwiaXRlbVwiPlxyXG4gICAgICAgIDx2ZHItZmFjZXQtdmFsdWUtY2hpcCBbZmFjZXRWYWx1ZV09XCJpdGVtXCIgW3JlbW92YWJsZV09XCJmYWxzZVwiPjwvdmRyLWZhY2V0LXZhbHVlLWNoaXA+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG48L25nLXNlbGVjdD5cclxuIl19