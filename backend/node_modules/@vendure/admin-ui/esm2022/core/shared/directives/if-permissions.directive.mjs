import { Directive, Input, } from '@angular/core';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { IfDirectiveBase } from './if-directive-base';
import * as i0 from "@angular/core";
import * as i1 from "../../data/providers/data.service";
/**
 * @description
 * Conditionally shows/hides templates based on the current active user having the specified permission.
 * Based on the ngIf source. Also support "else" templates:
 *
 * @example
 * ```html
 * <button *vdrIfPermissions="'DeleteCatalog'; else unauthorized">Delete Product</button>
 * <ng-template #unauthorized>Not allowed!</ng-template>
 * ```
 *
 * The permission can be a single string, or an array. If an array is passed, then _all_ of the permissions
 * must match (logical AND)
 *
 * @docsCategory directives
 */
export class IfPermissionsDirective extends IfDirectiveBase {
    constructor(_viewContainer, templateRef, dataService, changeDetectorRef) {
        super(_viewContainer, templateRef, permissions => {
            if (permissions == null) {
                return of(true);
            }
            else if (!permissions) {
                return of(false);
            }
            return this.dataService.client
                .userStatus()
                .mapStream(({ userStatus }) => {
                for (const permission of permissions) {
                    if (userStatus.permissions.includes(permission)) {
                        return true;
                    }
                }
                return false;
            })
                .pipe(tap(() => this.changeDetectorRef.markForCheck()));
        });
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.permissionToCheck = ['__initial_value__'];
    }
    /**
     * The permission to check to determine whether to show the template.
     */
    set vdrIfPermissions(permission) {
        this.permissionToCheck =
            (permission && (Array.isArray(permission) ? permission : [permission])) || null;
        this.updateArgs$.next([this.permissionToCheck]);
    }
    /**
     * A template to show if the current user does not have the specified permission.
     */
    set vdrIfPermissionsElse(templateRef) {
        this.setElseTemplate(templateRef);
        this.updateArgs$.next([this.permissionToCheck]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: IfPermissionsDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i1.DataService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.2", type: IfPermissionsDirective, selector: "[vdrIfPermissions]", inputs: { vdrIfPermissions: "vdrIfPermissions", vdrIfPermissionsElse: "vdrIfPermissionsElse" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: IfPermissionsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[vdrIfPermissions]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i1.DataService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { vdrIfPermissions: [{
                type: Input
            }], vdrIfPermissionsElse: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtcGVybWlzc2lvbnMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvZGlyZWN0aXZlcy9pZi1wZXJtaXNzaW9ucy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVILFNBQVMsRUFFVCxLQUFLLEdBR1IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLckMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7QUFFdEQ7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBSUgsTUFBTSxPQUFPLHNCQUF1QixTQUFRLGVBQTJDO0lBR25GLFlBQ0ksY0FBZ0MsRUFDaEMsV0FBNkIsRUFDckIsV0FBd0IsRUFDeEIsaUJBQW9DO1FBRTVDLEtBQUssQ0FBQyxjQUFjLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxFQUFFO1lBQzdDLElBQUksV0FBVyxJQUFJLElBQUksRUFBRTtnQkFDckIsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbkI7aUJBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDckIsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDcEI7WUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTTtpQkFDekIsVUFBVSxFQUFFO2lCQUNaLFNBQVMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRTtnQkFDMUIsS0FBSyxNQUFNLFVBQVUsSUFBSSxXQUFXLEVBQUU7b0JBQ2xDLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQzdDLE9BQU8sSUFBSSxDQUFDO3FCQUNmO2lCQUNKO2dCQUNELE9BQU8sS0FBSyxDQUFDO1lBQ2pCLENBQUMsQ0FBQztpQkFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDLENBQUM7UUFwQkssZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQU54QyxzQkFBaUIsR0FBb0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBMEJuRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLGdCQUFnQixDQUFDLFVBQW9DO1FBQ3JELElBQUksQ0FBQyxpQkFBaUI7WUFDbEIsQ0FBQyxVQUFVLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQztRQUNwRixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUMsQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFDSSxvQkFBb0IsQ0FBQyxXQUFvQztRQUN6RCxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQyxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDOzhHQTlDUSxzQkFBc0I7a0dBQXRCLHNCQUFzQjs7MkZBQXRCLHNCQUFzQjtrQkFIbEMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsb0JBQW9CO2lCQUNqQzsyTEFrQ08sZ0JBQWdCO3NCQURuQixLQUFLO2dCQVdGLG9CQUFvQjtzQkFEdkIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIERpcmVjdGl2ZSxcclxuICAgIEVtYmVkZGVkVmlld1JlZixcclxuICAgIElucHV0LFxyXG4gICAgVGVtcGxhdGVSZWYsXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vY29tbW9uL2dlbmVyYXRlZC10eXBlcyc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGF0YS9wcm92aWRlcnMvZGF0YS5zZXJ2aWNlJztcclxuXHJcbmltcG9ydCB7IElmRGlyZWN0aXZlQmFzZSB9IGZyb20gJy4vaWYtZGlyZWN0aXZlLWJhc2UnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb25kaXRpb25hbGx5IHNob3dzL2hpZGVzIHRlbXBsYXRlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBhY3RpdmUgdXNlciBoYXZpbmcgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxyXG4gKiBCYXNlZCBvbiB0aGUgbmdJZiBzb3VyY2UuIEFsc28gc3VwcG9ydCBcImVsc2VcIiB0ZW1wbGF0ZXM6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGh0bWxcclxuICogPGJ1dHRvbiAqdmRySWZQZXJtaXNzaW9ucz1cIidEZWxldGVDYXRhbG9nJzsgZWxzZSB1bmF1dGhvcml6ZWRcIj5EZWxldGUgUHJvZHVjdDwvYnV0dG9uPlxyXG4gKiA8bmctdGVtcGxhdGUgI3VuYXV0aG9yaXplZD5Ob3QgYWxsb3dlZCE8L25nLXRlbXBsYXRlPlxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIHBlcm1pc3Npb24gY2FuIGJlIGEgc2luZ2xlIHN0cmluZywgb3IgYW4gYXJyYXkuIElmIGFuIGFycmF5IGlzIHBhc3NlZCwgdGhlbiBfYWxsXyBvZiB0aGUgcGVybWlzc2lvbnNcclxuICogbXVzdCBtYXRjaCAobG9naWNhbCBBTkQpXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgZGlyZWN0aXZlc1xyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t2ZHJJZlBlcm1pc3Npb25zXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJZlBlcm1pc3Npb25zRGlyZWN0aXZlIGV4dGVuZHMgSWZEaXJlY3RpdmVCYXNlPEFycmF5PFBlcm1pc3Npb25bXSB8IG51bGw+PiB7XHJcbiAgICBwcml2YXRlIHBlcm1pc3Npb25Ub0NoZWNrOiBzdHJpbmdbXSB8IG51bGwgPSBbJ19faW5pdGlhbF92YWx1ZV9fJ107XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXHJcbiAgICAgICAgcHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICApIHtcclxuICAgICAgICBzdXBlcihfdmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIHBlcm1pc3Npb25zID0+IHtcclxuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb25zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZih0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghcGVybWlzc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50XHJcbiAgICAgICAgICAgICAgICAudXNlclN0YXR1cygpXHJcbiAgICAgICAgICAgICAgICAubWFwU3RyZWFtKCh7IHVzZXJTdGF0dXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGVybWlzc2lvbiBvZiBwZXJtaXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlclN0YXR1cy5wZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtaXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5waXBlKHRhcCgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGVybWlzc2lvbiB0byBjaGVjayB0byBkZXRlcm1pbmUgd2hldGhlciB0byBzaG93IHRoZSB0ZW1wbGF0ZS5cclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIHNldCB2ZHJJZlBlcm1pc3Npb25zKHBlcm1pc3Npb246IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGVybWlzc2lvblRvQ2hlY2sgPVxyXG4gICAgICAgICAgICAocGVybWlzc2lvbiAmJiAoQXJyYXkuaXNBcnJheShwZXJtaXNzaW9uKSA/IHBlcm1pc3Npb24gOiBbcGVybWlzc2lvbl0pKSB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXJncyQubmV4dChbdGhpcy5wZXJtaXNzaW9uVG9DaGVjayBhcyBQZXJtaXNzaW9uW11dKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgdGVtcGxhdGUgdG8gc2hvdyBpZiB0aGUgY3VycmVudCB1c2VyIGRvZXMgbm90IGhhdmUgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgc2V0IHZkcklmUGVybWlzc2lvbnNFbHNlKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+IHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc2V0RWxzZVRlbXBsYXRlKHRlbXBsYXRlUmVmKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyZ3MkLm5leHQoW3RoaXMucGVybWlzc2lvblRvQ2hlY2sgYXMgUGVybWlzc2lvbltdXSk7XHJcbiAgICB9XHJcbn1cclxuIl19