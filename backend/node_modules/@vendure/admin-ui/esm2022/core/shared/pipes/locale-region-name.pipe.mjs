import { Optional, Pipe } from '@angular/core';
import { LocaleBasePipe } from './locale-base.pipe';
import * as i0 from "@angular/core";
import * as i1 from "../../data/providers/data.service";
/**
 * @description
 * Displays a human-readable name for a given region.
 *
 * @example
 * ```HTML
 * {{ 'GB' | localeRegionName }}
 * ```
 *
 * @docsCategory pipes
 */
export class LocaleRegionNamePipe extends LocaleBasePipe {
    constructor(dataService, changeDetectorRef) {
        super(dataService, changeDetectorRef);
    }
    transform(value, locale) {
        if (value == null || value === '') {
            return '';
        }
        if (typeof value !== 'string') {
            return `Invalid region code "${value}"`;
        }
        const activeLocale = this.getActiveLocale(locale);
        // Awaiting TS types for this API: https://github.com/microsoft/TypeScript/pull/44022/files
        const DisplayNames = Intl.DisplayNames;
        try {
            return new DisplayNames([activeLocale.replace('_', '-')], { type: 'region' }).of(value.replace('_', '-'));
        }
        catch (e) {
            return value;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: LocaleRegionNamePipe, deps: [{ token: i1.DataService, optional: true }, { token: i0.ChangeDetectorRef, optional: true }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.2", ngImport: i0, type: LocaleRegionNamePipe, name: "localeRegionName", pure: false }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: LocaleRegionNamePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'localeRegionName',
                    pure: false,
                }]
        }], ctorParameters: function () { return [{ type: i1.DataService, decorators: [{
                    type: Optional
                }] }, { type: i0.ChangeDetectorRef, decorators: [{
                    type: Optional
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxlLXJlZ2lvbi1uYW1lLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9waXBlcy9sb2NhbGUtcmVnaW9uLW5hbWUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQXFCLFFBQVEsRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBSWpGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7O0FBRXBEOzs7Ozs7Ozs7O0dBVUc7QUFLSCxNQUFNLE9BQU8sb0JBQXFCLFNBQVEsY0FBYztJQUNwRCxZQUF3QixXQUF5QixFQUFjLGlCQUFxQztRQUNoRyxLQUFLLENBQUMsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUNELFNBQVMsQ0FBQyxLQUFVLEVBQUUsTUFBZ0I7UUFDbEMsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7WUFDL0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzNCLE9BQU8sd0JBQXdCLEtBQVksR0FBRyxDQUFDO1NBQ2xEO1FBQ0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsRCwyRkFBMkY7UUFDM0YsTUFBTSxZQUFZLEdBQUksSUFBWSxDQUFDLFlBQVksQ0FBQztRQUVoRCxJQUFJO1lBQ0EsT0FBTyxJQUFJLFlBQVksQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQzVFLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUMxQixDQUFDO1NBQ0w7UUFBQyxPQUFPLENBQU0sRUFBRTtZQUNiLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQzs4R0F2QlEsb0JBQW9COzRHQUFwQixvQkFBb0I7OzJGQUFwQixvQkFBb0I7a0JBSmhDLElBQUk7bUJBQUM7b0JBQ0YsSUFBSSxFQUFFLGtCQUFrQjtvQkFDeEIsSUFBSSxFQUFFLEtBQUs7aUJBQ2Q7OzBCQUVnQixRQUFROzswQkFBK0IsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBPcHRpb25hbCwgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0IHsgTG9jYWxlQmFzZVBpcGUgfSBmcm9tICcuL2xvY2FsZS1iYXNlLnBpcGUnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEaXNwbGF5cyBhIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIGEgZ2l2ZW4gcmVnaW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBIVE1MXHJcbiAqIHt7ICdHQicgfCBsb2NhbGVSZWdpb25OYW1lIH19XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZG9jc0NhdGVnb3J5IHBpcGVzXHJcbiAqL1xyXG5AUGlwZSh7XHJcbiAgICBuYW1lOiAnbG9jYWxlUmVnaW9uTmFtZScsXHJcbiAgICBwdXJlOiBmYWxzZSxcclxufSlcclxuZXhwb3J0IGNsYXNzIExvY2FsZVJlZ2lvbk5hbWVQaXBlIGV4dGVuZHMgTG9jYWxlQmFzZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGRhdGFTZXJ2aWNlPzogRGF0YVNlcnZpY2UsIEBPcHRpb25hbCgpIGNoYW5nZURldGVjdG9yUmVmPzogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcclxuICAgICAgICBzdXBlcihkYXRhU2VydmljZSwgY2hhbmdlRGV0ZWN0b3JSZWYpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGxvY2FsZT86IHVua25vd24pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCByZWdpb24gY29kZSBcIiR7dmFsdWUgYXMgYW55fVwiYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWN0aXZlTG9jYWxlID0gdGhpcy5nZXRBY3RpdmVMb2NhbGUobG9jYWxlKTtcclxuXHJcbiAgICAgICAgLy8gQXdhaXRpbmcgVFMgdHlwZXMgZm9yIHRoaXMgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC80NDAyMi9maWxlc1xyXG4gICAgICAgIGNvbnN0IERpc3BsYXlOYW1lcyA9IChJbnRsIGFzIGFueSkuRGlzcGxheU5hbWVzO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpc3BsYXlOYW1lcyhbYWN0aXZlTG9jYWxlLnJlcGxhY2UoJ18nLCAnLScpXSwgeyB0eXBlOiAncmVnaW9uJyB9KS5vZihcclxuICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoJ18nLCAnLScpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==