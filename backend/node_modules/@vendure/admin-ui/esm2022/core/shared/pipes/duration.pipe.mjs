import { Pipe } from '@angular/core';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import * as i0 from "@angular/core";
import * as i1 from "../../providers/i18n/i18n.service";
/**
 * @description
 * Displays a number of milliseconds in a more human-readable format,
 * e.g. "12ms", "33s", "2:03m"
 *
 * @example
 * ```ts
 * {{ timeInMs | duration }}
 * ```
 *
 * @docsCategory pipes
 */
export class DurationPipe {
    constructor(i18nService) {
        this.i18nService = i18nService;
    }
    transform(value) {
        if (value < 1000) {
            return this.i18nService.translate(_('datetime.duration-milliseconds'), { ms: value });
        }
        else if (value < 1000 * 60) {
            const seconds1dp = +(value / 1000).toFixed(1);
            return this.i18nService.translate(_('datetime.duration-seconds'), { s: seconds1dp });
        }
        else {
            const minutes = Math.floor(value / (1000 * 60));
            const seconds = Math.round((value % (1000 * 60)) / 1000)
                .toString()
                .padStart(2, '0');
            return this.i18nService.translate(_('datetime.duration-minutes:seconds'), {
                m: minutes,
                s: seconds,
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DurationPipe, deps: [{ token: i1.I18nService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.2", ngImport: i0, type: DurationPipe, name: "duration" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DurationPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'duration',
                }]
        }], ctorParameters: function () { return [{ type: i1.I18nService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHVyYXRpb24ucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL3BpcGVzL2R1cmF0aW9uLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7O0FBSXRFOzs7Ozs7Ozs7OztHQVdHO0FBSUgsTUFBTSxPQUFPLFlBQVk7SUFDckIsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBRyxDQUFDO0lBRWhELFNBQVMsQ0FBQyxLQUFhO1FBQ25CLElBQUksS0FBSyxHQUFHLElBQUksRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGdDQUFnQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUN6RjthQUFNLElBQUksS0FBSyxHQUFHLElBQUksR0FBRyxFQUFFLEVBQUU7WUFDMUIsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsMkJBQTJCLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQ3hGO2FBQU07WUFDSCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7aUJBQ25ELFFBQVEsRUFBRTtpQkFDVixRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDLEVBQUU7Z0JBQ3RFLENBQUMsRUFBRSxPQUFPO2dCQUNWLENBQUMsRUFBRSxPQUFPO2FBQ2IsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDOzhHQW5CUSxZQUFZOzRHQUFaLFlBQVk7OzJGQUFaLFlBQVk7a0JBSHhCLElBQUk7bUJBQUM7b0JBQ0YsSUFBSSxFQUFFLFVBQVU7aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBtYXJrZXIgYXMgXyB9IGZyb20gJ0BiaWVzYmplcmcvbmd4LXRyYW5zbGF0ZS1leHRyYWN0LW1hcmtlcic7XHJcblxyXG5pbXBvcnQgeyBJMThuU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9pMThuL2kxOG4uc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERpc3BsYXlzIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIG1vcmUgaHVtYW4tcmVhZGFibGUgZm9ybWF0LFxyXG4gKiBlLmcuIFwiMTJtc1wiLCBcIjMzc1wiLCBcIjI6MDNtXCJcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICoge3sgdGltZUluTXMgfCBkdXJhdGlvbiB9fVxyXG4gKiBgYGBcclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBwaXBlc1xyXG4gKi9cclxuQFBpcGUoe1xyXG4gICAgbmFtZTogJ2R1cmF0aW9uJyxcclxufSlcclxuZXhwb3J0IGNsYXNzIER1cmF0aW9uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBpMThuU2VydmljZTogSTE4blNlcnZpY2UpIHt9XHJcblxyXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDEwMDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaTE4blNlcnZpY2UudHJhbnNsYXRlKF8oJ2RhdGV0aW1lLmR1cmF0aW9uLW1pbGxpc2Vjb25kcycpLCB7IG1zOiB2YWx1ZSB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMTAwMCAqIDYwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZHMxZHAgPSArKHZhbHVlIC8gMTAwMCkudG9GaXhlZCgxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaTE4blNlcnZpY2UudHJhbnNsYXRlKF8oJ2RhdGV0aW1lLmR1cmF0aW9uLXNlY29uZHMnKSwgeyBzOiBzZWNvbmRzMWRwIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHZhbHVlIC8gKDEwMDAgKiA2MCkpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5yb3VuZCgodmFsdWUgJSAoMTAwMCAqIDYwKSkgLyAxMDAwKVxyXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIC5wYWRTdGFydCgyLCAnMCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pMThuU2VydmljZS50cmFuc2xhdGUoXygnZGF0ZXRpbWUuZHVyYXRpb24tbWludXRlczpzZWNvbmRzJyksIHtcclxuICAgICAgICAgICAgICAgIG06IG1pbnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBzOiBzZWNvbmRzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19