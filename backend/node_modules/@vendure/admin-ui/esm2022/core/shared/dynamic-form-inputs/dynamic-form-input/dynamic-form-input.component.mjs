import { moveItemInArray } from '@angular/cdk/drag-drop';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Injector, Input, ViewChild, ViewChildren, ViewContainerRef, } from '@angular/core';
import { FormArray, NG_VALUE_ACCESSOR, UntypedFormArray, UntypedFormControl, } from '@angular/forms';
import { assertNever, notNullOrUndefined } from '@vendure/common/lib/shared-utils';
import { simpleDeepClone } from '@vendure/common/lib/simple-deep-clone';
import { Subject } from 'rxjs';
import { switchMap, take, takeUntil } from 'rxjs/operators';
import { getConfigArgValue } from '../../../common/utilities/configurable-operation-utils';
import * as i0 from "@angular/core";
import * as i1 from "../../../providers/component-registry/component-registry.service";
import * as i2 from "@clr/angular";
import * as i3 from "@angular/common";
import * as i4 from "@angular/cdk/drag-drop";
import * as i5 from "@ngx-translate/core";
/**
 * A host component which delegates to an instance or list of FormInputComponent components.
 */
export class DynamicFormInputComponent {
    constructor(componentRegistryService, changeDetectorRef, injector) {
        this.componentRegistryService = componentRegistryService;
        this.changeDetectorRef = changeDetectorRef;
        this.injector = injector;
        this.renderAsList = false;
        this.listItems = [];
        this.listId = 1;
        this.listFormArray = new FormArray([]);
        this.componentProviders = [];
        this.renderList$ = new Subject();
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        const componentId = this.getInputComponentConfig(this.def).component;
        const component = this.componentRegistryService.getInputComponent(componentId);
        if (component) {
            this.componentType = component.type;
            this.componentProviders = component.providers;
        }
        else {
            // eslint-disable-next-line no-console
            console.error(`No form input component registered with the id "${componentId}". Using the default input instead.`);
            const defaultComponentType = this.componentRegistryService.getInputComponent(this.getInputComponentConfig({ ...this.def, ui: undefined }).component);
            if (defaultComponentType) {
                this.componentType = defaultComponentType.type;
            }
        }
    }
    ngAfterViewInit() {
        if (this.componentType) {
            const injector = Injector.create({
                providers: this.componentProviders,
                parent: this.injector,
            });
            // create a temp instance to check the value of `isListInput`
            const cmpRef = this.singleViewContainer.createComponent(this.componentType, { injector });
            const isListInputComponent = cmpRef.instance.isListInput ?? false;
            cmpRef.destroy();
            if (this.def.list === false && isListInputComponent) {
                throw new Error(`The ${this.componentType.name} component is a list input, but the definition for ${this.def.name} does not expect a list`);
            }
            this.renderAsList = this.def.list && !isListInputComponent;
            if (!this.renderAsList) {
                this.singleComponentRef = this.renderInputComponent(injector, this.singleViewContainer, this.control);
            }
            else {
                let formArraySub;
                const renderListInputs = (viewContainerRefs) => {
                    if (viewContainerRefs.length) {
                        if (formArraySub) {
                            formArraySub.unsubscribe();
                        }
                        this.listFormArray = new UntypedFormArray([]);
                        this.listItems.forEach(i => i.componentRef?.destroy());
                        viewContainerRefs.forEach((ref, i) => {
                            const listItem = this.listItems?.[i];
                            if (listItem) {
                                this.listFormArray.push(listItem.control);
                                listItem.componentRef = this.renderInputComponent(injector, ref, listItem.control);
                            }
                        });
                        formArraySub = this.listFormArray.valueChanges
                            .pipe(takeUntil(this.destroy$))
                            .subscribe(val => {
                            this.control.markAsTouched();
                            this.control.markAsDirty();
                            const truthyValues = val.filter(notNullOrUndefined);
                            this.onChange(truthyValues);
                            this.control.patchValue(truthyValues, { emitEvent: false });
                        });
                        setTimeout(() => this.changeDetectorRef.markForCheck());
                    }
                };
                // initial render
                this.listItemContainers.changes
                    .pipe(take(1))
                    .subscribe(val => renderListInputs(this.listItemContainers));
                // render on changes to the list
                this.renderList$
                    .pipe(switchMap(() => this.listItemContainers.changes.pipe(take(1))), takeUntil(this.destroy$))
                    .subscribe(() => {
                    renderListInputs(this.listItemContainers);
                });
            }
        }
        setTimeout(() => this.changeDetectorRef.markForCheck());
    }
    ngOnChanges(changes) {
        if (this.listItems) {
            for (const item of this.listItems) {
                if (item.componentRef) {
                    this.updateBindings(changes, item.componentRef);
                }
            }
        }
        if (this.singleComponentRef) {
            this.updateBindings(changes, this.singleComponentRef);
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    updateBindings(changes, componentRef) {
        if ('def' in changes) {
            componentRef.instance.config = simpleDeepClone(this.def);
        }
        if ('readonly' in changes) {
            componentRef.instance.readonly = this.readonly;
        }
        componentRef.injector.get(ChangeDetectorRef).markForCheck();
    }
    trackById(index, item) {
        return item.id;
    }
    addListItem() {
        if (!this.listItems) {
            this.listItems = [];
        }
        this.listItems.push({
            id: this.listId++,
            control: new UntypedFormControl(this.def.defaultValue ?? null),
        });
        this.renderList$.next();
    }
    moveListItem(event) {
        if (this.listItems) {
            moveItemInArray(this.listItems, event.previousIndex, event.currentIndex);
            this.listFormArray.removeAt(event.previousIndex);
            this.listFormArray.insert(event.currentIndex, event.item.data.control);
            this.renderList$.next();
        }
    }
    removeListItem(item) {
        if (this.listItems) {
            const index = this.listItems.findIndex(i => i === item);
            item.componentRef?.destroy();
            this.listFormArray.removeAt(index);
            this.listItems = this.listItems.filter(i => i !== item);
            this.renderList$.next();
        }
    }
    renderInputComponent(injector, viewContainerRef, formControl) {
        const componentRef = viewContainerRef.createComponent(this.componentType, { injector });
        const { instance } = componentRef;
        instance.config = simpleDeepClone(this.def);
        instance.formControl = formControl;
        instance.readonly = this.readonly;
        componentRef.injector.get(ChangeDetectorRef).markForCheck();
        return componentRef;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    writeValue(obj) {
        if (Array.isArray(obj)) {
            if (obj.length === this.listItems.length) {
                obj.forEach((value, index) => {
                    const control = this.listItems[index]?.control;
                    control.patchValue(getConfigArgValue(value), { emitEvent: false });
                });
            }
            else {
                this.listItems = obj.map(value => ({
                    id: this.listId++,
                    control: new UntypedFormControl(getConfigArgValue(value)),
                }));
                this.renderList$.next();
            }
        }
        else {
            this.listItems = [];
            this.renderList$.next();
        }
        this.changeDetectorRef.markForCheck();
    }
    getInputComponentConfig(argDef) {
        if (this.hasUiConfig(argDef) && argDef.ui.component) {
            return argDef.ui;
        }
        const type = argDef?.type;
        switch (type) {
            case 'string':
            case 'localeString': {
                const hasOptions = !!(this.isConfigArgDef(argDef) && argDef.ui?.options) ||
                    !!argDef.options;
                if (hasOptions) {
                    return { component: 'select-form-input' };
                }
                else {
                    return { component: 'text-form-input' };
                }
            }
            case 'text':
            case 'localeText': {
                return { component: 'textarea-form-input' };
            }
            case 'int':
            case 'float':
                return { component: 'number-form-input' };
            case 'boolean':
                return { component: 'boolean-form-input' };
            case 'datetime':
                return { component: 'date-form-input' };
            case 'ID':
                return { component: 'text-form-input' };
            case 'relation':
                return { component: 'relation-form-input' };
            default:
                assertNever(type);
        }
    }
    isConfigArgDef(def) {
        return def?.__typename === 'ConfigArgDefinition';
    }
    hasUiConfig(def) {
        return typeof def === 'object' && typeof def?.ui?.component === 'string';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DynamicFormInputComponent, deps: [{ token: i1.ComponentRegistryService }, { token: i0.ChangeDetectorRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: DynamicFormInputComponent, selector: "vdr-dynamic-form-input", inputs: { def: "def", readonly: "readonly", control: "control" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: DynamicFormInputComponent,
                multi: true,
            },
        ], viewQueries: [{ propertyName: "singleViewContainer", first: true, predicate: ["single"], descendants: true, read: ViewContainerRef }, { propertyName: "listItemContainers", predicate: ["listItem"], descendants: true, read: ViewContainerRef }], usesOnChanges: true, ngImport: i0, template: "<ng-container *ngIf=\"!renderAsList; else list\">\r\n    <ng-container #single></ng-container>\r\n</ng-container>\r\n<ng-template #list>\r\n    <div class=\"list-container\" cdkDropList (cdkDropListDropped)=\"moveListItem($event)\">\r\n        <div\r\n            class=\"list-item-row\"\r\n            *ngFor=\"let item of listItems; trackBy: trackById\"\r\n            cdkDrag\r\n            [cdkDragData]=\"item\"\r\n            [cdkDragLockAxis]=\"'y'\"\r\n        >\r\n            <div class=\"flex-spacer pr-2\">\r\n                <ng-container #listItem></ng-container>\r\n            </div>\r\n            <button\r\n                class=\"button-small\"\r\n                *ngIf=\"!readonly\"\r\n                (click)=\"removeListItem(item)\"\r\n                [title]=\"'common.remove-item-from-list' | translate\"\r\n            >\r\n                <clr-icon shape=\"times\"></clr-icon>\r\n            </button>\r\n            <div class=\"drag-handle\" cdkDragHandle [class.hidden]=\"readonly\">\r\n                <clr-icon shape=\"drag-handle\" size=\"24\"></clr-icon>\r\n            </div>\r\n        </div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"addListItem()\" *ngIf=\"!readonly\">\r\n            <clr-icon shape=\"plus\"></clr-icon> {{ 'common.add-item-to-list' | translate }}\r\n        </button>\r\n    </div>\r\n</ng-template>\r\n", styles: [":host{flex:1}.list-container{border:1px solid var(--color-component-border-200);border-radius:3px;padding:12px}.list-item-row{font-size:13px;display:flex;align-items:center;margin:3px 0}.drag-placeholder{transition:transform .25s cubic-bezier(0,0,.2,1)}.cdk-drag-preview{font-size:13px;background-color:var(--color-component-bg-100);opacity:.8;border-radius:4px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.drag-handle{cursor:move}.drag-handle.hidden{display:none}.cdk-drag-placeholder{opacity:.1}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.cdk-drop-list-dragging .list-item-row:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"], dependencies: [{ kind: "directive", type: i2.ClrDatagridItemsTrackBy, selector: "[ngForTrackBy]", inputs: ["ngForTrackBy"] }, { kind: "directive", type: i2.ClrIconCustomTag, selector: "clr-icon" }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i4.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i4.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { kind: "pipe", type: i5.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: DynamicFormInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-dynamic-form-input', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: DynamicFormInputComponent,
                            multi: true,
                        },
                    ], template: "<ng-container *ngIf=\"!renderAsList; else list\">\r\n    <ng-container #single></ng-container>\r\n</ng-container>\r\n<ng-template #list>\r\n    <div class=\"list-container\" cdkDropList (cdkDropListDropped)=\"moveListItem($event)\">\r\n        <div\r\n            class=\"list-item-row\"\r\n            *ngFor=\"let item of listItems; trackBy: trackById\"\r\n            cdkDrag\r\n            [cdkDragData]=\"item\"\r\n            [cdkDragLockAxis]=\"'y'\"\r\n        >\r\n            <div class=\"flex-spacer pr-2\">\r\n                <ng-container #listItem></ng-container>\r\n            </div>\r\n            <button\r\n                class=\"button-small\"\r\n                *ngIf=\"!readonly\"\r\n                (click)=\"removeListItem(item)\"\r\n                [title]=\"'common.remove-item-from-list' | translate\"\r\n            >\r\n                <clr-icon shape=\"times\"></clr-icon>\r\n            </button>\r\n            <div class=\"drag-handle\" cdkDragHandle [class.hidden]=\"readonly\">\r\n                <clr-icon shape=\"drag-handle\" size=\"24\"></clr-icon>\r\n            </div>\r\n        </div>\r\n        <button class=\"btn btn-secondary btn-sm\" (click)=\"addListItem()\" *ngIf=\"!readonly\">\r\n            <clr-icon shape=\"plus\"></clr-icon> {{ 'common.add-item-to-list' | translate }}\r\n        </button>\r\n    </div>\r\n</ng-template>\r\n", styles: [":host{flex:1}.list-container{border:1px solid var(--color-component-border-200);border-radius:3px;padding:12px}.list-item-row{font-size:13px;display:flex;align-items:center;margin:3px 0}.drag-placeholder{transition:transform .25s cubic-bezier(0,0,.2,1)}.cdk-drag-preview{font-size:13px;background-color:var(--color-component-bg-100);opacity:.8;border-radius:4px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.drag-handle{cursor:move}.drag-handle.hidden{display:none}.cdk-drag-placeholder{opacity:.1}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.cdk-drop-list-dragging .list-item-row:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.ComponentRegistryService }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }]; }, propDecorators: { def: [{
                type: Input
            }], readonly: [{
                type: Input
            }], control: [{
                type: Input
            }], singleViewContainer: [{
                type: ViewChild,
                args: ['single', { read: ViewContainerRef }]
            }], listItemContainers: [{
                type: ViewChildren,
                args: ['listItem', { read: ViewContainerRef }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1mb3JtLWlucHV0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL2R5bmFtaWMtZm9ybS1pbnB1dHMvZHluYW1pYy1mb3JtLWlucHV0L2R5bmFtaWMtZm9ybS1pbnB1dC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9keW5hbWljLWZvcm0taW5wdXRzL2R5bmFtaWMtZm9ybS1pbnB1dC9keW5hbWljLWZvcm0taW5wdXQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFlLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RFLE9BQU8sRUFFSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFFVCxRQUFRLEVBQ1IsS0FBSyxFQVFMLFNBQVMsRUFDVCxZQUFZLEVBQ1osZ0JBQWdCLEdBQ25CLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFFSCxTQUFTLEVBRVQsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQixrQkFBa0IsR0FDckIsTUFBTSxnQkFBZ0IsQ0FBQztBQUd4QixPQUFPLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDbkYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSTVELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHdEQUF3RCxDQUFDOzs7Ozs7O0FBUzNGOztHQUVHO0FBY0gsTUFBTSxPQUFPLHlCQUF5QjtJQW9CbEMsWUFDWSx3QkFBa0QsRUFDbEQsaUJBQW9D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SztnQkFDRyxPQUFPO3NCQUFmLEtBQUs7Z0JBQzJDLG1CQUFtQjtzQkFBbkUsU0FBUzt1QkFBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBQ08sa0JBQWtCO3NCQUF2RSxZQUFZO3VCQUFDLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxnQkFBZ0IsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENka0RyYWdEcm9wLCBtb3ZlSXRlbUluQXJyYXkgfSBmcm9tICdAYW5ndWxhci9jZGsvZHJhZy1kcm9wJztcclxuaW1wb3J0IHtcclxuICAgIEFmdGVyVmlld0luaXQsXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICAgIENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgQ29tcG9uZW50LFxyXG4gICAgQ29tcG9uZW50UmVmLFxyXG4gICAgSW5qZWN0b3IsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIE9uSW5pdCxcclxuICAgIFByb3ZpZGVyLFxyXG4gICAgUXVlcnlMaXN0LFxyXG4gICAgU2ltcGxlQ2hhbmdlcyxcclxuICAgIFR5cGUsXHJcbiAgICBWaWV3Q2hpbGQsXHJcbiAgICBWaWV3Q2hpbGRyZW4sXHJcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gICAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXHJcbiAgICBGb3JtQXJyYXksXHJcbiAgICBGb3JtQ29udHJvbCxcclxuICAgIE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgVW50eXBlZEZvcm1BcnJheSxcclxuICAgIFVudHlwZWRGb3JtQ29udHJvbCxcclxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IFN0cmluZ0N1c3RvbUZpZWxkQ29uZmlnIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9nZW5lcmF0ZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyBDb25maWdBcmdUeXBlLCBDdXN0b21GaWVsZFR5cGUsIERlZmF1bHRGb3JtQ29tcG9uZW50SWQgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC10eXBlcyc7XHJcbmltcG9ydCB7IGFzc2VydE5ldmVyLCBub3ROdWxsT3JVbmRlZmluZWQgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC11dGlscyc7XHJcbmltcG9ydCB7IHNpbXBsZURlZXBDbG9uZSB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2ltcGxlLWRlZXAtY2xvbmUnO1xyXG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBGb3JtSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vY29tcG9uZW50LXJlZ2lzdHJ5LXR5cGVzJztcclxuaW1wb3J0IHsgQ29uZmlnQXJnRGVmaW5pdGlvbiwgQ3VzdG9tRmllbGRDb25maWcgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgZ2V0Q29uZmlnQXJnVmFsdWUgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vdXRpbGl0aWVzL2NvbmZpZ3VyYWJsZS1vcGVyYXRpb24tdXRpbHMnO1xyXG5pbXBvcnQgeyBDb21wb25lbnRSZWdpc3RyeVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlcnMvY29tcG9uZW50LXJlZ2lzdHJ5L2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcclxuXHJcbnR5cGUgSW5wdXRMaXN0SXRlbSA9IHtcclxuICAgIGlkOiBudW1iZXI7XHJcbiAgICBjb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8Rm9ybUlucHV0Q29tcG9uZW50PjtcclxuICAgIGNvbnRyb2w6IFVudHlwZWRGb3JtQ29udHJvbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhvc3QgY29tcG9uZW50IHdoaWNoIGRlbGVnYXRlcyB0byBhbiBpbnN0YW5jZSBvciBsaXN0IG9mIEZvcm1JbnB1dENvbXBvbmVudCBjb21wb25lbnRzLlxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1keW5hbWljLWZvcm0taW5wdXQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL2R5bmFtaWMtZm9ybS1pbnB1dC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9keW5hbWljLWZvcm0taW5wdXQuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IER5bmFtaWNGb3JtSW5wdXRDb21wb25lbnQsXHJcbiAgICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRHluYW1pY0Zvcm1JbnB1dENvbXBvbmVudFxyXG4gICAgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvclxyXG57XHJcbiAgICBASW5wdXQoKSBkZWY6IENvbmZpZ0FyZ0RlZmluaXRpb24gfCBDdXN0b21GaWVsZENvbmZpZztcclxuICAgIEBJbnB1dCgpIHJlYWRvbmx5OiBib29sZWFuO1xyXG4gICAgQElucHV0KCkgY29udHJvbDogVW50eXBlZEZvcm1Db250cm9sO1xyXG4gICAgQFZpZXdDaGlsZCgnc2luZ2xlJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pIHNpbmdsZVZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWY7XHJcbiAgICBAVmlld0NoaWxkcmVuKCdsaXN0SXRlbScsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KSBsaXN0SXRlbUNvbnRhaW5lcnM6IFF1ZXJ5TGlzdDxWaWV3Q29udGFpbmVyUmVmPjtcclxuICAgIHJlbmRlckFzTGlzdCA9IGZhbHNlO1xyXG4gICAgbGlzdEl0ZW1zOiBJbnB1dExpc3RJdGVtW10gPSBbXTtcclxuICAgIHByaXZhdGUgc2luZ2xlQ29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8Rm9ybUlucHV0Q29tcG9uZW50PjtcclxuICAgIHByaXZhdGUgbGlzdElkID0gMTtcclxuICAgIHByaXZhdGUgbGlzdEZvcm1BcnJheSA9IG5ldyBGb3JtQXJyYXkoW10gYXMgQXJyYXk8Rm9ybUNvbnRyb2w8YW55Pj4pO1xyXG4gICAgcHJpdmF0ZSBjb21wb25lbnRUeXBlOiBUeXBlPEZvcm1JbnB1dENvbXBvbmVudD47XHJcbiAgICBwcml2YXRlIGNvbXBvbmVudFByb3ZpZGVyczogUHJvdmlkZXJbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKHZhbDogYW55KSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBvblRvdWNoOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSByZW5kZXJMaXN0JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGNvbXBvbmVudFJlZ2lzdHJ5U2VydmljZTogQ29tcG9uZW50UmVnaXN0cnlTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgKSB7fVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudElkID0gdGhpcy5nZXRJbnB1dENvbXBvbmVudENvbmZpZyh0aGlzLmRlZikuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50UmVnaXN0cnlTZXJ2aWNlLmdldElucHV0Q29tcG9uZW50KGNvbXBvbmVudElkKTtcclxuICAgICAgICBpZiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudC50eXBlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFByb3ZpZGVycyA9IGNvbXBvbmVudC5wcm92aWRlcnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgICAgIGBObyBmb3JtIGlucHV0IGNvbXBvbmVudCByZWdpc3RlcmVkIHdpdGggdGhlIGlkIFwiJHtjb21wb25lbnRJZH1cIi4gVXNpbmcgdGhlIGRlZmF1bHQgaW5wdXQgaW5zdGVhZC5gLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29tcG9uZW50VHlwZSA9IHRoaXMuY29tcG9uZW50UmVnaXN0cnlTZXJ2aWNlLmdldElucHV0Q29tcG9uZW50KFxyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbnB1dENvbXBvbmVudENvbmZpZyh7IC4uLnRoaXMuZGVmLCB1aTogdW5kZWZpbmVkIH0gYXMgYW55KS5jb21wb25lbnQsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0Q29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gZGVmYXVsdENvbXBvbmVudFR5cGUudHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IHRoaXMuY29tcG9uZW50UHJvdmlkZXJzLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLmluamVjdG9yLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXAgaW5zdGFuY2UgdG8gY2hlY2sgdGhlIHZhbHVlIG9mIGBpc0xpc3RJbnB1dGBcclxuICAgICAgICAgICAgY29uc3QgY21wUmVmID0gdGhpcy5zaW5nbGVWaWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudCh0aGlzLmNvbXBvbmVudFR5cGUsIHsgaW5qZWN0b3IgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTGlzdElucHV0Q29tcG9uZW50ID0gY21wUmVmLmluc3RhbmNlLmlzTGlzdElucHV0ID8/IGZhbHNlO1xyXG4gICAgICAgICAgICBjbXBSZWYuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmLmxpc3QgPT09IGZhbHNlICYmIGlzTGlzdElucHV0Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgYFRoZSAke3RoaXMuY29tcG9uZW50VHlwZS5uYW1lfSBjb21wb25lbnQgaXMgYSBsaXN0IGlucHV0LCBidXQgdGhlIGRlZmluaXRpb24gZm9yICR7dGhpcy5kZWYubmFtZX0gZG9lcyBub3QgZXhwZWN0IGEgbGlzdGAsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQXNMaXN0ID0gdGhpcy5kZWYubGlzdCAmJiAhaXNMaXN0SW5wdXRDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZW5kZXJBc0xpc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xlQ29tcG9uZW50UmVmID0gdGhpcy5yZW5kZXJJbnB1dENvbXBvbmVudChcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RvcixcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpbmdsZVZpZXdDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBmb3JtQXJyYXlTdWI6IFN1YnNjcmlwdGlvbiB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlckxpc3RJbnB1dHMgPSAodmlld0NvbnRhaW5lclJlZnM6IFF1ZXJ5TGlzdDxWaWV3Q29udGFpbmVyUmVmPikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3Q29udGFpbmVyUmVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1BcnJheVN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUFycmF5U3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Rm9ybUFycmF5ID0gbmV3IFVudHlwZWRGb3JtQXJyYXkoW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RJdGVtcy5mb3JFYWNoKGkgPT4gaS5jb21wb25lbnRSZWY/LmRlc3Ryb3koKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXJSZWZzLmZvckVhY2goKHJlZiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSB0aGlzLmxpc3RJdGVtcz8uW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Rm9ybUFycmF5LnB1c2gobGlzdEl0ZW0uY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0uY29tcG9uZW50UmVmID0gdGhpcy5yZW5kZXJJbnB1dENvbXBvbmVudChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0uY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1BcnJheVN1YiA9IHRoaXMubGlzdEZvcm1BcnJheS52YWx1ZUNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wubWFya0FzVG91Y2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5tYXJrQXNEaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRydXRoeVZhbHVlcyA9IHZhbC5maWx0ZXIobm90TnVsbE9yVW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRydXRoeVZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLnBhdGNoVmFsdWUodHJ1dGh5VmFsdWVzLCB7IGVtaXRFdmVudDogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RJdGVtQ29udGFpbmVycy5jaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUodGFrZSgxKSlcclxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHZhbCA9PiByZW5kZXJMaXN0SW5wdXRzKHRoaXMubGlzdEl0ZW1Db250YWluZXJzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIG9uIGNoYW5nZXMgdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCRcclxuICAgICAgICAgICAgICAgICAgICAucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMubGlzdEl0ZW1Db250YWluZXJzLmNoYW5nZXMucGlwZSh0YWtlKDEpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSxcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxpc3RJbnB1dHModGhpcy5saXN0SXRlbUNvbnRhaW5lcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RJdGVtcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5saXN0SXRlbXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbXBvbmVudFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQmluZGluZ3MoY2hhbmdlcywgaXRlbS5jb21wb25lbnRSZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZUNvbXBvbmVudFJlZikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJpbmRpbmdzKGNoYW5nZXMsIHRoaXMuc2luZ2xlQ29tcG9uZW50UmVmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlQmluZGluZ3MoY2hhbmdlczogU2ltcGxlQ2hhbmdlcywgY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8Rm9ybUlucHV0Q29tcG9uZW50Pikge1xyXG4gICAgICAgIGlmICgnZGVmJyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZi5pbnN0YW5jZS5jb25maWcgPSBzaW1wbGVEZWVwQ2xvbmUodGhpcy5kZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJ3JlYWRvbmx5JyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZi5pbnN0YW5jZS5yZWFkb25seSA9IHRoaXMucmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFJlZi5pbmplY3Rvci5nZXQoQ2hhbmdlRGV0ZWN0b3JSZWYpLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYWNrQnlJZChpbmRleDogbnVtYmVyLCBpdGVtOiB7IGlkOiBudW1iZXIgfSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZExpc3RJdGVtKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5saXN0SXRlbXMpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0SXRlbXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0SXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgIGlkOiB0aGlzLmxpc3RJZCsrLFxyXG4gICAgICAgICAgICBjb250cm9sOiBuZXcgVW50eXBlZEZvcm1Db250cm9sKCh0aGlzLmRlZiBhcyBDb25maWdBcmdEZWZpbml0aW9uKS5kZWZhdWx0VmFsdWUgPz8gbnVsbCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0JC5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZUxpc3RJdGVtKGV2ZW50OiBDZGtEcmFnRHJvcDxJbnB1dExpc3RJdGVtPikge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RJdGVtcykge1xyXG4gICAgICAgICAgICBtb3ZlSXRlbUluQXJyYXkodGhpcy5saXN0SXRlbXMsIGV2ZW50LnByZXZpb3VzSW5kZXgsIGV2ZW50LmN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdEZvcm1BcnJheS5yZW1vdmVBdChldmVudC5wcmV2aW91c0luZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5saXN0Rm9ybUFycmF5Lmluc2VydChldmVudC5jdXJyZW50SW5kZXgsIGV2ZW50Lml0ZW0uZGF0YS5jb250cm9sKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0JC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUxpc3RJdGVtKGl0ZW06IElucHV0TGlzdEl0ZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0SXRlbXMpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmxpc3RJdGVtcy5maW5kSW5kZXgoaSA9PiBpID09PSBpdGVtKTtcclxuICAgICAgICAgICAgaXRlbS5jb21wb25lbnRSZWY/LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5saXN0Rm9ybUFycmF5LnJlbW92ZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5saXN0SXRlbXMgPSB0aGlzLmxpc3RJdGVtcy5maWx0ZXIoaSA9PiBpICE9PSBpdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0JC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVySW5wdXRDb21wb25lbnQoXHJcbiAgICAgICAgaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgICAgIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgZm9ybUNvbnRyb2w6IFVudHlwZWRGb3JtQ29udHJvbCxcclxuICAgICkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IHZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50VHlwZSwgeyBpbmplY3RvciB9KTtcclxuICAgICAgICBjb25zdCB7IGluc3RhbmNlIH0gPSBjb21wb25lbnRSZWY7XHJcbiAgICAgICAgaW5zdGFuY2UuY29uZmlnID0gc2ltcGxlRGVlcENsb25lKHRoaXMuZGVmKTtcclxuICAgICAgICBpbnN0YW5jZS5mb3JtQ29udHJvbCA9IGZvcm1Db250cm9sO1xyXG4gICAgICAgIGluc3RhbmNlLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seTtcclxuICAgICAgICBjb21wb25lbnRSZWYuaW5qZWN0b3IuZ2V0KENoYW5nZURldGVjdG9yUmVmKS5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vblRvdWNoID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IHRoaXMubGlzdEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgb2JqLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLmxpc3RJdGVtc1tpbmRleF0/LmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5wYXRjaFZhbHVlKGdldENvbmZpZ0FyZ1ZhbHVlKHZhbHVlKSwgeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RJdGVtcyA9IG9iai5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmxpc3RJZCsrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogbmV3IFVudHlwZWRGb3JtQ29udHJvbChnZXRDb25maWdBcmdWYWx1ZSh2YWx1ZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGFzIElucHV0TGlzdEl0ZW0pLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCQubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0SXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0JC5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRJbnB1dENvbXBvbmVudENvbmZpZyhhcmdEZWY6IENvbmZpZ0FyZ0RlZmluaXRpb24gfCBDdXN0b21GaWVsZENvbmZpZyk6IHtcclxuICAgICAgICBjb21wb25lbnQ6IERlZmF1bHRGb3JtQ29tcG9uZW50SWQ7XHJcbiAgICB9IHtcclxuICAgICAgICBpZiAodGhpcy5oYXNVaUNvbmZpZyhhcmdEZWYpICYmIGFyZ0RlZi51aS5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ0RlZi51aTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGFyZ0RlZj8udHlwZSBhcyBDb25maWdBcmdUeXBlIHwgQ3VzdG9tRmllbGRUeXBlO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICBjYXNlICdsb2NhbGVTdHJpbmcnOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNPcHRpb25zID1cclxuICAgICAgICAgICAgICAgICAgICAhISh0aGlzLmlzQ29uZmlnQXJnRGVmKGFyZ0RlZikgJiYgYXJnRGVmLnVpPy5vcHRpb25zKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICEhKGFyZ0RlZiBhcyBTdHJpbmdDdXN0b21GaWVsZENvbmZpZykub3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiAnc2VsZWN0LWZvcm0taW5wdXQnIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogJ3RleHQtZm9ybS1pbnB1dCcgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgY2FzZSAnbG9jYWxlVGV4dCc6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogJ3RleHRhcmVhLWZvcm0taW5wdXQnIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnaW50JzpcclxuICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiAnbnVtYmVyLWZvcm0taW5wdXQnIH07XHJcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiAnYm9vbGVhbi1mb3JtLWlucHV0JyB9O1xyXG4gICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnQ6ICdkYXRlLWZvcm0taW5wdXQnIH07XHJcbiAgICAgICAgICAgIGNhc2UgJ0lEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogJ3RleHQtZm9ybS1pbnB1dCcgfTtcclxuICAgICAgICAgICAgY2FzZSAncmVsYXRpb24nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiAncmVsYXRpb24tZm9ybS1pbnB1dCcgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzQ29uZmlnQXJnRGVmKGRlZjogQ29uZmlnQXJnRGVmaW5pdGlvbiB8IEN1c3RvbUZpZWxkQ29uZmlnKTogZGVmIGlzIENvbmZpZ0FyZ0RlZmluaXRpb24ge1xyXG4gICAgICAgIHJldHVybiAoZGVmIGFzIENvbmZpZ0FyZ0RlZmluaXRpb24pPy5fX3R5cGVuYW1lID09PSAnQ29uZmlnQXJnRGVmaW5pdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYXNVaUNvbmZpZyhkZWY6IHVua25vd24pOiBkZWYgaXMgeyB1aTogeyBjb21wb25lbnQ6IHN0cmluZyB9IH0ge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgKGRlZiBhcyBhbnkpPy51aT8uY29tcG9uZW50ID09PSAnc3RyaW5nJztcclxuICAgIH1cclxufVxyXG4iLCI8bmctY29udGFpbmVyICpuZ0lmPVwiIXJlbmRlckFzTGlzdDsgZWxzZSBsaXN0XCI+XHJcbiAgICA8bmctY29udGFpbmVyICNzaW5nbGU+PC9uZy1jb250YWluZXI+XHJcbjwvbmctY29udGFpbmVyPlxyXG48bmctdGVtcGxhdGUgI2xpc3Q+XHJcbiAgICA8ZGl2IGNsYXNzPVwibGlzdC1jb250YWluZXJcIiBjZGtEcm9wTGlzdCAoY2RrRHJvcExpc3REcm9wcGVkKT1cIm1vdmVMaXN0SXRlbSgkZXZlbnQpXCI+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBjbGFzcz1cImxpc3QtaXRlbS1yb3dcIlxyXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBsaXN0SXRlbXM7IHRyYWNrQnk6IHRyYWNrQnlJZFwiXHJcbiAgICAgICAgICAgIGNka0RyYWdcclxuICAgICAgICAgICAgW2Nka0RyYWdEYXRhXT1cIml0ZW1cIlxyXG4gICAgICAgICAgICBbY2RrRHJhZ0xvY2tBeGlzXT1cIid5J1wiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleC1zcGFjZXIgcHItMlwiPlxyXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAjbGlzdEl0ZW0+PC9uZy1jb250YWluZXI+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbi1zbWFsbFwiXHJcbiAgICAgICAgICAgICAgICAqbmdJZj1cIiFyZWFkb25seVwiXHJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwicmVtb3ZlTGlzdEl0ZW0oaXRlbSlcIlxyXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cIidjb21tb24ucmVtb3ZlLWl0ZW0tZnJvbS1saXN0JyB8IHRyYW5zbGF0ZVwiXHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInRpbWVzXCI+PC9jbHItaWNvbj5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkcmFnLWhhbmRsZVwiIGNka0RyYWdIYW5kbGUgW2NsYXNzLmhpZGRlbl09XCJyZWFkb25seVwiPlxyXG4gICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZHJhZy1oYW5kbGVcIiBzaXplPVwiMjRcIj48L2Nsci1pY29uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnkgYnRuLXNtXCIgKGNsaWNrKT1cImFkZExpc3RJdGVtKClcIiAqbmdJZj1cIiFyZWFkb25seVwiPlxyXG4gICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJwbHVzXCI+PC9jbHItaWNvbj4ge3sgJ2NvbW1vbi5hZGQtaXRlbS10by1saXN0JyB8IHRyYW5zbGF0ZSB9fVxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbjwvbmctdGVtcGxhdGU+XHJcbiJdfQ==