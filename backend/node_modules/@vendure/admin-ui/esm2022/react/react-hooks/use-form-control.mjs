import { useContext, useEffect, useState } from 'react';
import { HostedComponentContext } from '../directives/react-component-host.directive';
/**
 * @description
 * Provides access to the current FormControl value and a method to update the value.
 *
 * @example
 * ```ts
 * import { useFormControl, ReactFormInputProps } from '\@vendure/admin-ui/react';
 * import React from 'react';
 *
 * export function ReactNumberInput({ readonly }: ReactFormInputProps) {
 *     const { value, setFormValue } = useFormControl();
 *
 *     const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
 *         setFormValue(val);
 *     };
 *     return (
 *         <div>
 *             <input readOnly={readonly} type="number" onChange={handleChange} value={value} />
 *         </div>
 *     );
 * }
 * ```
 *
 * @docsCategory react-hooks
 */
export function useFormControl() {
    const context = useContext(HostedComponentContext);
    if (!context) {
        throw new Error('No HostedComponentContext found');
    }
    if (!isFormInputContext(context)) {
        throw new Error('useFormControl() can only be used in a form input component');
    }
    const { formControl, config } = context;
    const [value, setValue] = useState(formControl.value ?? 0);
    useEffect(() => {
        const subscription = formControl.valueChanges.subscribe(v => {
            setValue(v);
        });
        return () => {
            subscription.unsubscribe();
        };
    }, []);
    function setFormValue(newValue) {
        formControl.setValue(coerceFormValue(newValue, config.type));
        formControl.markAsDirty();
    }
    return { value, setFormValue };
}
function isFormInputContext(context) {
    return context.config && context.formControl;
}
function coerceFormValue(value, type) {
    switch (type) {
        case 'int':
        case 'float':
            return Number(value);
        case 'boolean':
            return Boolean(value);
        default:
            return value;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlLWZvcm0tY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvcmVhY3Qvc3JjL3JlYWN0LWhvb2tzL3VzZS1mb3JtLWNvbnRyb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQ3hELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBR3RGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Qkc7QUFDSCxNQUFNLFVBQVUsY0FBYztJQUMxQixNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQ3REO0lBQ0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQztLQUNsRjtJQUNELE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBQ3hDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7SUFFM0QsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNYLE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3hELFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sR0FBRyxFQUFFO1lBQ1IsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQy9CLENBQUMsQ0FBQztJQUNOLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVQLFNBQVMsWUFBWSxDQUFDLFFBQWE7UUFDL0IsV0FBVyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUF1QixDQUFDLENBQUMsQ0FBQztRQUNoRixXQUFXLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUM7QUFDbkMsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQ3ZCLE9BQW9DO0lBRXBDLE9BQU8sT0FBTyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ2pELENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxLQUFVLEVBQUUsSUFBcUI7SUFDdEQsUUFBUSxJQUFJLEVBQUU7UUFDVixLQUFLLEtBQUssQ0FBQztRQUNYLEtBQUssT0FBTztZQUNSLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pCLEtBQUssU0FBUztZQUNWLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFCO1lBQ0ksT0FBTyxLQUFLLENBQUM7S0FDcEI7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3VzdG9tRmllbGRUeXBlIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtdHlwZXMnO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBIb3N0ZWRDb21wb25lbnRDb250ZXh0IH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9yZWFjdC1jb21wb25lbnQtaG9zdC5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBIb3N0ZWRSZWFjdENvbXBvbmVudENvbnRleHQsIFJlYWN0Rm9ybUlucHV0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBjdXJyZW50IEZvcm1Db250cm9sIHZhbHVlIGFuZCBhIG1ldGhvZCB0byB1cGRhdGUgdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyB1c2VGb3JtQ29udHJvbCwgUmVhY3RGb3JtSW5wdXRQcm9wcyB9IGZyb20gJ1xcQHZlbmR1cmUvYWRtaW4tdWkvcmVhY3QnO1xyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG4gKlxyXG4gKiBleHBvcnQgZnVuY3Rpb24gUmVhY3ROdW1iZXJJbnB1dCh7IHJlYWRvbmx5IH06IFJlYWN0Rm9ybUlucHV0UHJvcHMpIHtcclxuICogICAgIGNvbnN0IHsgdmFsdWUsIHNldEZvcm1WYWx1ZSB9ID0gdXNlRm9ybUNvbnRyb2woKTtcclxuICpcclxuICogICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4gKiAgICAgICAgIHNldEZvcm1WYWx1ZSh2YWwpO1xyXG4gKiAgICAgfTtcclxuICogICAgIHJldHVybiAoXHJcbiAqICAgICAgICAgPGRpdj5cclxuICogICAgICAgICAgICAgPGlucHV0IHJlYWRPbmx5PXtyZWFkb25seX0gdHlwZT1cIm51bWJlclwiIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9IHZhbHVlPXt2YWx1ZX0gLz5cclxuICogICAgICAgICA8L2Rpdj5cclxuICogICAgICk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgcmVhY3QtaG9va3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JtQ29udHJvbCgpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEhvc3RlZENvbXBvbmVudENvbnRleHQpO1xyXG4gICAgaWYgKCFjb250ZXh0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIb3N0ZWRDb21wb25lbnRDb250ZXh0IGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRm9ybUlucHV0Q29udGV4dChjb250ZXh0KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlRm9ybUNvbnRyb2woKSBjYW4gb25seSBiZSB1c2VkIGluIGEgZm9ybSBpbnB1dCBjb21wb25lbnQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZm9ybUNvbnRyb2wsIGNvbmZpZyB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoZm9ybUNvbnRyb2wudmFsdWUgPz8gMCk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBmb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKHYgPT4ge1xyXG4gICAgICAgICAgICBzZXRWYWx1ZSh2KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldEZvcm1WYWx1ZShuZXdWYWx1ZTogYW55KSB7XHJcbiAgICAgICAgZm9ybUNvbnRyb2wuc2V0VmFsdWUoY29lcmNlRm9ybVZhbHVlKG5ld1ZhbHVlLCBjb25maWcudHlwZSBhcyBDdXN0b21GaWVsZFR5cGUpKTtcclxuICAgICAgICBmb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IHZhbHVlLCBzZXRGb3JtVmFsdWUgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGb3JtSW5wdXRDb250ZXh0KFxyXG4gICAgY29udGV4dDogSG9zdGVkUmVhY3RDb21wb25lbnRDb250ZXh0LFxyXG4pOiBjb250ZXh0IGlzIEhvc3RlZFJlYWN0Q29tcG9uZW50Q29udGV4dDxSZWFjdEZvcm1JbnB1dE9wdGlvbnM+IHtcclxuICAgIHJldHVybiBjb250ZXh0LmNvbmZpZyAmJiBjb250ZXh0LmZvcm1Db250cm9sO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2VyY2VGb3JtVmFsdWUodmFsdWU6IGFueSwgdHlwZTogQ3VzdG9tRmllbGRUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICdpbnQnOlxyXG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuIl19