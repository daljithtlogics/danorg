import { DataService } from '@vendure/admin-ui/core';
import { useCallback, useContext, useEffect, useState } from 'react';
import { firstValueFrom } from 'rxjs';
import { tap } from 'rxjs/operators';
import { HostedComponentContext } from '../directives/react-component-host.directive';
/**
 * @description
 * A React hook which provides access to the results of a GraphQL query.
 *
 * @example
 * ```ts
 * import { useQuery } from '\@vendure/admin-ui/react';
 * import { gql } from 'graphql-tag';
 *
 * const GET_PRODUCT = gql`
 *    query GetProduct($id: ID!) {
 *      product(id: $id) {
 *        id
 *        name
 *        description
 *      }
 *    }`;
 *
 * export const MyComponent = () => {
 *     const { data, loading, error } = useQuery(GET_PRODUCT, { id: '1' });
 *
 *     if (loading) return <div>Loading...</div>;
 *     if (error) return <div>Error! { error }</div>;
 *     return (
 *         <div>
 *             <h1>{data.product.name}</h1>
 *             <p>{data.product.description}</p>
 *         </div>
 *     );
 * };
 * ```
 *
 * @docsCategory react-hooks
 */
export function useQuery(query, variables) {
    const { data, loading, error, runQuery } = useDataService((dataService, vars) => dataService.query(query, vars).stream$);
    useEffect(() => {
        const subscription = runQuery(variables).subscribe();
        return () => subscription.unsubscribe();
    }, [runQuery]);
    const refetch = (variables) => firstValueFrom(runQuery(variables));
    return { data, loading, error, refetch };
}
/**
 * @description
 * A React hook which allows you to execute a GraphQL mutation.
 *
 * @example
 * ```ts
 * import { useMutation } from '\@vendure/admin-ui/react';
 * import { gql } from 'graphql-tag';
 *
 * const UPDATE_PRODUCT = gql`
 *   mutation UpdateProduct($input: UpdateProductInput!) {
 *     updateProduct(input: $input) {
 *     id
 *     name
 *   }
 * }`;
 *
 * export const MyComponent = () => {
 *     const [updateProduct, { data, loading, error }] = useMutation(UPDATE_PRODUCT);
 *
 *     const handleClick = () => {
 *         updateProduct({
 *             input: {
 *                 id: '1',
 *                 name: 'New name',
 *             },
 *         }).then(result => {
 *             // do something with the result
 *         });
 *     };
 *
 *     if (loading) return <div>Loading...</div>;
 *     if (error) return <div>Error! { error }</div>;
 *
 *     return (
 *     <div>
 *         <button onClick={handleClick}>Update product</button>
 *         {data && <div>Product updated!</div>}
 *     </div>
 *     );
 * };
 * ```
 *
 * @docsCategory react-hooks
 */
export function useMutation(mutation) {
    const { data, loading, error, runQuery } = useDataService((dataService, variables) => dataService.mutate(mutation, variables));
    const rest = { data, loading, error };
    const execute = (variables) => firstValueFrom(runQuery(variables));
    return [execute, rest];
}
function useDataService(operation) {
    const context = useContext(HostedComponentContext);
    const dataService = context?.injector.get(DataService);
    if (!dataService) {
        throw new Error('No DataService found in HostedComponentContext');
    }
    const [data, setData] = useState();
    const [error, setError] = useState();
    const [loading, setLoading] = useState(false);
    const runQuery = useCallback((variables) => {
        setLoading(true);
        return operation(dataService, variables).pipe(tap({
            next: res => {
                setData(res);
                setLoading(false);
            },
            error: err => {
                setError(err.message);
                setLoading(false);
            },
        }));
    }, []);
    return { data, loading, error, runQuery };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlLXF1ZXJ5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9yZWFjdC9zcmMvcmVhY3QtaG9va3MvdXNlLXF1ZXJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUVyRCxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxjQUFjLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBRXRGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQ0c7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUNwQixLQUE2QyxFQUM3QyxTQUFhO0lBRWIsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxHQUFHLGNBQWMsQ0FDckQsQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQ2hFLENBQUM7SUFDRixTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ1gsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JELE9BQU8sR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzVDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFFZixNQUFNLE9BQU8sR0FBRyxDQUFDLFNBQWEsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQVcsQ0FBQztBQUN0RCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNENHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FDdkIsUUFBZ0Q7SUFFaEQsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxHQUFHLGNBQWMsQ0FBTyxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUN2RixXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FDMUMsQ0FBQztJQUNGLE1BQU0sSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUN0QyxNQUFNLE9BQU8sR0FBRyxDQUFDLFNBQWEsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFrQyxDQUFDO0FBQzVELENBQUM7QUFFRCxTQUFTLGNBQWMsQ0FDbkIsU0FBcUU7SUFFckUsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDbkQsTUFBTSxXQUFXLEdBQUcsT0FBTyxFQUFFLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDdkQsSUFBSSxDQUFDLFdBQVcsRUFBRTtRQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztLQUNyRTtJQUVELE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEdBQUcsUUFBUSxFQUFLLENBQUM7SUFDdEMsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsR0FBRyxRQUFRLEVBQVUsQ0FBQztJQUM3QyxNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU5QyxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsQ0FBQyxTQUFhLEVBQUUsRUFBRTtRQUMzQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDakIsT0FBTyxTQUFTLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FDekMsR0FBRyxDQUFDO1lBQ0EsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFO2dCQUNSLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDYixVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdEIsQ0FBQztZQUNELEtBQUssRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDVCxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN0QixVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdEIsQ0FBQztTQUNKLENBQUMsQ0FDTCxDQUFDO0lBQ04sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRVAsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxDQUFDO0FBQzlDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlZERvY3VtZW50Tm9kZSB9IGZyb20gJ0BncmFwaHFsLXR5cGVkLWRvY3VtZW50LW5vZGUvY29yZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcbmltcG9ydCB7IERvY3VtZW50Tm9kZSB9IGZyb20gJ2dyYXBocWwvaW5kZXgnO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgZmlyc3RWYWx1ZUZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBIb3N0ZWRDb21wb25lbnRDb250ZXh0IH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9yZWFjdC1jb21wb25lbnQtaG9zdC5kaXJlY3RpdmUnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIFJlYWN0IGhvb2sgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSByZXN1bHRzIG9mIGEgR3JhcGhRTCBxdWVyeS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgdXNlUXVlcnkgfSBmcm9tICdcXEB2ZW5kdXJlL2FkbWluLXVpL3JlYWN0JztcclxuICogaW1wb3J0IHsgZ3FsIH0gZnJvbSAnZ3JhcGhxbC10YWcnO1xyXG4gKlxyXG4gKiBjb25zdCBHRVRfUFJPRFVDVCA9IGdxbGBcclxuICogICAgcXVlcnkgR2V0UHJvZHVjdCgkaWQ6IElEISkge1xyXG4gKiAgICAgIHByb2R1Y3QoaWQ6ICRpZCkge1xyXG4gKiAgICAgICAgaWRcclxuICogICAgICAgIG5hbWVcclxuICogICAgICAgIGRlc2NyaXB0aW9uXHJcbiAqICAgICAgfVxyXG4gKiAgICB9YDtcclxuICpcclxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgICAgY29uc3QgeyBkYXRhLCBsb2FkaW5nLCBlcnJvciB9ID0gdXNlUXVlcnkoR0VUX1BST0RVQ1QsIHsgaWQ6ICcxJyB9KTtcclxuICpcclxuICogICAgIGlmIChsb2FkaW5nKSByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xyXG4gKiAgICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvciEgeyBlcnJvciB9PC9kaXY+O1xyXG4gKiAgICAgcmV0dXJuIChcclxuICogICAgICAgICA8ZGl2PlxyXG4gKiAgICAgICAgICAgICA8aDE+e2RhdGEucHJvZHVjdC5uYW1lfTwvaDE+XHJcbiAqICAgICAgICAgICAgIDxwPntkYXRhLnByb2R1Y3QuZGVzY3JpcHRpb259PC9wPlxyXG4gKiAgICAgICAgIDwvZGl2PlxyXG4gKiAgICAgKTtcclxuICogfTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgcmVhY3QtaG9va3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeTxULCBWIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4+KFxyXG4gICAgcXVlcnk6IERvY3VtZW50Tm9kZSB8IFR5cGVkRG9jdW1lbnROb2RlPFQsIFY+LFxyXG4gICAgdmFyaWFibGVzPzogVixcclxuKSB7XHJcbiAgICBjb25zdCB7IGRhdGEsIGxvYWRpbmcsIGVycm9yLCBydW5RdWVyeSB9ID0gdXNlRGF0YVNlcnZpY2U8VCwgVj4oXHJcbiAgICAgICAgKGRhdGFTZXJ2aWNlLCB2YXJzKSA9PiBkYXRhU2VydmljZS5xdWVyeShxdWVyeSwgdmFycykuc3RyZWFtJCxcclxuICAgICk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHJ1blF1ZXJ5KHZhcmlhYmxlcykuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfSwgW3J1blF1ZXJ5XSk7XHJcblxyXG4gICAgY29uc3QgcmVmZXRjaCA9ICh2YXJpYWJsZXM/OiBWKSA9PiBmaXJzdFZhbHVlRnJvbShydW5RdWVyeSh2YXJpYWJsZXMpKTtcclxuICAgIHJldHVybiB7IGRhdGEsIGxvYWRpbmcsIGVycm9yLCByZWZldGNoIH0gYXMgY29uc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBSZWFjdCBob29rIHdoaWNoIGFsbG93cyB5b3UgdG8gZXhlY3V0ZSBhIEdyYXBoUUwgbXV0YXRpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IHVzZU11dGF0aW9uIH0gZnJvbSAnXFxAdmVuZHVyZS9hZG1pbi11aS9yZWFjdCc7XHJcbiAqIGltcG9ydCB7IGdxbCB9IGZyb20gJ2dyYXBocWwtdGFnJztcclxuICpcclxuICogY29uc3QgVVBEQVRFX1BST0RVQ1QgPSBncWxgXHJcbiAqICAgbXV0YXRpb24gVXBkYXRlUHJvZHVjdCgkaW5wdXQ6IFVwZGF0ZVByb2R1Y3RJbnB1dCEpIHtcclxuICogICAgIHVwZGF0ZVByb2R1Y3QoaW5wdXQ6ICRpbnB1dCkge1xyXG4gKiAgICAgaWRcclxuICogICAgIG5hbWVcclxuICogICB9XHJcbiAqIH1gO1xyXG4gKlxyXG4gKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAqICAgICBjb25zdCBbdXBkYXRlUHJvZHVjdCwgeyBkYXRhLCBsb2FkaW5nLCBlcnJvciB9XSA9IHVzZU11dGF0aW9uKFVQREFURV9QUk9EVUNUKTtcclxuICpcclxuICogICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xyXG4gKiAgICAgICAgIHVwZGF0ZVByb2R1Y3Qoe1xyXG4gKiAgICAgICAgICAgICBpbnB1dDoge1xyXG4gKiAgICAgICAgICAgICAgICAgaWQ6ICcxJyxcclxuICogICAgICAgICAgICAgICAgIG5hbWU6ICdOZXcgbmFtZScsXHJcbiAqICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgfSkudGhlbihyZXN1bHQgPT4ge1xyXG4gKiAgICAgICAgICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XHJcbiAqICAgICAgICAgfSk7XHJcbiAqICAgICB9O1xyXG4gKlxyXG4gKiAgICAgaWYgKGxvYWRpbmcpIHJldHVybiA8ZGl2PkxvYWRpbmcuLi48L2Rpdj47XHJcbiAqICAgICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PkVycm9yISB7IGVycm9yIH08L2Rpdj47XHJcbiAqXHJcbiAqICAgICByZXR1cm4gKFxyXG4gKiAgICAgPGRpdj5cclxuICogICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfT5VcGRhdGUgcHJvZHVjdDwvYnV0dG9uPlxyXG4gKiAgICAgICAgIHtkYXRhICYmIDxkaXY+UHJvZHVjdCB1cGRhdGVkITwvZGl2Pn1cclxuICogICAgIDwvZGl2PlxyXG4gKiAgICAgKTtcclxuICogfTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgcmVhY3QtaG9va3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNdXRhdGlvbjxULCBWIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4+KFxyXG4gICAgbXV0YXRpb246IERvY3VtZW50Tm9kZSB8IFR5cGVkRG9jdW1lbnROb2RlPFQsIFY+LFxyXG4pIHtcclxuICAgIGNvbnN0IHsgZGF0YSwgbG9hZGluZywgZXJyb3IsIHJ1blF1ZXJ5IH0gPSB1c2VEYXRhU2VydmljZTxULCBWPigoZGF0YVNlcnZpY2UsIHZhcmlhYmxlcykgPT5cclxuICAgICAgICBkYXRhU2VydmljZS5tdXRhdGUobXV0YXRpb24sIHZhcmlhYmxlcyksXHJcbiAgICApO1xyXG4gICAgY29uc3QgcmVzdCA9IHsgZGF0YSwgbG9hZGluZywgZXJyb3IgfTtcclxuICAgIGNvbnN0IGV4ZWN1dGUgPSAodmFyaWFibGVzPzogVikgPT4gZmlyc3RWYWx1ZUZyb20ocnVuUXVlcnkodmFyaWFibGVzKSk7XHJcbiAgICByZXR1cm4gW2V4ZWN1dGUsIHJlc3RdIGFzIFt0eXBlb2YgZXhlY3V0ZSwgdHlwZW9mIHJlc3RdO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1c2VEYXRhU2VydmljZTxULCBWIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4+KFxyXG4gICAgb3BlcmF0aW9uOiAoZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlLCB2YXJpYWJsZXM/OiBWKSA9PiBPYnNlcnZhYmxlPFQ+LFxyXG4pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEhvc3RlZENvbXBvbmVudENvbnRleHQpO1xyXG4gICAgY29uc3QgZGF0YVNlcnZpY2UgPSBjb250ZXh0Py5pbmplY3Rvci5nZXQoRGF0YVNlcnZpY2UpO1xyXG4gICAgaWYgKCFkYXRhU2VydmljZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gRGF0YVNlcnZpY2UgZm91bmQgaW4gSG9zdGVkQ29tcG9uZW50Q29udGV4dCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlPFQ+KCk7XHJcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZz4oKTtcclxuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBydW5RdWVyeSA9IHVzZUNhbGxiYWNrKCh2YXJpYWJsZXM/OiBWKSA9PiB7XHJcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgICByZXR1cm4gb3BlcmF0aW9uKGRhdGFTZXJ2aWNlLCB2YXJpYWJsZXMpLnBpcGUoXHJcbiAgICAgICAgICAgIHRhcCh7XHJcbiAgICAgICAgICAgICAgICBuZXh0OiByZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERhdGEocmVzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7IGRhdGEsIGxvYWRpbmcsIGVycm9yLCBydW5RdWVyeSB9O1xyXG59XHJcbiJdfQ==