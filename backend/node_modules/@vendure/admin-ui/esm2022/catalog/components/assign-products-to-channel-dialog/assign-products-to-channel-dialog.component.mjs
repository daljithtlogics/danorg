import { ChangeDetectionStrategy, Component } from '@angular/core';
import { UntypedFormControl } from '@angular/forms';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { LogicalOperator, } from '@vendure/admin-ui/core';
import { combineLatest, from, lastValueFrom } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@vendure/admin-ui/core";
import * as i2 from "@clr/angular";
import * as i3 from "@angular/common";
import * as i4 from "@angular/forms";
import * as i5 from "@ngx-translate/core";
export class AssignProductsToChannelDialogComponent {
    get isProductVariantMode() {
        return this.productVariantIds != null;
    }
    constructor(dataService, notificationService) {
        this.dataService = dataService;
        this.notificationService = notificationService;
        this.priceFactorControl = new UntypedFormControl(1);
        this.selectedChannelIdControl = new UntypedFormControl();
    }
    ngOnInit() {
        const activeChannelId$ = this.dataService.client
            .userStatus()
            .mapSingle(({ userStatus }) => userStatus.activeChannelId);
        const allChannels$ = this.dataService.settings.getChannels().mapSingle(data => data.channels);
        combineLatest(activeChannelId$, allChannels$).subscribe(([activeChannelId, channels]) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.currentChannel = channels.items.find(c => c.id === activeChannelId);
            this.availableChannels = channels.items;
        });
        this.selectedChannelIdControl.valueChanges.subscribe(ids => {
            this.selectChannel(ids);
        });
        this.variantsPreview$ = combineLatest(from(this.getTopVariants(10)), this.priceFactorControl.valueChanges.pipe(startWith(1))).pipe(map(([variants, factor]) => variants.map(v => ({
            id: v.id,
            name: v.name,
            price: v.price,
            pricePreview: v.price * +factor,
        }))));
    }
    selectChannel(channelIds) {
        this.selectedChannel = this.availableChannels.find(c => c.id === channelIds[0]);
    }
    assign() {
        const selectedChannel = this.selectedChannel;
        if (selectedChannel) {
            if (!this.isProductVariantMode) {
                this.dataService.product
                    .assignProductsToChannel({
                    channelId: selectedChannel.id,
                    productIds: this.productIds,
                    priceFactor: +this.priceFactorControl.value,
                })
                    .subscribe(() => {
                    this.notificationService.success(_('catalog.assign-product-to-channel-success'), {
                        channel: selectedChannel.code,
                        count: this.productIds.length,
                    });
                    this.resolveWith(true);
                });
            }
            else if (this.productVariantIds) {
                this.dataService.product
                    .assignVariantsToChannel({
                    channelId: selectedChannel.id,
                    productVariantIds: this.productVariantIds,
                    priceFactor: +this.priceFactorControl.value,
                })
                    .subscribe(() => {
                    this.notificationService.success(_('catalog.assign-variant-to-channel-success'), {
                        channel: selectedChannel.code,
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        count: this.productVariantIds.length,
                    });
                    this.resolveWith(true);
                });
            }
        }
    }
    cancel() {
        this.resolveWith();
    }
    async getTopVariants(take) {
        return (await lastValueFrom(this.dataService.product.getProductVariants({
            filterOperator: LogicalOperator.OR,
            filter: {
                productId: { in: this.productIds },
                id: { in: this.productVariantIds },
            },
            take,
        }).single$)).productVariants.items;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: AssignProductsToChannelDialogComponent, deps: [{ token: i1.DataService }, { token: i1.NotificationService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: AssignProductsToChannelDialogComponent, selector: "vdr-assign-products-to-channel-dialog", ngImport: i0, template: "<ng-template vdrDialogTitle>\r\n    <ng-container *ngIf=\"isProductVariantMode; else productModeTitle\">{{\r\n        'catalog.assign-variants-to-channel' | translate\r\n    }}</ng-container>\r\n    <ng-template #productModeTitle>{{ 'catalog.assign-products-to-channel' | translate }}</ng-template>\r\n</ng-template>\r\n\r\n<div class=\"flex\">\r\n    <clr-input-container>\r\n        <label>{{ 'common.channel' | translate }}</label>\r\n        <vdr-channel-assignment-control\r\n            clrInput\r\n            [multiple]=\"false\"\r\n            [includeDefaultChannel]=\"false\"\r\n            [disableChannelIds]=\"currentChannelIds\"\r\n            [formControl]=\"selectedChannelIdControl\"\r\n        ></vdr-channel-assignment-control>\r\n    </clr-input-container>\r\n    <div class=\"flex-spacer\"></div>\r\n    <clr-input-container>\r\n        <label>{{ 'catalog.price-conversion-factor' | translate }}</label>\r\n        <input clrInput type=\"number\" min=\"0\" max=\"99999\" [formControl]=\"priceFactorControl\" />\r\n    </clr-input-container>\r\n</div>\r\n\r\n<div class=\"channel-price-preview\">\r\n    <label class=\"clr-control-label\">{{ 'catalog.channel-price-preview' | translate }}</label>\r\n    <table class=\"table\">\r\n        <thead>\r\n            <tr>\r\n                <th>{{ 'common.name' | translate }}</th>\r\n                <th>\r\n                    {{\r\n                        'catalog.price-in-channel'\r\n                            | translate: { channel: currentChannel?.code | channelCodeToLabel | translate }\r\n                    }}\r\n                </th>\r\n                <th>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n                        {{ 'catalog.price-in-channel' | translate: { channel: selectedChannel?.code } }}\r\n                    </ng-template>\r\n                    <ng-template #noSelection>\r\n                        {{ 'catalog.no-channel-selected' | translate }}\r\n                    </ng-template>\r\n                </th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr *ngFor=\"let row of variantsPreview$ | async\">\r\n                <td>{{ row.name }}</td>\r\n                <td>{{ row.price | localeCurrency: currentChannel?.defaultCurrencyCode }}</td>\r\n                <td>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noChannelSelected\">\r\n                        {{ row.pricePreview | localeCurrency: selectedChannel?.defaultCurrencyCode }}\r\n                    </ng-template>\r\n                    <ng-template #noChannelSelected> - </ng-template>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n\r\n<ng-template vdrDialogButtons>\r\n    <button type=\"button\" class=\"btn\" (click)=\"cancel()\">{{ 'common.cancel' | translate }}</button>\r\n    <button type=\"submit\" (click)=\"assign()\" [disabled]=\"!selectedChannel\" class=\"btn btn-primary\">\r\n        <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n            {{ 'catalog.assign-to-named-channel' | translate: { channelCode: selectedChannel?.code } }}\r\n        </ng-template>\r\n        <ng-template #noSelection>\r\n            {{ 'catalog.no-channel-selected' | translate }}\r\n        </ng-template>\r\n    </button>\r\n</ng-template>\r\n", styles: ["vdr-channel-assignment-control{min-width:200px}.channel-price-preview{margin-top:24px}.channel-price-preview table.table{margin-top:6px}\n"], dependencies: [{ kind: "directive", type: i2.ClrLabel, selector: "label", inputs: ["for"] }, { kind: "directive", type: i2.ClrInput, selector: "[clrInput]" }, { kind: "component", type: i2.ClrInputContainer, selector: "clr-input-container" }, { kind: "directive", type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { kind: "directive", type: i4.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i1.FormFieldControlDirective, selector: "input, textarea, select" }, { kind: "directive", type: i1.DialogButtonsDirective, selector: "[vdrDialogButtons]" }, { kind: "directive", type: i1.DialogTitleDirective, selector: "[vdrDialogTitle]" }, { kind: "component", type: i1.ChannelAssignmentControlComponent, selector: "vdr-channel-assignment-control", inputs: ["multiple", "includeDefaultChannel", "disableChannelIds"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i5.TranslatePipe, name: "translate" }, { kind: "pipe", type: i1.ChannelLabelPipe, name: "channelCodeToLabel" }, { kind: "pipe", type: i1.LocaleCurrencyPipe, name: "localeCurrency" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: AssignProductsToChannelDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-assign-products-to-channel-dialog', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template vdrDialogTitle>\r\n    <ng-container *ngIf=\"isProductVariantMode; else productModeTitle\">{{\r\n        'catalog.assign-variants-to-channel' | translate\r\n    }}</ng-container>\r\n    <ng-template #productModeTitle>{{ 'catalog.assign-products-to-channel' | translate }}</ng-template>\r\n</ng-template>\r\n\r\n<div class=\"flex\">\r\n    <clr-input-container>\r\n        <label>{{ 'common.channel' | translate }}</label>\r\n        <vdr-channel-assignment-control\r\n            clrInput\r\n            [multiple]=\"false\"\r\n            [includeDefaultChannel]=\"false\"\r\n            [disableChannelIds]=\"currentChannelIds\"\r\n            [formControl]=\"selectedChannelIdControl\"\r\n        ></vdr-channel-assignment-control>\r\n    </clr-input-container>\r\n    <div class=\"flex-spacer\"></div>\r\n    <clr-input-container>\r\n        <label>{{ 'catalog.price-conversion-factor' | translate }}</label>\r\n        <input clrInput type=\"number\" min=\"0\" max=\"99999\" [formControl]=\"priceFactorControl\" />\r\n    </clr-input-container>\r\n</div>\r\n\r\n<div class=\"channel-price-preview\">\r\n    <label class=\"clr-control-label\">{{ 'catalog.channel-price-preview' | translate }}</label>\r\n    <table class=\"table\">\r\n        <thead>\r\n            <tr>\r\n                <th>{{ 'common.name' | translate }}</th>\r\n                <th>\r\n                    {{\r\n                        'catalog.price-in-channel'\r\n                            | translate: { channel: currentChannel?.code | channelCodeToLabel | translate }\r\n                    }}\r\n                </th>\r\n                <th>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n                        {{ 'catalog.price-in-channel' | translate: { channel: selectedChannel?.code } }}\r\n                    </ng-template>\r\n                    <ng-template #noSelection>\r\n                        {{ 'catalog.no-channel-selected' | translate }}\r\n                    </ng-template>\r\n                </th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr *ngFor=\"let row of variantsPreview$ | async\">\r\n                <td>{{ row.name }}</td>\r\n                <td>{{ row.price | localeCurrency: currentChannel?.defaultCurrencyCode }}</td>\r\n                <td>\r\n                    <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noChannelSelected\">\r\n                        {{ row.pricePreview | localeCurrency: selectedChannel?.defaultCurrencyCode }}\r\n                    </ng-template>\r\n                    <ng-template #noChannelSelected> - </ng-template>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n\r\n<ng-template vdrDialogButtons>\r\n    <button type=\"button\" class=\"btn\" (click)=\"cancel()\">{{ 'common.cancel' | translate }}</button>\r\n    <button type=\"submit\" (click)=\"assign()\" [disabled]=\"!selectedChannel\" class=\"btn btn-primary\">\r\n        <ng-template [ngIf]=\"selectedChannel\" [ngIfElse]=\"noSelection\">\r\n            {{ 'catalog.assign-to-named-channel' | translate: { channelCode: selectedChannel?.code } }}\r\n        </ng-template>\r\n        <ng-template #noSelection>\r\n            {{ 'catalog.no-channel-selected' | translate }}\r\n        </ng-template>\r\n    </button>\r\n</ng-template>\r\n", styles: ["vdr-channel-assignment-control{min-width:200px}.channel-price-preview{margin-top:24px}.channel-price-preview table.table{margin-top:6px}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.DataService }, { type: i1.NotificationService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9hc3NpZ24tcHJvZHVjdHMtdG8tY2hhbm5lbC1kaWFsb2cvYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9hc3NpZ24tcHJvZHVjdHMtdG8tY2hhbm5lbC1kaWFsb2cvYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUN0RSxPQUFPLEVBS0gsZUFBZSxHQUVsQixNQUFNLHdCQUF3QixDQUFDO0FBQ2hDLE9BQU8sRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN0RSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7O0FBVWhELE1BQU0sT0FBTyxzQ0FBc0M7SUFjL0MsSUFBSSxvQkFBb0I7UUFDcEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDO0lBQzFDLENBQUM7SUFFRCxZQUFvQixXQUF3QixFQUFVLG1CQUF3QztRQUExRSxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUFVLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFaOUYsdUJBQWtCLEdBQUcsSUFBSSxr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LEVBQUU7YUFDckM7WUFDRCxJQUFJO1NBQ1AsQ0FBQyxDQUFDLE9BQU8sQ0FDYixDQUNKLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQztJQUM1QixDQUFDOzhHQTVHUSxzQ0FBc0M7a0dBQXRDLHNDQUFzQyw2RUN0Qm5ELHEwR0F5RUE7OzJGRG5EYSxzQ0FBc0M7a0JBTmxELFNBQVM7K0JBQ0ksdUNBQXVDLG1CQUdoQyx1QkFBdUIsQ0FBQyxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFVudHlwZWRGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgbWFya2VyIGFzIF8gfSBmcm9tICdAYmllc2JqZXJnL25neC10cmFuc2xhdGUtZXh0cmFjdC1tYXJrZXInO1xyXG5pbXBvcnQge1xyXG4gICAgRGF0YVNlcnZpY2UsXHJcbiAgICBEaWFsb2csXHJcbiAgICBHZXRDaGFubmVsc1F1ZXJ5LFxyXG4gICAgSXRlbU9mLFxyXG4gICAgTG9naWNhbE9wZXJhdG9yLFxyXG4gICAgTm90aWZpY2F0aW9uU2VydmljZSxcclxufSBmcm9tICdAdmVuZHVyZS9hZG1pbi11aS9jb3JlJztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgZnJvbSwgbGFzdFZhbHVlRnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbnR5cGUgQ2hhbm5lbCA9IEl0ZW1PZjxHZXRDaGFubmVsc1F1ZXJ5LCAnY2hhbm5lbHMnPjtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2ZHItYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9hc3NpZ24tcHJvZHVjdHMtdG8tY2hhbm5lbC1kaWFsb2cuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vYXNzaWduLXByb2R1Y3RzLXRvLWNoYW5uZWwtZGlhbG9nLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIEFzc2lnblByb2R1Y3RzVG9DaGFubmVsRGlhbG9nQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEaWFsb2c8YW55PiB7XHJcbiAgICBzZWxlY3RlZENoYW5uZWw6IENoYW5uZWwgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgY3VycmVudENoYW5uZWw6IENoYW5uZWw7XHJcbiAgICBhdmFpbGFibGVDaGFubmVsczogQ2hhbm5lbFtdO1xyXG4gICAgcmVzb2x2ZVdpdGg6IChyZXN1bHQ/OiBhbnkpID0+IHZvaWQ7XHJcbiAgICB2YXJpYW50c1ByZXZpZXckOiBPYnNlcnZhYmxlPEFycmF5PHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyBwcmljZTogbnVtYmVyOyBwcmljZVByZXZpZXc6IG51bWJlciB9Pj47XHJcbiAgICBwcmljZUZhY3RvckNvbnRyb2wgPSBuZXcgVW50eXBlZEZvcm1Db250cm9sKDEpO1xyXG4gICAgc2VsZWN0ZWRDaGFubmVsSWRDb250cm9sID0gbmV3IFVudHlwZWRGb3JtQ29udHJvbCgpO1xyXG5cclxuICAgIC8vIGFzc2lnbmVkIGJ5IE1vZGFsU2VydmljZS5mcm9tQ29tcG9uZW50KCkgY2FsbFxyXG4gICAgcHJvZHVjdElkczogc3RyaW5nW107XHJcbiAgICBwcm9kdWN0VmFyaWFudElkczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbiAgICBjdXJyZW50Q2hhbm5lbElkczogc3RyaW5nW107XHJcblxyXG4gICAgZ2V0IGlzUHJvZHVjdFZhcmlhbnRNb2RlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2R1Y3RWYXJpYW50SWRzICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsIHByaXZhdGUgbm90aWZpY2F0aW9uU2VydmljZTogTm90aWZpY2F0aW9uU2VydmljZSkge31cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICBjb25zdCBhY3RpdmVDaGFubmVsSWQkID0gdGhpcy5kYXRhU2VydmljZS5jbGllbnRcclxuICAgICAgICAgICAgLnVzZXJTdGF0dXMoKVxyXG4gICAgICAgICAgICAubWFwU2luZ2xlKCh7IHVzZXJTdGF0dXMgfSkgPT4gdXNlclN0YXR1cy5hY3RpdmVDaGFubmVsSWQpO1xyXG4gICAgICAgIGNvbnN0IGFsbENoYW5uZWxzJCA9IHRoaXMuZGF0YVNlcnZpY2Uuc2V0dGluZ3MuZ2V0Q2hhbm5lbHMoKS5tYXBTaW5nbGUoZGF0YSA9PiBkYXRhLmNoYW5uZWxzKTtcclxuXHJcbiAgICAgICAgY29tYmluZUxhdGVzdChhY3RpdmVDaGFubmVsSWQkLCBhbGxDaGFubmVscyQpLnN1YnNjcmliZSgoW2FjdGl2ZUNoYW5uZWxJZCwgY2hhbm5lbHNdKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaGFubmVscy5pdGVtcy5maW5kKGMgPT4gYy5pZCA9PT0gYWN0aXZlQ2hhbm5lbElkKSE7XHJcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlQ2hhbm5lbHMgPSBjaGFubmVscy5pdGVtcztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5uZWxJZENvbnRyb2wudmFsdWVDaGFuZ2VzLnN1YnNjcmliZShpZHMgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdENoYW5uZWwoaWRzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy52YXJpYW50c1ByZXZpZXckID0gY29tYmluZUxhdGVzdChcclxuICAgICAgICAgICAgZnJvbSh0aGlzLmdldFRvcFZhcmlhbnRzKDEwKSksXHJcbiAgICAgICAgICAgIHRoaXMucHJpY2VGYWN0b3JDb250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKHN0YXJ0V2l0aCgxKSksXHJcbiAgICAgICAgKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKFt2YXJpYW50cywgZmFjdG9yXSkgPT5cclxuICAgICAgICAgICAgICAgIHZhcmlhbnRzLm1hcCh2ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHYuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdi5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiB2LnByaWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHByaWNlUHJldmlldzogdi5wcmljZSAqICtmYWN0b3IsXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3RDaGFubmVsKGNoYW5uZWxJZHM6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5uZWwgPSB0aGlzLmF2YWlsYWJsZUNoYW5uZWxzLmZpbmQoYyA9PiBjLmlkID09PSBjaGFubmVsSWRzWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3NpZ24oKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDaGFubmVsID0gdGhpcy5zZWxlY3RlZENoYW5uZWw7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkQ2hhbm5lbCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcm9kdWN0VmFyaWFudE1vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNlcnZpY2UucHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ25Qcm9kdWN0c1RvQ2hhbm5lbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxJZDogc2VsZWN0ZWRDaGFubmVsLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0SWRzOiB0aGlzLnByb2R1Y3RJZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlRmFjdG9yOiArdGhpcy5wcmljZUZhY3RvckNvbnRyb2wudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25TZXJ2aWNlLnN1Y2Nlc3MoXygnY2F0YWxvZy5hc3NpZ24tcHJvZHVjdC10by1jaGFubmVsLXN1Y2Nlc3MnKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogc2VsZWN0ZWRDaGFubmVsLmNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5wcm9kdWN0SWRzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVdpdGgodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9kdWN0VmFyaWFudElkcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnblZhcmlhbnRzVG9DaGFubmVsKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbElkOiBzZWxlY3RlZENoYW5uZWwuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RWYXJpYW50SWRzOiB0aGlzLnByb2R1Y3RWYXJpYW50SWRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZUZhY3RvcjogK3RoaXMucHJpY2VGYWN0b3JDb250cm9sLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uU2VydmljZS5zdWNjZXNzKF8oJ2NhdGFsb2cuYXNzaWduLXZhcmlhbnQtdG8tY2hhbm5lbC1zdWNjZXNzJyksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHNlbGVjdGVkQ2hhbm5lbC5jb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLnByb2R1Y3RWYXJpYW50SWRzIS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVXaXRoKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmVXaXRoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRUb3BWYXJpYW50cyh0YWtlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBhd2FpdCBsYXN0VmFsdWVGcm9tKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0LmdldFByb2R1Y3RWYXJpYW50cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyT3BlcmF0b3I6IExvZ2ljYWxPcGVyYXRvci5PUixcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdElkOiB7IGluOiB0aGlzLnByb2R1Y3RJZHMgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHsgaW46IHRoaXMucHJvZHVjdFZhcmlhbnRJZHMgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2UsXHJcbiAgICAgICAgICAgICAgICB9KS5zaW5nbGUkLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKS5wcm9kdWN0VmFyaWFudHMuaXRlbXM7XHJcbiAgICB9XHJcbn1cclxuIiwiPG5nLXRlbXBsYXRlIHZkckRpYWxvZ1RpdGxlPlxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImlzUHJvZHVjdFZhcmlhbnRNb2RlOyBlbHNlIHByb2R1Y3RNb2RlVGl0bGVcIj57e1xyXG4gICAgICAgICdjYXRhbG9nLmFzc2lnbi12YXJpYW50cy10by1jaGFubmVsJyB8IHRyYW5zbGF0ZVxyXG4gICAgfX08L25nLWNvbnRhaW5lcj5cclxuICAgIDxuZy10ZW1wbGF0ZSAjcHJvZHVjdE1vZGVUaXRsZT57eyAnY2F0YWxvZy5hc3NpZ24tcHJvZHVjdHMtdG8tY2hhbm5lbCcgfCB0cmFuc2xhdGUgfX08L25nLXRlbXBsYXRlPlxyXG48L25nLXRlbXBsYXRlPlxyXG5cclxuPGRpdiBjbGFzcz1cImZsZXhcIj5cclxuICAgIDxjbHItaW5wdXQtY29udGFpbmVyPlxyXG4gICAgICAgIDxsYWJlbD57eyAnY29tbW9uLmNoYW5uZWwnIHwgdHJhbnNsYXRlIH19PC9sYWJlbD5cclxuICAgICAgICA8dmRyLWNoYW5uZWwtYXNzaWdubWVudC1jb250cm9sXHJcbiAgICAgICAgICAgIGNscklucHV0XHJcbiAgICAgICAgICAgIFttdWx0aXBsZV09XCJmYWxzZVwiXHJcbiAgICAgICAgICAgIFtpbmNsdWRlRGVmYXVsdENoYW5uZWxdPVwiZmFsc2VcIlxyXG4gICAgICAgICAgICBbZGlzYWJsZUNoYW5uZWxJZHNdPVwiY3VycmVudENoYW5uZWxJZHNcIlxyXG4gICAgICAgICAgICBbZm9ybUNvbnRyb2xdPVwic2VsZWN0ZWRDaGFubmVsSWRDb250cm9sXCJcclxuICAgICAgICA+PC92ZHItY2hhbm5lbC1hc3NpZ25tZW50LWNvbnRyb2w+XHJcbiAgICA8L2Nsci1pbnB1dC1jb250YWluZXI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmxleC1zcGFjZXJcIj48L2Rpdj5cclxuICAgIDxjbHItaW5wdXQtY29udGFpbmVyPlxyXG4gICAgICAgIDxsYWJlbD57eyAnY2F0YWxvZy5wcmljZS1jb252ZXJzaW9uLWZhY3RvcicgfCB0cmFuc2xhdGUgfX08L2xhYmVsPlxyXG4gICAgICAgIDxpbnB1dCBjbHJJbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPVwiMFwiIG1heD1cIjk5OTk5XCIgW2Zvcm1Db250cm9sXT1cInByaWNlRmFjdG9yQ29udHJvbFwiIC8+XHJcbiAgICA8L2Nsci1pbnB1dC1jb250YWluZXI+XHJcbjwvZGl2PlxyXG5cclxuPGRpdiBjbGFzcz1cImNoYW5uZWwtcHJpY2UtcHJldmlld1wiPlxyXG4gICAgPGxhYmVsIGNsYXNzPVwiY2xyLWNvbnRyb2wtbGFiZWxcIj57eyAnY2F0YWxvZy5jaGFubmVsLXByaWNlLXByZXZpZXcnIHwgdHJhbnNsYXRlIH19PC9sYWJlbD5cclxuICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XHJcbiAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICA8dGg+e3sgJ2NvbW1vbi5uYW1lJyB8IHRyYW5zbGF0ZSB9fTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8dGg+XHJcbiAgICAgICAgICAgICAgICAgICAge3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhdGFsb2cucHJpY2UtaW4tY2hhbm5lbCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdHJhbnNsYXRlOiB7IGNoYW5uZWw6IGN1cnJlbnRDaGFubmVsPy5jb2RlIHwgY2hhbm5lbENvZGVUb0xhYmVsIHwgdHJhbnNsYXRlIH1cclxuICAgICAgICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgICAgPC90aD5cclxuICAgICAgICAgICAgICAgIDx0aD5cclxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2VsZWN0ZWRDaGFubmVsXCIgW25nSWZFbHNlXT1cIm5vU2VsZWN0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7ICdjYXRhbG9nLnByaWNlLWluLWNoYW5uZWwnIHwgdHJhbnNsYXRlOiB7IGNoYW5uZWw6IHNlbGVjdGVkQ2hhbm5lbD8uY29kZSB9IH19XHJcbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI25vU2VsZWN0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7eyAnY2F0YWxvZy5uby1jaGFubmVsLXNlbGVjdGVkJyB8IHRyYW5zbGF0ZSB9fVxyXG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICA8L3RoPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICA8dHIgKm5nRm9yPVwibGV0IHJvdyBvZiB2YXJpYW50c1ByZXZpZXckIHwgYXN5bmNcIj5cclxuICAgICAgICAgICAgICAgIDx0ZD57eyByb3cubmFtZSB9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICA8dGQ+e3sgcm93LnByaWNlIHwgbG9jYWxlQ3VycmVuY3k6IGN1cnJlbnRDaGFubmVsPy5kZWZhdWx0Q3VycmVuY3lDb2RlIH19PC90ZD5cclxuICAgICAgICAgICAgICAgIDx0ZD5cclxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2VsZWN0ZWRDaGFubmVsXCIgW25nSWZFbHNlXT1cIm5vQ2hhbm5lbFNlbGVjdGVkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IHJvdy5wcmljZVByZXZpZXcgfCBsb2NhbGVDdXJyZW5jeTogc2VsZWN0ZWRDaGFubmVsPy5kZWZhdWx0Q3VycmVuY3lDb2RlIH19XHJcbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI25vQ2hhbm5lbFNlbGVjdGVkPiAtIDwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgIDwvdGJvZHk+XHJcbiAgICA8L3RhYmxlPlxyXG48L2Rpdj5cclxuXHJcbjxuZy10ZW1wbGF0ZSB2ZHJEaWFsb2dCdXR0b25zPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG5cIiAoY2xpY2spPVwiY2FuY2VsKClcIj57eyAnY29tbW9uLmNhbmNlbCcgfCB0cmFuc2xhdGUgfX08L2J1dHRvbj5cclxuICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIChjbGljayk9XCJhc3NpZ24oKVwiIFtkaXNhYmxlZF09XCIhc2VsZWN0ZWRDaGFubmVsXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIj5cclxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2VsZWN0ZWRDaGFubmVsXCIgW25nSWZFbHNlXT1cIm5vU2VsZWN0aW9uXCI+XHJcbiAgICAgICAgICAgIHt7ICdjYXRhbG9nLmFzc2lnbi10by1uYW1lZC1jaGFubmVsJyB8IHRyYW5zbGF0ZTogeyBjaGFubmVsQ29kZTogc2VsZWN0ZWRDaGFubmVsPy5jb2RlIH0gfX1cclxuICAgICAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjbm9TZWxlY3Rpb24+XHJcbiAgICAgICAgICAgIHt7ICdjYXRhbG9nLm5vLWNoYW5uZWwtc2VsZWN0ZWQnIHwgdHJhbnNsYXRlIH19XHJcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDwvYnV0dG9uPlxyXG48L25nLXRlbXBsYXRlPlxyXG4iXX0=