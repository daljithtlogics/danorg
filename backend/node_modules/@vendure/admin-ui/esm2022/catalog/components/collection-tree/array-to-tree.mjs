/**
 * Builds a tree from an array of nodes which have a parent.
 * Based on https://stackoverflow.com/a/31247960/772859, modified to preserve ordering.
 */
export function arrayToTree(nodes, currentState, expandedIds = []) {
    const topLevelNodes = [];
    const mappedArr = {};
    const currentStateMap = treeToMap(currentState);
    // First map the nodes of the array to an object -> create a hash table.
    for (const node of nodes) {
        mappedArr[node.id] = { ...node, children: [] };
    }
    for (const id of nodes.map(n => n.id)) {
        if (mappedArr.hasOwnProperty(id)) {
            const mappedElem = mappedArr[id];
            mappedElem.expanded = currentStateMap.get(id)?.expanded ?? expandedIds.includes(id);
            const parent = mappedElem.parent;
            if (!parent) {
                continue;
            }
            // If the element is not at the root level, add it to its parent array of children.
            const parentIsRoot = !mappedArr[parent.id];
            if (!parentIsRoot) {
                if (mappedArr[parent.id]) {
                    mappedArr[parent.id].children.push(mappedElem);
                }
                else {
                    mappedArr[parent.id] = { children: [mappedElem] };
                }
            }
            else {
                topLevelNodes.push(mappedElem);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const rootId = topLevelNodes.length ? topLevelNodes[0].parent.id : undefined;
    return { id: rootId, children: topLevelNodes };
}
/**
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 */
function treeToMap(tree) {
    const nodeMap = new Map();
    function visit(node) {
        nodeMap.set(node.id, node);
        node.children.forEach(visit);
    }
    if (tree) {
        visit(tree);
    }
    return nodeMap;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdG8tdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRyZWUvYXJyYXktdG8tdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUN2QixLQUFVLEVBQ1YsWUFBMEIsRUFDMUIsY0FBd0IsRUFBRTtJQUUxQixNQUFNLGFBQWEsR0FBdUIsRUFBRSxDQUFDO0lBQzdDLE1BQU0sU0FBUyxHQUFrQyxFQUFFLENBQUM7SUFDcEQsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRWhELHdFQUF3RTtJQUN4RSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBSSxJQUFZLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFDO0tBQzNEO0lBRUQsS0FBSyxNQUFNLEVBQUUsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ25DLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUM5QixNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakMsVUFBVSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFFBQVEsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BGLE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDakMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDVCxTQUFTO2FBQ1o7WUFDRCxtRkFBbUY7WUFDbkYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2YsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUN0QixTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQ2xEO3FCQUFNO29CQUNILFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBUyxDQUFDO2lCQUM1RDthQUNKO2lCQUFNO2dCQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDbEM7U0FDSjtLQUNKO0lBQ0Qsb0VBQW9FO0lBQ3BFLE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDOUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ25ELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxTQUFTLENBQXNCLElBQWtCO0lBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxFQUF1QixDQUFDO0lBQy9DLFNBQVMsS0FBSyxDQUFDLElBQWlCO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBSSxJQUFJLEVBQUU7UUFDTixLQUFLLENBQUMsSUFBbUIsQ0FBQyxDQUFDO0tBQzlCO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIEhhc1BhcmVudCA9IHsgaWQ6IHN0cmluZzsgcGFyZW50PzogeyBpZDogc3RyaW5nIH0gfCBudWxsIH07XHJcbmV4cG9ydCB0eXBlIFRyZWVOb2RlPFQgZXh0ZW5kcyBIYXNQYXJlbnQ+ID0gVCAmIHsgY2hpbGRyZW46IEFycmF5PFRyZWVOb2RlPFQ+PjsgZXhwYW5kZWQ6IGJvb2xlYW4gfTtcclxuZXhwb3J0IHR5cGUgUm9vdE5vZGU8VCBleHRlbmRzIEhhc1BhcmVudD4gPSB7IGlkPzogc3RyaW5nOyBjaGlsZHJlbjogQXJyYXk8VHJlZU5vZGU8VD4+IH07XHJcblxyXG4vKipcclxuICogQnVpbGRzIGEgdHJlZSBmcm9tIGFuIGFycmF5IG9mIG5vZGVzIHdoaWNoIGhhdmUgYSBwYXJlbnQuXHJcbiAqIEJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTI0Nzk2MC83NzI4NTksIG1vZGlmaWVkIHRvIHByZXNlcnZlIG9yZGVyaW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9UcmVlPFQgZXh0ZW5kcyBIYXNQYXJlbnQ+KFxyXG4gICAgbm9kZXM6IFRbXSxcclxuICAgIGN1cnJlbnRTdGF0ZT86IFJvb3ROb2RlPFQ+LFxyXG4gICAgZXhwYW5kZWRJZHM6IHN0cmluZ1tdID0gW10sXHJcbik6IFJvb3ROb2RlPFQ+IHtcclxuICAgIGNvbnN0IHRvcExldmVsTm9kZXM6IEFycmF5PFRyZWVOb2RlPFQ+PiA9IFtdO1xyXG4gICAgY29uc3QgbWFwcGVkQXJyOiB7IFtpZDogc3RyaW5nXTogVHJlZU5vZGU8VD4gfSA9IHt9O1xyXG4gICAgY29uc3QgY3VycmVudFN0YXRlTWFwID0gdHJlZVRvTWFwKGN1cnJlbnRTdGF0ZSk7XHJcblxyXG4gICAgLy8gRmlyc3QgbWFwIHRoZSBub2RlcyBvZiB0aGUgYXJyYXkgdG8gYW4gb2JqZWN0IC0+IGNyZWF0ZSBhIGhhc2ggdGFibGUuXHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICBtYXBwZWRBcnJbbm9kZS5pZF0gPSB7IC4uLihub2RlIGFzIGFueSksIGNoaWxkcmVuOiBbXSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgaWQgb2Ygbm9kZXMubWFwKG4gPT4gbi5pZCkpIHtcclxuICAgICAgICBpZiAobWFwcGVkQXJyLmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXBwZWRFbGVtID0gbWFwcGVkQXJyW2lkXTtcclxuICAgICAgICAgICAgbWFwcGVkRWxlbS5leHBhbmRlZCA9IGN1cnJlbnRTdGF0ZU1hcC5nZXQoaWQpPy5leHBhbmRlZCA/PyBleHBhbmRlZElkcy5pbmNsdWRlcyhpZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG1hcHBlZEVsZW0ucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGF0IHRoZSByb290IGxldmVsLCBhZGQgaXQgdG8gaXRzIHBhcmVudCBhcnJheSBvZiBjaGlsZHJlbi5cclxuICAgICAgICAgICAgY29uc3QgcGFyZW50SXNSb290ID0gIW1hcHBlZEFycltwYXJlbnQuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudElzUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZEFycltwYXJlbnQuaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkQXJyW3BhcmVudC5pZF0uY2hpbGRyZW4ucHVzaChtYXBwZWRFbGVtKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkQXJyW3BhcmVudC5pZF0gPSB7IGNoaWxkcmVuOiBbbWFwcGVkRWxlbV0gfSBhcyBhbnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b3BMZXZlbE5vZGVzLnB1c2gobWFwcGVkRWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxyXG4gICAgY29uc3Qgcm9vdElkID0gdG9wTGV2ZWxOb2Rlcy5sZW5ndGggPyB0b3BMZXZlbE5vZGVzWzBdLnBhcmVudCEuaWQgOiB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4geyBpZDogcm9vdElkLCBjaGlsZHJlbjogdG9wTGV2ZWxOb2RlcyB9O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gZXhpc3RpbmcgdHJlZSAoYXMgZ2VuZXJhdGVkIGJ5IHRoZSBhcnJheVRvVHJlZSBmdW5jdGlvbikgaW50byBhIGZsYXRcclxuICogTWFwLiBUaGlzIGlzIHVzZWQgdG8gcGVyc2lzdCBjZXJ0YWluIHN0YXRlcyAoZS5nLiBgZXhwYW5kZWRgKSB3aGVuIHJlLWJ1aWxkaW5nIHRoZVxyXG4gKiB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVRvTWFwPFQgZXh0ZW5kcyBIYXNQYXJlbnQ+KHRyZWU/OiBSb290Tm9kZTxUPik6IE1hcDxzdHJpbmcsIFRyZWVOb2RlPFQ+PiB7XHJcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFRyZWVOb2RlPFQ+PigpO1xyXG4gICAgZnVuY3Rpb24gdmlzaXQobm9kZTogVHJlZU5vZGU8VD4pIHtcclxuICAgICAgICBub2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2godmlzaXQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRyZWUpIHtcclxuICAgICAgICB2aXNpdCh0cmVlIGFzIFRyZWVOb2RlPFQ+KTtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlTWFwO1xyXG59XHJcbiJdfQ==