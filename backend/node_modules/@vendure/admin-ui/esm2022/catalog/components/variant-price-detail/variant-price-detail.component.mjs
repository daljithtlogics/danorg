import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@vendure/admin-ui/core";
import * as i2 from "@clr/angular";
import * as i3 from "@angular/common";
import * as i4 from "@ngx-translate/core";
export class VariantPriceDetailComponent {
    constructor(dataService) {
        this.dataService = dataService;
        this.priceChange$ = new BehaviorSubject(0);
        this.taxCategoryIdChange$ = new BehaviorSubject('');
    }
    ngOnInit() {
        const taxRates$ = this.dataService.settings
            .getTaxRatesSimple(999, 0, 'cache-first')
            .mapStream(data => data.taxRates.items);
        const activeChannel$ = this.dataService.settings
            .getActiveChannel('cache-first')
            .refetchOnChannelChange()
            .mapStream(data => data.activeChannel);
        this.taxRate$ = combineLatest(activeChannel$, taxRates$, this.taxCategoryIdChange$).pipe(map(([channel, taxRates, taxCategoryId]) => {
            const defaultTaxZone = channel.defaultTaxZone;
            if (!defaultTaxZone) {
                return 0;
            }
            const applicableRate = taxRates.find(taxRate => taxRate.zone.id === defaultTaxZone.id && taxRate.category.id === taxCategoryId);
            if (!applicableRate) {
                return 0;
            }
            return applicableRate.value;
        }));
        this.grossPrice$ = combineLatest(this.taxRate$, this.priceChange$).pipe(map(([taxRate, price]) => Math.round(price * ((100 + taxRate) / 100))));
    }
    ngOnChanges(changes) {
        if ('price' in changes) {
            this.priceChange$.next(changes.price.currentValue);
        }
        if ('taxCategoryId' in changes) {
            this.taxCategoryIdChange$.next(changes.taxCategoryId.currentValue);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: VariantPriceDetailComponent, deps: [{ token: i1.DataService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: VariantPriceDetailComponent, selector: "vdr-variant-price-detail", inputs: { priceIncludesTax: "priceIncludesTax", price: "price", currencyCode: "currencyCode", taxCategoryId: "taxCategoryId" }, usesOnChanges: true, ngImport: i0, template: "<label class=\"clr-control-label\">{{ 'catalog.taxes' | translate }}</label>\r\n<div *ngIf=\"priceIncludesTax\" class=\"value\">\r\n    {{ 'catalog.price-includes-tax-at' | translate: { rate: taxRate$ | async } }}\r\n</div>\r\n<div *ngIf=\"!priceIncludesTax\" class=\"value\">\r\n    {{\r\n        'catalog.price-with-tax-in-default-zone'\r\n            | translate: { price: grossPrice$ | async | localeCurrency: currencyCode, rate: taxRate$ | async }\r\n    }}\r\n</div>\r\n", styles: [":host{display:flex;flex-direction:column}.value{margin-top:3px}\n"], dependencies: [{ kind: "directive", type: i2.ClrLabel, selector: "label", inputs: ["for"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i4.TranslatePipe, name: "translate" }, { kind: "pipe", type: i1.LocaleCurrencyPipe, name: "localeCurrency" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: VariantPriceDetailComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-variant-price-detail', changeDetection: ChangeDetectionStrategy.OnPush, template: "<label class=\"clr-control-label\">{{ 'catalog.taxes' | translate }}</label>\r\n<div *ngIf=\"priceIncludesTax\" class=\"value\">\r\n    {{ 'catalog.price-includes-tax-at' | translate: { rate: taxRate$ | async } }}\r\n</div>\r\n<div *ngIf=\"!priceIncludesTax\" class=\"value\">\r\n    {{\r\n        'catalog.price-with-tax-in-default-zone'\r\n            | translate: { price: grossPrice$ | async | localeCurrency: currencyCode, rate: taxRate$ | async }\r\n    }}\r\n</div>\r\n", styles: [":host{display:flex;flex-direction:column}.value{margin-top:3px}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.DataService }]; }, propDecorators: { priceIncludesTax: [{
                type: Input
            }], price: [{
                type: Input
            }], currencyCode: [{
                type: Input
            }], taxCategoryId: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFyaWFudC1wcmljZS1kZXRhaWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jYXRhbG9nL3NyYy9jb21wb25lbnRzL3ZhcmlhbnQtcHJpY2UtZGV0YWlsL3ZhcmlhbnQtcHJpY2UtZGV0YWlsLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy92YXJpYW50LXByaWNlLWRldGFpbC92YXJpYW50LXByaWNlLWRldGFpbC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFFNUcsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQXVCLE1BQU0sTUFBTSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBUXJDLE1BQU0sT0FBTywyQkFBMkI7SUFZcEMsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFIcEMsaUJBQVksR0FBRyxJQUFJLGVBQWUsQ0FBUyxDQUFDLENBQUMsQ0FBQztRQUM5Qyx5QkFBb0IsR0FBRyxJQUFJLGVBQWUsQ0FBUyxFQUFFLENBQUMsQ0FBQztJQUVoQixDQUFDO0lBRWhELFFBQVE7UUFDSixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7YUFDdEMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxhQUFhLENBQUM7YUFDeEMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVE7YUFDM0MsZ0JBQWdCLENBQUMsYUFBYSxDQUFDO2FBQy9CLHNCQUFzQixFQUFFO2FBQ3hCLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUUzQyxJQUFJLENBQUMsUUFBUSxHQUFHLGFBQWEsQ0FBQyxjQUFjLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLElBQUksQ0FDcEYsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLGFBQWEsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQztZQUM5QyxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUNqQixPQUFPLENBQUMsQ0FBQzthQUNaO1lBQ0QsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FDaEMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxjQUFjLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxLQUFLLGFBQWEsQ0FDNUYsQ0FBQztZQUVGLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ2pCLE9BQU8sQ0FBQyxDQUFDO2FBQ1o7WUFDRCxPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQ0wsQ0FBQztRQUVGLElBQUksQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FDbkUsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUN6RSxDQUFDO0lBQ04sQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUM5QixJQUFJLE9BQU8sSUFBSSxPQUFPLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUN0RDtRQUNELElBQUksZUFBZSxJQUFJLE9BQU8sRUFBRTtZQUM1QixJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDdEU7SUFDTCxDQUFDOzhHQXBEUSwyQkFBMkI7a0dBQTNCLDJCQUEyQixxTkNYeEMsOGRBVUE7OzJGRENhLDJCQUEyQjtrQkFOdkMsU0FBUzsrQkFDSSwwQkFBMEIsbUJBR25CLHVCQUF1QixDQUFDLE1BQU07a0dBR3RDLGdCQUFnQjtzQkFBeEIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUs7Z0JBQ0csWUFBWTtzQkFBcEIsS0FBSztnQkFDRyxhQUFhO3NCQUFyQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLXZhcmlhbnQtcHJpY2UtZGV0YWlsJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi92YXJpYW50LXByaWNlLWRldGFpbC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi92YXJpYW50LXByaWNlLWRldGFpbC5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBWYXJpYW50UHJpY2VEZXRhaWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XHJcbiAgICBASW5wdXQoKSBwcmljZUluY2x1ZGVzVGF4OiBib29sZWFuO1xyXG4gICAgQElucHV0KCkgcHJpY2U6IG51bWJlcjtcclxuICAgIEBJbnB1dCgpIGN1cnJlbmN5Q29kZTogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgdGF4Q2F0ZWdvcnlJZDogc3RyaW5nO1xyXG5cclxuICAgIGdyb3NzUHJpY2UkOiBPYnNlcnZhYmxlPG51bWJlcj47XHJcbiAgICB0YXhSYXRlJDogT2JzZXJ2YWJsZTxudW1iZXI+O1xyXG5cclxuICAgIHByaXZhdGUgcHJpY2VDaGFuZ2UkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KDApO1xyXG4gICAgcHJpdmF0ZSB0YXhDYXRlZ29yeUlkQ2hhbmdlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UpIHt9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgdGF4UmF0ZXMkID0gdGhpcy5kYXRhU2VydmljZS5zZXR0aW5nc1xyXG4gICAgICAgICAgICAuZ2V0VGF4UmF0ZXNTaW1wbGUoOTk5LCAwLCAnY2FjaGUtZmlyc3QnKVxyXG4gICAgICAgICAgICAubWFwU3RyZWFtKGRhdGEgPT4gZGF0YS50YXhSYXRlcy5pdGVtcyk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlQ2hhbm5lbCQgPSB0aGlzLmRhdGFTZXJ2aWNlLnNldHRpbmdzXHJcbiAgICAgICAgICAgIC5nZXRBY3RpdmVDaGFubmVsKCdjYWNoZS1maXJzdCcpXHJcbiAgICAgICAgICAgIC5yZWZldGNoT25DaGFubmVsQ2hhbmdlKClcclxuICAgICAgICAgICAgLm1hcFN0cmVhbShkYXRhID0+IGRhdGEuYWN0aXZlQ2hhbm5lbCk7XHJcblxyXG4gICAgICAgIHRoaXMudGF4UmF0ZSQgPSBjb21iaW5lTGF0ZXN0KGFjdGl2ZUNoYW5uZWwkLCB0YXhSYXRlcyQsIHRoaXMudGF4Q2F0ZWdvcnlJZENoYW5nZSQpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoW2NoYW5uZWwsIHRheFJhdGVzLCB0YXhDYXRlZ29yeUlkXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFRheFpvbmUgPSBjaGFubmVsLmRlZmF1bHRUYXhab25lO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0VGF4Wm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwbGljYWJsZVJhdGUgPSB0YXhSYXRlcy5maW5kKFxyXG4gICAgICAgICAgICAgICAgICAgIHRheFJhdGUgPT4gdGF4UmF0ZS56b25lLmlkID09PSBkZWZhdWx0VGF4Wm9uZS5pZCAmJiB0YXhSYXRlLmNhdGVnb3J5LmlkID09PSB0YXhDYXRlZ29yeUlkLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFwcGxpY2FibGVSYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbGljYWJsZVJhdGUudmFsdWU7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3Jvc3NQcmljZSQgPSBjb21iaW5lTGF0ZXN0KHRoaXMudGF4UmF0ZSQsIHRoaXMucHJpY2VDaGFuZ2UkKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKFt0YXhSYXRlLCBwcmljZV0pID0+IE1hdGgucm91bmQocHJpY2UgKiAoKDEwMCArIHRheFJhdGUpIC8gMTAwKSkpLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmICgncHJpY2UnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmljZUNoYW5nZSQubmV4dChjaGFuZ2VzLnByaWNlLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgndGF4Q2F0ZWdvcnlJZCcgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLnRheENhdGVnb3J5SWRDaGFuZ2UkLm5leHQoY2hhbmdlcy50YXhDYXRlZ29yeUlkLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIjxsYWJlbCBjbGFzcz1cImNsci1jb250cm9sLWxhYmVsXCI+e3sgJ2NhdGFsb2cudGF4ZXMnIHwgdHJhbnNsYXRlIH19PC9sYWJlbD5cclxuPGRpdiAqbmdJZj1cInByaWNlSW5jbHVkZXNUYXhcIiBjbGFzcz1cInZhbHVlXCI+XHJcbiAgICB7eyAnY2F0YWxvZy5wcmljZS1pbmNsdWRlcy10YXgtYXQnIHwgdHJhbnNsYXRlOiB7IHJhdGU6IHRheFJhdGUkIHwgYXN5bmMgfSB9fVxyXG48L2Rpdj5cclxuPGRpdiAqbmdJZj1cIiFwcmljZUluY2x1ZGVzVGF4XCIgY2xhc3M9XCJ2YWx1ZVwiPlxyXG4gICAge3tcclxuICAgICAgICAnY2F0YWxvZy5wcmljZS13aXRoLXRheC1pbi1kZWZhdWx0LXpvbmUnXHJcbiAgICAgICAgICAgIHwgdHJhbnNsYXRlOiB7IHByaWNlOiBncm9zc1ByaWNlJCB8IGFzeW5jIHwgbG9jYWxlQ3VycmVuY3k6IGN1cnJlbmN5Q29kZSwgcmF0ZTogdGF4UmF0ZSQgfCBhc3luYyB9XHJcbiAgICB9fVxyXG48L2Rpdj5cclxuIl19