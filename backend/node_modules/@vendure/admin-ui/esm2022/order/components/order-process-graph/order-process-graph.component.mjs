import { ChangeDetectionStrategy, Component, HostBinding, Input, ViewChildren, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { NODE_HEIGHT } from './constants';
import { OrderProcessNodeComponent } from './order-process-node.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./order-process-node.component";
import * as i3 from "./order-process-edge.component";
export class OrderProcessGraphComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.setActiveState$ = new BehaviorSubject(undefined);
        this.nodes = [];
        this.edges = [];
    }
    get outerHeight() {
        return this.nodes.length * NODE_HEIGHT;
    }
    ngOnInit() {
        this.setActiveState$.next(this.initialState);
        this.activeState$ = this.setActiveState$.pipe(debounceTime(150));
    }
    ngOnChanges(changes) {
        this.populateNodes();
    }
    ngAfterViewInit() {
        setTimeout(() => this.populateEdges());
    }
    onMouseOver(stateName) {
        this.setActiveState$.next(stateName);
    }
    onMouseOut() {
        this.setActiveState$.next(this.initialState);
    }
    getNodeFor(state) {
        if (this.nodeComponents) {
            return this.nodeComponents.find((n) => n.node.name === state);
        }
    }
    populateNodes() {
        const stateNodeMap = new Map();
        for (const state of this.states) {
            stateNodeMap.set(state.name, {
                name: state.name,
                to: [],
            });
        }
        for (const [name, stateNode] of stateNodeMap.entries()) {
            const targets = this.states.find((s) => s.name === name)?.to ?? [];
            for (const target of targets) {
                const targetNode = stateNodeMap.get(target);
                if (targetNode) {
                    stateNode.to.push(targetNode);
                }
            }
        }
        this.nodes = [...stateNodeMap.values()].filter((n) => n.name !== 'Cancelled');
    }
    populateEdges() {
        for (const node of this.nodes) {
            const nodeCmp = this.getNodeFor(node.name);
            let index = 0;
            for (const to of node.to) {
                const toCmp = this.getNodeFor(to.name);
                if (nodeCmp && toCmp && nodeCmp !== toCmp) {
                    this.edges.push({
                        to: toCmp,
                        from: nodeCmp,
                        index,
                    });
                    index++;
                }
            }
        }
        this.edges = [...this.edges];
        this.changeDetector.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderProcessGraphComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: OrderProcessGraphComponent, selector: "vdr-order-process-graph", inputs: { states: "states", initialState: "initialState" }, host: { properties: { "style.height.px": "this.outerHeight" } }, viewQueries: [{ propertyName: "nodeComponents", predicate: OrderProcessNodeComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container *ngFor=\"let state of nodes; let i = index\">\r\n    <vdr-order-process-node\r\n        [node]=\"state\"\r\n        [index]=\"i\"\r\n        [active]=\"(activeState$ | async) === state.name\"\r\n        (mouseenter)=\"onMouseOver(state.name)\"\r\n        (mouseleave)=\"onMouseOut()\"\r\n    ></vdr-order-process-node>\r\n</ng-container>\r\n<ng-container *ngFor=\"let edge of edges\">\r\n    <vdr-order-process-edge [from]=\"edge.from\" [to]=\"edge.to\" [index]=\"edge.index\"></vdr-order-process-edge>\r\n</ng-container>\r\n", styles: [":host{display:block;border:1px hotpink;margin:20px;padding:12px;position:relative}.state-row{display:flex}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i2.OrderProcessNodeComponent, selector: "vdr-order-process-node", inputs: ["node", "index", "active"] }, { kind: "component", type: i3.OrderProcessEdgeComponent, selector: "vdr-order-process-edge", inputs: ["from", "to", "index"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderProcessGraphComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-order-process-graph', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngFor=\"let state of nodes; let i = index\">\r\n    <vdr-order-process-node\r\n        [node]=\"state\"\r\n        [index]=\"i\"\r\n        [active]=\"(activeState$ | async) === state.name\"\r\n        (mouseenter)=\"onMouseOver(state.name)\"\r\n        (mouseleave)=\"onMouseOut()\"\r\n    ></vdr-order-process-node>\r\n</ng-container>\r\n<ng-container *ngFor=\"let edge of edges\">\r\n    <vdr-order-process-edge [from]=\"edge.from\" [to]=\"edge.to\" [index]=\"edge.index\"></vdr-order-process-edge>\r\n</ng-container>\r\n", styles: [":host{display:block;border:1px hotpink;margin:20px;padding:12px;position:relative}.state-row{display:flex}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { states: [{
                type: Input
            }], initialState: [{
                type: Input
            }], nodeComponents: [{
                type: ViewChildren,
                args: [OrderProcessNodeComponent]
            }], outerHeight: [{
                type: HostBinding,
                args: ['style.height.px']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL29yZGVyL3NyYy9jb21wb25lbnRzL29yZGVyLXByb2Nlc3MtZ3JhcGgvb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL29yZGVyL3NyYy9jb21wb25lbnRzL29yZGVyLXByb2Nlc3MtZ3JhcGgvb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxXQUFXLEVBQ1gsS0FBSyxFQUtMLFlBQVksR0FDZixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU5QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7OztBQVMzRSxNQUFNLE9BQU8sMEJBQTBCO0lBVW5DLFlBQW9CLGNBQWlDO1FBQWpDLG1CQUFjLEdBQWQsY0FBYyxDQUFtQjtRQVByRCxvQkFBZSxHQUFHLElBQUksZUFBZSxDQUFxQixTQUFTLENBQUMsQ0FBQztRQUVyRSxVQUFLLEdBQWdCLEVBQUUsQ0FBQztRQUN4QixVQUFLLEdBQTZGLEVBQUUsQ0FBQztJQUk3QyxDQUFDO0lBRXpELElBQ0ksV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO0lBQzNDLENBQUM7SUFFRCxRQUFRO1FBQ0osSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElB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QUssR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdkMsQ0FBQzs4R0FuRlEsMEJBQTBCO2tHQUExQiwwQkFBMEIsK05BUXJCLHlCQUF5QixxRUNuQzNDLDZoQkFZQTs7MkZEZWEsMEJBQTBCO2tCQU50QyxTQUFTOytCQUNJLHlCQUF5QixtQkFHbEIsdUJBQXVCLENBQUMsTUFBTTt3R0FHdEMsTUFBTTtzQkFBZCxLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBTW1DLGNBQWM7c0JBQXRELFlBQVk7dUJBQUMseUJBQXlCO2dCQUtuQyxXQUFXO3NCQURkLFdBQVc7dUJBQUMsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIEFmdGVyVmlld0luaXQsXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICAgIENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgQ29tcG9uZW50LFxyXG4gICAgSG9zdEJpbmRpbmcsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uSW5pdCxcclxuICAgIFF1ZXJ5TGlzdCxcclxuICAgIFNpbXBsZUNoYW5nZXMsXHJcbiAgICBWaWV3Q2hpbGRyZW4sXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9yZGVyUHJvY2Vzc1N0YXRlIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBOT0RFX0hFSUdIVCB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgT3JkZXJQcm9jZXNzTm9kZUNvbXBvbmVudCB9IGZyb20gJy4vb3JkZXItcHJvY2Vzcy1ub2RlLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFN0YXRlTm9kZSB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1vcmRlci1wcm9jZXNzLWdyYXBoJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9vcmRlci1wcm9jZXNzLWdyYXBoLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL29yZGVyLXByb2Nlc3MtZ3JhcGguY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgT3JkZXJQcm9jZXNzR3JhcGhDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCB7XHJcbiAgICBASW5wdXQoKSBzdGF0ZXM6IE9yZGVyUHJvY2Vzc1N0YXRlW107XHJcbiAgICBASW5wdXQoKSBpbml0aWFsU3RhdGU/OiBzdHJpbmc7XHJcbiAgICBzZXRBY3RpdmVTdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuICAgIGFjdGl2ZVN0YXRlJDogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xyXG4gICAgbm9kZXM6IFN0YXRlTm9kZVtdID0gW107XHJcbiAgICBlZGdlczogQXJyYXk8eyBmcm9tOiBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50OyB0bzogT3JkZXJQcm9jZXNzTm9kZUNvbXBvbmVudDsgaW5kZXg6IG51bWJlciB9PiA9IFtdO1xyXG5cclxuICAgIEBWaWV3Q2hpbGRyZW4oT3JkZXJQcm9jZXNzTm9kZUNvbXBvbmVudCkgbm9kZUNvbXBvbmVudHM6IFF1ZXJ5TGlzdDxPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50PjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZikge31cclxuXHJcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmhlaWdodC5weCcpXHJcbiAgICBnZXQgb3V0ZXJIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggKiBOT0RFX0hFSUdIVDtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnNldEFjdGl2ZVN0YXRlJC5uZXh0KHRoaXMuaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlJCA9IHRoaXMuc2V0QWN0aXZlU3RhdGUkLnBpcGUoZGVib3VuY2VUaW1lKDE1MCkpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnBvcHVsYXRlTm9kZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnBvcHVsYXRlRWRnZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VzZU92ZXIoc3RhdGVOYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnNldEFjdGl2ZVN0YXRlJC5uZXh0KHN0YXRlTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VzZU91dCgpIHtcclxuICAgICAgICB0aGlzLnNldEFjdGl2ZVN0YXRlJC5uZXh0KHRoaXMuaW5pdGlhbFN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROb2RlRm9yKHN0YXRlOiBzdHJpbmcpOiBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlQ29tcG9uZW50cy5maW5kKChuKSA9PiBuLm5vZGUubmFtZSA9PT0gc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHBvcHVsYXRlTm9kZXMoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGVOb2RlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFN0YXRlTm9kZT4oKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgICAgICAgIHN0YXRlTm9kZU1hcC5zZXQoc3RhdGUubmFtZSwge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogc3RhdGUubmFtZSxcclxuICAgICAgICAgICAgICAgIHRvOiBbXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBzdGF0ZU5vZGVdIG9mIHN0YXRlTm9kZU1hcC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0cyA9IHRoaXMuc3RhdGVzLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gbmFtZSk/LnRvID8/IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gc3RhdGVOb2RlTWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU5vZGUudG8ucHVzaCh0YXJnZXROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vZGVzID0gWy4uLnN0YXRlTm9kZU1hcC52YWx1ZXMoKV0uZmlsdGVyKChuKSA9PiBuLm5hbWUgIT09ICdDYW5jZWxsZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHBvcHVsYXRlRWRnZXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZUNtcCA9IHRoaXMuZ2V0Tm9kZUZvcihub2RlLm5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvIG9mIG5vZGUudG8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ21wID0gdGhpcy5nZXROb2RlRm9yKHRvLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVDbXAgJiYgdG9DbXAgJiYgbm9kZUNtcCAhPT0gdG9DbXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogdG9DbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IG5vZGVDbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lZGdlcyA9IFsuLi50aGlzLmVkZ2VzXTtcclxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG59XHJcbiIsIjxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHN0YXRlIG9mIG5vZGVzOyBsZXQgaSA9IGluZGV4XCI+XHJcbiAgICA8dmRyLW9yZGVyLXByb2Nlc3Mtbm9kZVxyXG4gICAgICAgIFtub2RlXT1cInN0YXRlXCJcclxuICAgICAgICBbaW5kZXhdPVwiaVwiXHJcbiAgICAgICAgW2FjdGl2ZV09XCIoYWN0aXZlU3RhdGUkIHwgYXN5bmMpID09PSBzdGF0ZS5uYW1lXCJcclxuICAgICAgICAobW91c2VlbnRlcik9XCJvbk1vdXNlT3ZlcihzdGF0ZS5uYW1lKVwiXHJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwib25Nb3VzZU91dCgpXCJcclxuICAgID48L3Zkci1vcmRlci1wcm9jZXNzLW5vZGU+XHJcbjwvbmctY29udGFpbmVyPlxyXG48bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBlZGdlIG9mIGVkZ2VzXCI+XHJcbiAgICA8dmRyLW9yZGVyLXByb2Nlc3MtZWRnZSBbZnJvbV09XCJlZGdlLmZyb21cIiBbdG9dPVwiZWRnZS50b1wiIFtpbmRleF09XCJlZGdlLmluZGV4XCI+PC92ZHItb3JkZXItcHJvY2Vzcy1lZGdlPlxyXG48L25nLWNvbnRhaW5lcj5cclxuIl19