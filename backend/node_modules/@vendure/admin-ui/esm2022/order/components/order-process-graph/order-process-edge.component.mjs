import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@clr/angular";
import * as i2 from "@angular/common";
export class OrderProcessEdgeComponent {
    ngOnInit() {
        this.active$ = this.from.active$
            .asObservable()
            .pipe(tap((active) => this.to.activeTarget$.next(active)));
    }
    getStyle() {
        const direction = this.from.index < this.to.index ? 'down' : 'up';
        const startPos = this.from.getPos(direction === 'down' ? 'bottom' : 'top');
        const endPos = this.to.getPos(direction === 'down' ? 'top' : 'bottom');
        const dX = Math.abs(startPos.x - endPos.x);
        const dY = Math.abs(startPos.y - endPos.y);
        const length = Math.sqrt(dX ** 2 + dY ** 2);
        return {
            'top.px': startPos.y,
            'left.px': startPos.x + (direction === 'down' ? 10 : 40) + this.index * 12,
            'height.px': length,
            'width.px': 1,
            ...(direction === 'up'
                ? {
                    transform: 'rotateZ(180deg)',
                    'transform-origin': 'top',
                }
                : {}),
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderProcessEdgeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.2", type: OrderProcessEdgeComponent, selector: "vdr-order-process-edge", inputs: { from: "from", to: "to", index: "index" }, ngImport: i0, template: "<div\r\n    [attr.data-from]=\"from.node.name\"\r\n    [attr.data-to]=\"to.node.name\"\r\n    [ngStyle]=\"getStyle()\"\r\n    [class.active]=\"active$ | async\"\r\n    class=\"edge\">\r\n    <clr-icon shape=\"arrow\" flip=\"vertical\" class=\"arrow\"></clr-icon>\r\n</div>\r\n", styles: [".edge{position:absolute;border:1px solid var(--color-component-border-200);background-color:var(--color-component-bg-300);opacity:.3;transition:border .2s,opacity .2s,background-color .2s}.edge.active{border-color:var(--color-primary-500);background-color:var(--color-primary-500);opacity:1}.edge.active .arrow{color:var(--color-primary-500)}.edge .arrow{position:absolute;bottom:-4px;left:-8px;color:var(--color-grey-300)}\n"], dependencies: [{ kind: "directive", type: i1.ClrIconCustomTag, selector: "clr-icon" }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderProcessEdgeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-order-process-edge', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\r\n    [attr.data-from]=\"from.node.name\"\r\n    [attr.data-to]=\"to.node.name\"\r\n    [ngStyle]=\"getStyle()\"\r\n    [class.active]=\"active$ | async\"\r\n    class=\"edge\">\r\n    <clr-icon shape=\"arrow\" flip=\"vertical\" class=\"arrow\"></clr-icon>\r\n</div>\r\n", styles: [".edge{position:absolute;border:1px solid var(--color-component-border-200);background-color:var(--color-component-bg-300);opacity:.3;transition:border .2s,opacity .2s,background-color .2s}.edge.active{border-color:var(--color-primary-500);background-color:var(--color-primary-500);opacity:1}.edge.active .arrow{color:var(--color-primary-500)}.edge .arrow{position:absolute;bottom:-4px;left:-8px;color:var(--color-grey-300)}\n"] }]
        }], propDecorators: { from: [{
                type: Input
            }], to: [{
                type: Input
            }], index: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItcHJvY2Vzcy1lZGdlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvb3JkZXIvc3JjL2NvbXBvbmVudHMvb3JkZXItcHJvY2Vzcy1ncmFwaC9vcmRlci1wcm9jZXNzLWVkZ2UuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9vcmRlci9zcmMvY29tcG9uZW50cy9vcmRlci1wcm9jZXNzLWdyYXBoL29yZGVyLXByb2Nlc3MtZWRnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUVsRixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFVckMsTUFBTSxPQUFPLHlCQUF5QjtJQU1sQyxRQUFRO1FBQ0osSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU87YUFDM0IsWUFBWSxFQUFFO2FBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQsUUFBUTtRQUNKLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNsRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUMsT0FBTztZQUNILFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNwQixTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFO1lBQzFFLFdBQVcsRUFBRSxNQUFNO1lBQ25CLFVBQVUsRUFBRSxDQUFDO1lBQ2IsR0FBRyxDQUFDLFNBQVMsS0FBSyxJQUFJO2dCQUNsQixDQUFDLENBQUM7b0JBQ0ksU0FBUyxFQUFFLGlCQUFpQjtvQkFDNUIsa0JBQWtCLEVBQUUsS0FBSztpQkFDNUI7Z0JBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQztTQUNaLENBQUM7SUFDTixDQUFDOzhHQS9CUSx5QkFBeUI7a0dBQXpCLHlCQUF5QixrSENadEMsc1JBUUE7OzJGRElhLHlCQUF5QjtrQkFOckMsU0FBUzsrQkFDSSx3QkFBd0IsbUJBR2pCLHVCQUF1QixDQUFDLE1BQU07OEJBR3RDLElBQUk7c0JBQVosS0FBSztnQkFDRyxFQUFFO3NCQUFWLEtBQUs7Z0JBQ0csS0FBSztzQkFBYixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQgfSBmcm9tICcuL29yZGVyLXByb2Nlc3Mtbm9kZS5jb21wb25lbnQnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1vcmRlci1wcm9jZXNzLWVkZ2UnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL29yZGVyLXByb2Nlc3MtZWRnZS5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9vcmRlci1wcm9jZXNzLWVkZ2UuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgT3JkZXJQcm9jZXNzRWRnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgICBASW5wdXQoKSBmcm9tOiBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50O1xyXG4gICAgQElucHV0KCkgdG86IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQ7XHJcbiAgICBASW5wdXQoKSBpbmRleDogbnVtYmVyO1xyXG4gICAgYWN0aXZlJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSQgPSB0aGlzLmZyb20uYWN0aXZlJFxyXG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcclxuICAgICAgICAgICAgLnBpcGUodGFwKChhY3RpdmUpID0+IHRoaXMudG8uYWN0aXZlVGFyZ2V0JC5uZXh0KGFjdGl2ZSkpKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdHlsZSgpIHtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmZyb20uaW5kZXggPCB0aGlzLnRvLmluZGV4ID8gJ2Rvd24nIDogJ3VwJztcclxuICAgICAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuZnJvbS5nZXRQb3MoZGlyZWN0aW9uID09PSAnZG93bicgPyAnYm90dG9tJyA6ICd0b3AnKTtcclxuICAgICAgICBjb25zdCBlbmRQb3MgPSB0aGlzLnRvLmdldFBvcyhkaXJlY3Rpb24gPT09ICdkb3duJyA/ICd0b3AnIDogJ2JvdHRvbScpO1xyXG4gICAgICAgIGNvbnN0IGRYID0gTWF0aC5hYnMoc3RhcnRQb3MueCAtIGVuZFBvcy54KTtcclxuICAgICAgICBjb25zdCBkWSA9IE1hdGguYWJzKHN0YXJ0UG9zLnkgLSBlbmRQb3MueSk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KGRYICoqIDIgKyBkWSAqKiAyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAndG9wLnB4Jzogc3RhcnRQb3MueSxcclxuICAgICAgICAgICAgJ2xlZnQucHgnOiBzdGFydFBvcy54ICsgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gMTAgOiA0MCkgKyB0aGlzLmluZGV4ICogMTIsXHJcbiAgICAgICAgICAgICdoZWlnaHQucHgnOiBsZW5ndGgsXHJcbiAgICAgICAgICAgICd3aWR0aC5weCc6IDEsXHJcbiAgICAgICAgICAgIC4uLihkaXJlY3Rpb24gPT09ICd1cCdcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlWigxODBkZWcpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0tb3JpZ2luJzogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge30pLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiPGRpdlxyXG4gICAgW2F0dHIuZGF0YS1mcm9tXT1cImZyb20ubm9kZS5uYW1lXCJcclxuICAgIFthdHRyLmRhdGEtdG9dPVwidG8ubm9kZS5uYW1lXCJcclxuICAgIFtuZ1N0eWxlXT1cImdldFN0eWxlKClcIlxyXG4gICAgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmUkIHwgYXN5bmNcIlxyXG4gICAgY2xhc3M9XCJlZGdlXCI+XHJcbiAgICA8Y2xyLWljb24gc2hhcGU9XCJhcnJvd1wiIGZsaXA9XCJ2ZXJ0aWNhbFwiIGNsYXNzPVwiYXJyb3dcIj48L2Nsci1pY29uPlxyXG48L2Rpdj5cclxuIl19