import { Injectable } from '@angular/core';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { HistoryEntryType, SortOrder, } from '@vendure/admin-ui/core';
import { EMPTY } from 'rxjs';
import { catchError, delay, map, retryWhen, switchMap, take } from 'rxjs/operators';
import { OrderStateSelectDialogComponent } from '../components/order-state-select-dialog/order-state-select-dialog.component';
import * as i0 from "@angular/core";
import * as i1 from "@vendure/admin-ui/core";
export class OrderTransitionService {
    constructor(dataService, modalService, notificationService, i18nService) {
        this.dataService = dataService;
        this.modalService = modalService;
        this.notificationService = notificationService;
        this.i18nService = i18nService;
    }
    /**
     * Attempts to transition the Order to the last state it was in before it was transitioned
     * to the "Modifying" state. If this fails, a manual prompt is used.
     */
    transitionToPreModifyingState(orderId, nextStates) {
        return this.getPreModifyingState(orderId).pipe(switchMap(state => {
            const manualTransitionOptions = {
                orderId,
                nextStates,
                message: this.i18nService.translate(_('order.unable-to-transition-to-state-try-another'), { state }),
                cancellable: false,
                retry: 10,
            };
            if (state) {
                return this.transitionToStateOrThrow(orderId, state).pipe(catchError(err => this.manuallyTransitionToState(manualTransitionOptions)));
            }
            else {
                return this.manuallyTransitionToState(manualTransitionOptions);
            }
        }));
    }
    /**
     * Displays a modal for manually selecting the next state.
     */
    manuallyTransitionToState(options) {
        return this.modalService
            .fromComponent(OrderStateSelectDialogComponent, {
            locals: {
                nextStates: options.nextStates,
                cancellable: options.cancellable,
                message: options.message,
            },
            closable: false,
            size: 'md',
        })
            .pipe(switchMap(result => {
            if (result) {
                return this.transitionToStateOrThrow(options.orderId, result);
            }
            else {
                if (!options.cancellable) {
                    throw new Error(`An order state must be selected`);
                }
                else {
                    return EMPTY;
                }
            }
        }), retryWhen(errors => errors.pipe(delay(2000), take(options.retry))));
    }
    /**
     * Attempts to get the last state the Order was in before it was transitioned
     * to the "Modifying" state.
     */
    getPreModifyingState(orderId) {
        return this.dataService.order
            .getOrderHistory(orderId, {
            filter: {
                type: {
                    eq: HistoryEntryType.ORDER_STATE_TRANSITION,
                },
            },
            sort: {
                createdAt: SortOrder.DESC,
            },
        })
            .mapSingle(result => result.order)
            .pipe(map(result => {
            const item = result?.history.items.find(i => i.data.to === 'Modifying');
            if (item) {
                return item.data.from;
            }
            else {
                return;
            }
        }));
    }
    transitionToStateOrThrow(orderId, state) {
        return this.dataService.order.transitionToState(orderId, state).pipe(map(({ transitionOrderToState }) => {
            switch (transitionOrderToState?.__typename) {
                case 'Order':
                    return transitionOrderToState?.state;
                case 'OrderStateTransitionError':
                    this.notificationService.error(transitionOrderToState?.transitionError);
                    throw new Error(transitionOrderToState?.transitionError);
            }
        }));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderTransitionService, deps: [{ token: i1.DataService }, { token: i1.ModalService }, { token: i1.NotificationService }, { token: i1.I18nService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderTransitionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.2", ngImport: i0, type: OrderTransitionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.DataService }, { type: i1.ModalService }, { type: i1.NotificationService }, { type: i1.I18nService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItdHJhbnNpdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9vcmRlci9zcmMvcHJvdmlkZXJzL29yZGVyLXRyYW5zaXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDdEUsT0FBTyxFQUVILGdCQUFnQixFQUloQixTQUFTLEdBQ1osTUFBTSx3QkFBd0IsQ0FBQztBQUNoQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXBGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLDZFQUE2RSxDQUFDOzs7QUFLOUgsTUFBTSxPQUFPLHNCQUFzQjtJQUMvQixZQUNZLFdBQXdCLEVBQ3hCLFlBQTBCLEVBQzFCLG1CQUF3QyxFQUN4QyxXQUF3QjtRQUh4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4QixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBQ3hDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQ2pDLENBQUM7SUFFSjs7O09BR0c7SUFDSCw2QkFBNkIsQ0FBQyxPQUFlLEVBQUUsVUFBb0I7UUFDL0QsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUMxQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDZCxNQUFNLHVCQUF1QixHQUFHO2dCQUM1QixPQUFPO2dCQUNQLFVBQVU7Z0JBQ1YsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUMvQixDQUFDLENBQUMsaURBQWlELENBQUMsRUFDcEQsRUFBRSxLQUFLLEVBQUUsQ0FDWjtnQkFDRCxXQUFXLEVBQUUsS0FBSztnQkFDbEIsS0FBSyxFQUFFLEVBQUU7YUFDWixDQUFDO1lBQ0YsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FDckQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FDN0UsQ0FBQzthQUNMO2lCQUFNO2dCQUNILE9BQU8sSUFBSSxDQUFDLHlCQUF5QixDQUFDLHVCQUF1QixDQUFDLENBQUM7YUFDbEU7UUFDTCxDQUFDLENBQUMsQ0FDTCxDQUFDO0lBQ04sQ0FBQztJQUVEOztPQUVHO0lBQ0gseUJBQXlCLENBQUMsT0FNekI7UUFDRyxPQUFPLElBQUksQ0FBQyxZQUFZO2FBQ25CLGFBQWEsQ0FBQywrQkFBK0IsRUFBRTtZQUM1QyxNQUFNLEVBQUU7Z0JBQ0osVUFBVSxFQUFFLE9BQU8sQ0FBQyxVQUFVO2dCQUM5QixXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVc7Z0JBQ2hDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTzthQUMzQjtZQUNELFFBQVEsRUFBRSxLQUFLO1lBQ2YsSUFBSSxFQUFFLElBQUk7U0FDYixDQUFDO2FBQ0QsSUFBSSxDQUNELFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNmLElBQUksTUFBTSxFQUFFO2dCQUNSLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDakU7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUU7b0JBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztpQkFDdEQ7cUJBQU07b0JBQ0gsT0FBTyxLQUFLLENBQUM7aUJBQ2hCO2FBQ0o7UUFDTCxDQUFDLENBQUMsRUFDRixTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FDckUsQ0FBQztJQUNWLENBQUM7SUFFRDs7O09BR0c7SUFDSyxvQkFBb0IsQ0FBQyxPQUFlO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLO2FBQ3hCLGVBQWUsQ0FBQyxPQUFPLEVBQUU7WUFDdEIsTUFBTSxFQUFFO2dCQUNKLElBQUksRUFBRTtvQkFDRixFQUFFLEVBQUUsZ0JBQWdCLENBQUMsc0JBQXNCO2lCQUM5QzthQUNKO1lBQ0QsSUFBSSxFQUFFO2dCQUNGLFNBQVMsRUFBRSxTQUFTLENBQUMsSUFBSTthQUM1QjtTQUNKLENBQUM7YUFDRCxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO2FBQ2pDLElBQUksQ0FDRCxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDVCxNQUFNLElBQUksR0FBRyxNQUFNLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxXQUFXLENBQUMsQ0FBQztZQUN4RSxJQUFJLElBQUksRUFBRTtnQkFDTixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBYyxDQUFDO2FBQ25DO2lCQUFNO2dCQUNILE9BQU87YUFDVjtRQUNMLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDVixDQUFDO0lBRU8sd0JBQXdCLENBQUMsT0FBZSxFQUFFLEtBQWE7UUFDM0QsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUNoRSxHQUFHLENBQUMsQ0FBQyxFQUFFLHNCQUFzQixFQUFFLEVBQUUsRUFBRTtZQUMvQixRQUFRLHNCQUFzQixFQUFFLFVBQVUsRUFBRTtnQkFDeEMsS0FBSyxPQUFPO29CQUNSLE9BQU8sc0JBQXNCLEVBQUUsS0FBSyxDQUFDO2dCQUN6QyxLQUFLLDJCQUEyQjtvQkFDNUIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxzQkFBc0IsRUFBRSxlQUFlLENBQUMsQ0FBQztvQkFDeEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsRUFBRSxlQUFlLENBQUMsQ0FBQzthQUNoRTtRQUNMLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDTixDQUFDOzhHQWpIUSxzQkFBc0I7a0hBQXRCLHNCQUFzQixjQUZuQixNQUFNOzsyRkFFVCxzQkFBc0I7a0JBSGxDLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWFya2VyIGFzIF8gfSBmcm9tICdAYmllc2JqZXJnL25neC10cmFuc2xhdGUtZXh0cmFjdC1tYXJrZXInO1xuaW1wb3J0IHtcbiAgICBEYXRhU2VydmljZSxcbiAgICBIaXN0b3J5RW50cnlUeXBlLFxuICAgIEkxOG5TZXJ2aWNlLFxuICAgIE1vZGFsU2VydmljZSxcbiAgICBOb3RpZmljYXRpb25TZXJ2aWNlLFxuICAgIFNvcnRPcmRlcixcbn0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZGVsYXksIG1hcCwgcmV0cnlXaGVuLCBzd2l0Y2hNYXAsIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE9yZGVyU3RhdGVTZWxlY3REaWFsb2dDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzL29yZGVyLXN0YXRlLXNlbGVjdC1kaWFsb2cvb3JkZXItc3RhdGUtc2VsZWN0LWRpYWxvZy5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBPcmRlclRyYW5zaXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgbm90aWZpY2F0aW9uU2VydmljZTogTm90aWZpY2F0aW9uU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBpMThuU2VydmljZTogSTE4blNlcnZpY2UsXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gdHJhbnNpdGlvbiB0aGUgT3JkZXIgdG8gdGhlIGxhc3Qgc3RhdGUgaXQgd2FzIGluIGJlZm9yZSBpdCB3YXMgdHJhbnNpdGlvbmVkXG4gICAgICogdG8gdGhlIFwiTW9kaWZ5aW5nXCIgc3RhdGUuIElmIHRoaXMgZmFpbHMsIGEgbWFudWFsIHByb21wdCBpcyB1c2VkLlxuICAgICAqL1xuICAgIHRyYW5zaXRpb25Ub1ByZU1vZGlmeWluZ1N0YXRlKG9yZGVySWQ6IHN0cmluZywgbmV4dFN0YXRlczogc3RyaW5nW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJlTW9kaWZ5aW5nU3RhdGUob3JkZXJJZCkucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcChzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFudWFsVHJhbnNpdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVySWQsXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4blNlcnZpY2UudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgXygnb3JkZXIudW5hYmxlLXRvLXRyYW5zaXRpb24tdG8tc3RhdGUtdHJ5LWFub3RoZXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGUgfSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZXRyeTogMTAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvU3RhdGVPclRocm93KG9yZGVySWQsIHN0YXRlKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhpcy5tYW51YWxseVRyYW5zaXRpb25Ub1N0YXRlKG1hbnVhbFRyYW5zaXRpb25PcHRpb25zKSksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsbHlUcmFuc2l0aW9uVG9TdGF0ZShtYW51YWxUcmFuc2l0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYSBtb2RhbCBmb3IgbWFudWFsbHkgc2VsZWN0aW5nIHRoZSBuZXh0IHN0YXRlLlxuICAgICAqL1xuICAgIG1hbnVhbGx5VHJhbnNpdGlvblRvU3RhdGUob3B0aW9uczoge1xuICAgICAgICBvcmRlcklkOiBzdHJpbmc7XG4gICAgICAgIG5leHRTdGF0ZXM6IHN0cmluZ1tdO1xuICAgICAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgIGNhbmNlbGxhYmxlOiBib29sZWFuO1xuICAgICAgICByZXRyeTogbnVtYmVyO1xuICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kYWxTZXJ2aWNlXG4gICAgICAgICAgICAuZnJvbUNvbXBvbmVudChPcmRlclN0YXRlU2VsZWN0RGlhbG9nQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgbG9jYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZXM6IG9wdGlvbnMubmV4dFN0YXRlcyxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGFibGU6IG9wdGlvbnMuY2FuY2VsbGFibGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsb3NhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaXplOiAnbWQnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHN3aXRjaE1hcChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG9TdGF0ZU9yVGhyb3cob3B0aW9ucy5vcmRlcklkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvcmRlciBzdGF0ZSBtdXN0IGJlIHNlbGVjdGVkYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJldHJ5V2hlbihlcnJvcnMgPT4gZXJyb3JzLnBpcGUoZGVsYXkoMjAwMCksIHRha2Uob3B0aW9ucy5yZXRyeSkpKSxcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZ2V0IHRoZSBsYXN0IHN0YXRlIHRoZSBPcmRlciB3YXMgaW4gYmVmb3JlIGl0IHdhcyB0cmFuc2l0aW9uZWRcbiAgICAgKiB0byB0aGUgXCJNb2RpZnlpbmdcIiBzdGF0ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFByZU1vZGlmeWluZ1N0YXRlKG9yZGVySWQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5vcmRlclxuICAgICAgICAgICAgLmdldE9yZGVySGlzdG9yeShvcmRlcklkLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxOiBIaXN0b3J5RW50cnlUeXBlLk9SREVSX1NUQVRFX1RSQU5TSVRJT04sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogU29ydE9yZGVyLkRFU0MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwU2luZ2xlKHJlc3VsdCA9PiByZXN1bHQub3JkZXIpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHJlc3VsdD8uaGlzdG9yeS5pdGVtcy5maW5kKGkgPT4gaS5kYXRhLnRvID09PSAnTW9kaWZ5aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhLmZyb20gYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJhbnNpdGlvblRvU3RhdGVPclRocm93KG9yZGVySWQ6IHN0cmluZywgc3RhdGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5vcmRlci50cmFuc2l0aW9uVG9TdGF0ZShvcmRlcklkLCBzdGF0ZSkucGlwZShcbiAgICAgICAgICAgIG1hcCgoeyB0cmFuc2l0aW9uT3JkZXJUb1N0YXRlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zaXRpb25PcmRlclRvU3RhdGU/Ll9fdHlwZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnT3JkZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25PcmRlclRvU3RhdGU/LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdPcmRlclN0YXRlVHJhbnNpdGlvbkVycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uU2VydmljZS5lcnJvcih0cmFuc2l0aW9uT3JkZXJUb1N0YXRlPy50cmFuc2l0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zaXRpb25PcmRlclRvU3RhdGU/LnRyYW5zaXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19