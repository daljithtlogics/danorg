import { Inject, Injectable, Optional } from "@angular/core";
import { TranslateCompiler } from "@ngx-translate/core";
import MessageFormat from "@messageformat/core";
import { defaultConfig, MESSAGE_FORMAT_CONFIG, } from "./message-format-config";
import * as i0 from "@angular/core";
/**
 * This compiler expects ICU syntax and compiles the expressions with messageformat.js
 */
export class TranslateMessageFormatCompiler extends TranslateCompiler {
    constructor(config) {
        super();
        this.mfCache = new Map();
        const { formatters: customFormatters, biDiSupport, strictNumberSign: strict, currency, strictPluralKeys, } = {
            ...defaultConfig,
            ...config,
        };
        this.config = {
            customFormatters,
            biDiSupport,
            strict,
            currency,
            strictPluralKeys,
        };
    }
    compile(value, lang) {
        return this.getMessageFormatInstance(lang).compile(value);
    }
    compileTranslations(translations, lang) {
        if (typeof translations === "string") {
            return this.compile(translations, lang);
        }
        return Object.keys(translations).reduce((acc, key) => {
            const value = translations[key];
            return { ...acc, [key]: this.compileTranslations(value, lang) };
        }, {});
    }
    getMessageFormatInstance(locale) {
        if (!this.mfCache.has(locale)) {
            this.mfCache.set(locale, new MessageFormat(locale, this.config));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.mfCache.get(locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: TranslateMessageFormatCompiler, deps: [{ token: MESSAGE_FORMAT_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: TranslateMessageFormatCompiler }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.0", ngImport: i0, type: TranslateMessageFormatCompiler, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MESSAGE_FORMAT_CONFIG]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRlLW1lc3NhZ2UtZm9ybWF0LWNvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2xhdGUtbWVzc2FnZS1mb3JtYXQtY29tcGlsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3hELE9BQU8sYUFBdUMsTUFBTSxxQkFBcUIsQ0FBQztBQUMxRSxPQUFPLEVBQ0wsYUFBYSxFQUViLHFCQUFxQixHQUN0QixNQUFNLHlCQUF5QixDQUFDOztBQUVqQzs7R0FFRztBQUVILE1BQU0sT0FBTyw4QkFBK0IsU0FBUSxpQkFBaUI7SUFJbkUsWUFHRSxNQUE0QjtRQUU1QixLQUFLLEVBQUUsQ0FBQztRQVJGLFlBQU8sR0FBRyxJQUFJLEdBQUcsRUFBeUIsQ0FBQztRQVVqRCxNQUFNLEVBQ0osVUFBVSxFQUFFLGdCQUFnQixFQUM1QixXQUFXLEVBQ1gsZ0JBQWdCLEVBQUUsTUFBTSxFQUN4QixRQUFRLEVBQ1IsZ0JBQWdCLEdBQ2pCLEdBQUc7WUFDRixHQUFHLGFBQWE7WUFDaEIsR0FBRyxNQUFNO1NBQ1YsQ0FBQztRQUVGLElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixnQkFBZ0I7WUFDaEIsV0FBVztZQUNYLE1BQU07WUFDTixRQUFRO1lBQ1IsZ0JBQWdCO1NBQ2pCLENBQUM7SUFDSixDQUFDO0lBRU0sT0FBTyxDQUFDLEtBQWEsRUFBRSxJQUFZO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRU0sbUJBQW1CLENBQUMsWUFBaUIsRUFBRSxJQUFZO1FBQ3hELElBQUksT0FBTyxZQUFZLEtBQUssUUFBUSxFQUFFO1lBQ3BDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDekM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxDQUNyQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUNYLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQyxPQUFPLEVBQUUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDbEUsQ0FBQyxFQUNELEVBQUUsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVPLHdCQUF3QixDQUFDLE1BQWM7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLE1BQU0sRUFDTixJQUFJLGFBQWEsQ0FBVyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUNqRCxDQUFDO1NBQ0g7UUFFRCxvRUFBb0U7UUFDcEUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUUsQ0FBQztJQUNuQyxDQUFDOzhHQTNEVSw4QkFBOEIsa0JBTS9CLHFCQUFxQjtrSEFOcEIsOEJBQThCOzsyRkFBOUIsOEJBQThCO2tCQUQxQyxVQUFVOzswQkFNTixRQUFROzswQkFDUixNQUFNOzJCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgVHJhbnNsYXRlQ29tcGlsZXIgfSBmcm9tIFwiQG5neC10cmFuc2xhdGUvY29yZVwiO1xuaW1wb3J0IE1lc3NhZ2VGb3JtYXQsIHsgTWVzc2FnZUZvcm1hdE9wdGlvbnMgfSBmcm9tIFwiQG1lc3NhZ2Vmb3JtYXQvY29yZVwiO1xuaW1wb3J0IHtcbiAgZGVmYXVsdENvbmZpZyxcbiAgTWVzc2FnZUZvcm1hdENvbmZpZyxcbiAgTUVTU0FHRV9GT1JNQVRfQ09ORklHLFxufSBmcm9tIFwiLi9tZXNzYWdlLWZvcm1hdC1jb25maWdcIjtcblxuLyoqXG4gKiBUaGlzIGNvbXBpbGVyIGV4cGVjdHMgSUNVIHN5bnRheCBhbmQgY29tcGlsZXMgdGhlIGV4cHJlc3Npb25zIHdpdGggbWVzc2FnZWZvcm1hdC5qc1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRlTWVzc2FnZUZvcm1hdENvbXBpbGVyIGV4dGVuZHMgVHJhbnNsYXRlQ29tcGlsZXIge1xuICBwcml2YXRlIG1mQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgTWVzc2FnZUZvcm1hdD4oKTtcbiAgcHJpdmF0ZSBjb25maWc6IE1lc3NhZ2VGb3JtYXRPcHRpb25zPFwic3RyaW5nXCI+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChNRVNTQUdFX0ZPUk1BVF9DT05GSUcpXG4gICAgY29uZmlnPzogTWVzc2FnZUZvcm1hdENvbmZpZ1xuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3Qge1xuICAgICAgZm9ybWF0dGVyczogY3VzdG9tRm9ybWF0dGVycyxcbiAgICAgIGJpRGlTdXBwb3J0LFxuICAgICAgc3RyaWN0TnVtYmVyU2lnbjogc3RyaWN0LFxuICAgICAgY3VycmVuY3ksXG4gICAgICBzdHJpY3RQbHVyYWxLZXlzLFxuICAgIH0gPSB7XG4gICAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH07XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGN1c3RvbUZvcm1hdHRlcnMsXG4gICAgICBiaURpU3VwcG9ydCxcbiAgICAgIHN0cmljdCxcbiAgICAgIGN1cnJlbmN5LFxuICAgICAgc3RyaWN0UGx1cmFsS2V5cyxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNvbXBpbGUodmFsdWU6IHN0cmluZywgbGFuZzogc3RyaW5nKTogKHBhcmFtczogYW55KSA9PiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2VGb3JtYXRJbnN0YW5jZShsYW5nKS5jb21waWxlKHZhbHVlKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21waWxlVHJhbnNsYXRpb25zKHRyYW5zbGF0aW9uczogYW55LCBsYW5nOiBzdHJpbmcpOiBhbnkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlKHRyYW5zbGF0aW9ucywgbGFuZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRyYW5zbGF0aW9ucykucmVkdWNlPHsgW2tleTogc3RyaW5nXTogYW55IH0+KFxuICAgICAgKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNsYXRpb25zW2tleV07XG4gICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IHRoaXMuY29tcGlsZVRyYW5zbGF0aW9ucyh2YWx1ZSwgbGFuZykgfTtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldE1lc3NhZ2VGb3JtYXRJbnN0YW5jZShsb2NhbGU6IHN0cmluZyk6IE1lc3NhZ2VGb3JtYXQge1xuICAgIGlmICghdGhpcy5tZkNhY2hlLmhhcyhsb2NhbGUpKSB7XG4gICAgICB0aGlzLm1mQ2FjaGUuc2V0KFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG5ldyBNZXNzYWdlRm9ybWF0PFwic3RyaW5nXCI+KGxvY2FsZSwgdGhpcy5jb25maWcpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIHRoaXMubWZDYWNoZS5nZXQobG9jYWxlKSE7XG4gIH1cbn1cbiJdfQ==